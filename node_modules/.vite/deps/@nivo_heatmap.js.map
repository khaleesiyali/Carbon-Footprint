{
  "version": 3,
  "sources": ["../../lodash/uniq.js", "../../lodash/_baseIsDate.js", "../../lodash/isDate.js", "../../lodash/_baseFilter.js", "../../lodash/filter.js", "../../@nivo/axes/node_modules/d3-format/src/formatDecimal.js", "../../@nivo/axes/node_modules/d3-format/src/exponent.js", "../../@nivo/axes/node_modules/d3-format/src/formatGroup.js", "../../@nivo/axes/node_modules/d3-format/src/formatNumerals.js", "../../@nivo/axes/node_modules/d3-format/src/formatSpecifier.js", "../../@nivo/axes/node_modules/d3-format/src/formatTrim.js", "../../@nivo/axes/node_modules/d3-format/src/formatPrefixAuto.js", "../../@nivo/axes/node_modules/d3-format/src/formatRounded.js", "../../@nivo/axes/node_modules/d3-format/src/formatTypes.js", "../../@nivo/axes/node_modules/d3-format/src/identity.js", "../../@nivo/axes/node_modules/d3-format/src/locale.js", "../../@nivo/axes/node_modules/d3-format/src/defaultLocale.js", "../../@nivo/scales/src/timeHelpers.ts", "../../@nivo/scales/src/linearScale.ts", "../../@nivo/scales/src/pointScale.ts", "../../@nivo/scales/src/bandScale.ts", "../../@nivo/scales/src/timeScale.ts", "../../@nivo/scales/src/logScale.ts", "../../@nivo/scales/src/symlogScale.ts", "../../@nivo/scales/src/compute.ts", "../../@nivo/scales/src/ticks.ts", "../../@nivo/axes/src/compute.ts", "../../@nivo/axes/src/components/AxisTick.tsx", "../../@nivo/axes/src/components/Axis.tsx", "../../@nivo/axes/src/props.ts", "../../@nivo/axes/src/components/Axes.tsx", "../../@nivo/axes/src/components/GridLine.tsx", "../../@nivo/axes/src/components/GridLines.tsx", "../../@nivo/axes/src/components/Grid.tsx", "../../@nivo/axes/src/canvas.ts", "../../@nivo/annotations/src/props.ts", "../../@nivo/annotations/src/utils.ts", "../../@nivo/annotations/src/compute.ts", "../../@nivo/annotations/src/hooks.ts", "../../@nivo/annotations/src/AnnotationNote.tsx", "../../@nivo/annotations/src/AnnotationLink.tsx", "../../@nivo/annotations/src/CircleAnnotationOutline.tsx", "../../@nivo/annotations/src/DotAnnotationOutline.tsx", "../../@nivo/annotations/src/RectAnnotationOutline.tsx", "../../@nivo/annotations/src/Annotation.tsx", "../../@nivo/annotations/src/canvas.ts", "../../@nivo/heatmap/src/HeatMapTooltip.tsx", "../../@nivo/heatmap/src/defaults.ts", "../../@nivo/heatmap/src/compute.ts", "../../@nivo/heatmap/src/hooks.ts", "../../@nivo/heatmap/src/HeatMapCellRect.tsx", "../../@nivo/heatmap/src/HeatMapCellCircle.tsx", "../../@nivo/heatmap/src/HeatMapCells.tsx", "../../@nivo/heatmap/src/HeatMapCellAnnotations.tsx", "../../@nivo/heatmap/src/HeatMap.tsx", "../../@nivo/heatmap/src/ResponsiveHeatMap.tsx", "../../@nivo/heatmap/src/canvas.tsx", "../../@nivo/heatmap/src/HeatMapCanvas.tsx", "../../@nivo/heatmap/src/ResponsiveHeatMapCanvas.tsx"],
  "sourcesContent": ["var baseUniq = require('./_baseUniq');\n\n/**\n * Creates a duplicate-free version of an array, using\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * for equality comparisons, in which only the first occurrence of each element\n * is kept. The order of result values is determined by the order they occur\n * in the array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Array\n * @param {Array} array The array to inspect.\n * @returns {Array} Returns the new duplicate free array.\n * @example\n *\n * _.uniq([2, 1, 2]);\n * // => [2, 1]\n */\nfunction uniq(array) {\n  return (array && array.length) ? baseUniq(array) : [];\n}\n\nmodule.exports = uniq;\n", "var baseGetTag = require('./_baseGetTag'),\n    isObjectLike = require('./isObjectLike');\n\n/** `Object#toString` result references. */\nvar dateTag = '[object Date]';\n\n/**\n * The base implementation of `_.isDate` without Node.js optimizations.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n */\nfunction baseIsDate(value) {\n  return isObjectLike(value) && baseGetTag(value) == dateTag;\n}\n\nmodule.exports = baseIsDate;\n", "var baseIsDate = require('./_baseIsDate'),\n    baseUnary = require('./_baseUnary'),\n    nodeUtil = require('./_nodeUtil');\n\n/* Node.js helper references. */\nvar nodeIsDate = nodeUtil && nodeUtil.isDate;\n\n/**\n * Checks if `value` is classified as a `Date` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a date object, else `false`.\n * @example\n *\n * _.isDate(new Date);\n * // => true\n *\n * _.isDate('Mon April 23 2012');\n * // => false\n */\nvar isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;\n\nmodule.exports = isDate;\n", "var baseEach = require('./_baseEach');\n\n/**\n * The base implementation of `_.filter` without support for iteratee shorthands.\n *\n * @private\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} predicate The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n */\nfunction baseFilter(collection, predicate) {\n  var result = [];\n  baseEach(collection, function(value, index, collection) {\n    if (predicate(value, index, collection)) {\n      result.push(value);\n    }\n  });\n  return result;\n}\n\nmodule.exports = baseFilter;\n", "var arrayFilter = require('./_arrayFilter'),\n    baseFilter = require('./_baseFilter'),\n    baseIteratee = require('./_baseIteratee'),\n    isArray = require('./isArray');\n\n/**\n * Iterates over elements of `collection`, returning an array of all elements\n * `predicate` returns truthy for. The predicate is invoked with three\n * arguments: (value, index|key, collection).\n *\n * **Note:** Unlike `_.remove`, this method returns a new array.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Collection\n * @param {Array|Object} collection The collection to iterate over.\n * @param {Function} [predicate=_.identity] The function invoked per iteration.\n * @returns {Array} Returns the new filtered array.\n * @see _.reject\n * @example\n *\n * var users = [\n *   { 'user': 'barney', 'age': 36, 'active': true },\n *   { 'user': 'fred',   'age': 40, 'active': false }\n * ];\n *\n * _.filter(users, function(o) { return !o.active; });\n * // => objects for ['fred']\n *\n * // The `_.matches` iteratee shorthand.\n * _.filter(users, { 'age': 36, 'active': true });\n * // => objects for ['barney']\n *\n * // The `_.matchesProperty` iteratee shorthand.\n * _.filter(users, ['active', false]);\n * // => objects for ['fred']\n *\n * // The `_.property` iteratee shorthand.\n * _.filter(users, 'active');\n * // => objects for ['barney']\n *\n * // Combining several predicates using `_.overEvery` or `_.overSome`.\n * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));\n * // => objects for ['fred', 'barney']\n */\nfunction filter(collection, predicate) {\n  var func = isArray(collection) ? arrayFilter : baseFilter;\n  return func(collection, baseIteratee(predicate, 3));\n}\n\nmodule.exports = filter;\n", "export default function(x) {\n  return Math.abs(x = Math.round(x)) >= 1e21\n      ? x.toLocaleString(\"en\").replace(/,/g, \"\")\n      : x.toString(10);\n}\n\n// Computes the decimal coefficient and exponent of the specified number x with\n// significant digits p, where x is positive and p is in [1, 21] or undefined.\n// For example, formatDecimalParts(1.23) returns [\"123\", 0].\nexport function formatDecimalParts(x, p) {\n  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf(\"e\")) < 0) return null; // NaN, Â±Infinity\n  var i, coefficient = x.slice(0, i);\n\n  // The string returned by toExponential either has the form \\d\\.\\d+e[-+]\\d+\n  // (e.g., 1.2e+3) or the form \\de[-+]\\d+ (e.g., 1e+3).\n  return [\n    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,\n    +x.slice(i + 1)\n  ];\n}\n", "import {formatDecimalParts} from \"./formatDecimal.js\";\n\nexport default function(x) {\n  return x = formatDecimalParts(Math.abs(x)), x ? x[1] : NaN;\n}\n", "export default function(grouping, thousands) {\n  return function(value, width) {\n    var i = value.length,\n        t = [],\n        j = 0,\n        g = grouping[0],\n        length = 0;\n\n    while (i > 0 && g > 0) {\n      if (length + g + 1 > width) g = Math.max(1, width - length);\n      t.push(value.substring(i -= g, i + g));\n      if ((length += g + 1) > width) break;\n      g = grouping[j = (j + 1) % grouping.length];\n    }\n\n    return t.reverse().join(thousands);\n  };\n}\n", "export default function(numerals) {\n  return function(value) {\n    return value.replace(/[0-9]/g, function(i) {\n      return numerals[+i];\n    });\n  };\n}\n", "// [[fill]align][sign][symbol][0][width][,][.precision][~][type]\nvar re = /^(?:(.)?([<>=^]))?([+\\-( ])?([$#])?(0)?(\\d+)?(,)?(\\.\\d+)?(~)?([a-z%])?$/i;\n\nexport default function formatSpecifier(specifier) {\n  if (!(match = re.exec(specifier))) throw new Error(\"invalid format: \" + specifier);\n  var match;\n  return new FormatSpecifier({\n    fill: match[1],\n    align: match[2],\n    sign: match[3],\n    symbol: match[4],\n    zero: match[5],\n    width: match[6],\n    comma: match[7],\n    precision: match[8] && match[8].slice(1),\n    trim: match[9],\n    type: match[10]\n  });\n}\n\nformatSpecifier.prototype = FormatSpecifier.prototype; // instanceof\n\nexport function FormatSpecifier(specifier) {\n  this.fill = specifier.fill === undefined ? \" \" : specifier.fill + \"\";\n  this.align = specifier.align === undefined ? \">\" : specifier.align + \"\";\n  this.sign = specifier.sign === undefined ? \"-\" : specifier.sign + \"\";\n  this.symbol = specifier.symbol === undefined ? \"\" : specifier.symbol + \"\";\n  this.zero = !!specifier.zero;\n  this.width = specifier.width === undefined ? undefined : +specifier.width;\n  this.comma = !!specifier.comma;\n  this.precision = specifier.precision === undefined ? undefined : +specifier.precision;\n  this.trim = !!specifier.trim;\n  this.type = specifier.type === undefined ? \"\" : specifier.type + \"\";\n}\n\nFormatSpecifier.prototype.toString = function() {\n  return this.fill\n      + this.align\n      + this.sign\n      + this.symbol\n      + (this.zero ? \"0\" : \"\")\n      + (this.width === undefined ? \"\" : Math.max(1, this.width | 0))\n      + (this.comma ? \",\" : \"\")\n      + (this.precision === undefined ? \"\" : \".\" + Math.max(0, this.precision | 0))\n      + (this.trim ? \"~\" : \"\")\n      + this.type;\n};\n", "// Trims insignificant zeros, e.g., replaces 1.2000k with 1.2k.\nexport default function(s) {\n  out: for (var n = s.length, i = 1, i0 = -1, i1; i < n; ++i) {\n    switch (s[i]) {\n      case \".\": i0 = i1 = i; break;\n      case \"0\": if (i0 === 0) i0 = i; i1 = i; break;\n      default: if (!+s[i]) break out; if (i0 > 0) i0 = 0; break;\n    }\n  }\n  return i0 > 0 ? s.slice(0, i0) + s.slice(i1 + 1) : s;\n}\n", "import {formatDecimalParts} from \"./formatDecimal.js\";\n\nexport var prefixExponent;\n\nexport default function(x, p) {\n  var d = formatDecimalParts(x, p);\n  if (!d) return x + \"\";\n  var coefficient = d[0],\n      exponent = d[1],\n      i = exponent - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,\n      n = coefficient.length;\n  return i === n ? coefficient\n      : i > n ? coefficient + new Array(i - n + 1).join(\"0\")\n      : i > 0 ? coefficient.slice(0, i) + \".\" + coefficient.slice(i)\n      : \"0.\" + new Array(1 - i).join(\"0\") + formatDecimalParts(x, Math.max(0, p + i - 1))[0]; // less than 1y!\n}\n", "import {formatDecimalParts} from \"./formatDecimal.js\";\n\nexport default function(x, p) {\n  var d = formatDecimalParts(x, p);\n  if (!d) return x + \"\";\n  var coefficient = d[0],\n      exponent = d[1];\n  return exponent < 0 ? \"0.\" + new Array(-exponent).join(\"0\") + coefficient\n      : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + \".\" + coefficient.slice(exponent + 1)\n      : coefficient + new Array(exponent - coefficient.length + 2).join(\"0\");\n}\n", "import formatDecimal from \"./formatDecimal.js\";\nimport formatPrefixAuto from \"./formatPrefixAuto.js\";\nimport formatRounded from \"./formatRounded.js\";\n\nexport default {\n  \"%\": function(x, p) { return (x * 100).toFixed(p); },\n  \"b\": function(x) { return Math.round(x).toString(2); },\n  \"c\": function(x) { return x + \"\"; },\n  \"d\": formatDecimal,\n  \"e\": function(x, p) { return x.toExponential(p); },\n  \"f\": function(x, p) { return x.toFixed(p); },\n  \"g\": function(x, p) { return x.toPrecision(p); },\n  \"o\": function(x) { return Math.round(x).toString(8); },\n  \"p\": function(x, p) { return formatRounded(x * 100, p); },\n  \"r\": formatRounded,\n  \"s\": formatPrefixAuto,\n  \"X\": function(x) { return Math.round(x).toString(16).toUpperCase(); },\n  \"x\": function(x) { return Math.round(x).toString(16); }\n};\n", "export default function(x) {\n  return x;\n}\n", "import exponent from \"./exponent.js\";\nimport formatGroup from \"./formatGroup.js\";\nimport formatNumerals from \"./formatNumerals.js\";\nimport formatSpecifier from \"./formatSpecifier.js\";\nimport formatTrim from \"./formatTrim.js\";\nimport formatTypes from \"./formatTypes.js\";\nimport {prefixExponent} from \"./formatPrefixAuto.js\";\nimport identity from \"./identity.js\";\n\nvar map = Array.prototype.map,\n    prefixes = [\"y\",\"z\",\"a\",\"f\",\"p\",\"n\",\"Âµ\",\"m\",\"\",\"k\",\"M\",\"G\",\"T\",\"P\",\"E\",\"Z\",\"Y\"];\n\nexport default function(locale) {\n  var group = locale.grouping === undefined || locale.thousands === undefined ? identity : formatGroup(map.call(locale.grouping, Number), locale.thousands + \"\"),\n      currencyPrefix = locale.currency === undefined ? \"\" : locale.currency[0] + \"\",\n      currencySuffix = locale.currency === undefined ? \"\" : locale.currency[1] + \"\",\n      decimal = locale.decimal === undefined ? \".\" : locale.decimal + \"\",\n      numerals = locale.numerals === undefined ? identity : formatNumerals(map.call(locale.numerals, String)),\n      percent = locale.percent === undefined ? \"%\" : locale.percent + \"\",\n      minus = locale.minus === undefined ? \"-\" : locale.minus + \"\",\n      nan = locale.nan === undefined ? \"NaN\" : locale.nan + \"\";\n\n  function newFormat(specifier) {\n    specifier = formatSpecifier(specifier);\n\n    var fill = specifier.fill,\n        align = specifier.align,\n        sign = specifier.sign,\n        symbol = specifier.symbol,\n        zero = specifier.zero,\n        width = specifier.width,\n        comma = specifier.comma,\n        precision = specifier.precision,\n        trim = specifier.trim,\n        type = specifier.type;\n\n    // The \"n\" type is an alias for \",g\".\n    if (type === \"n\") comma = true, type = \"g\";\n\n    // The \"\" type, and any invalid type, is an alias for \".12~g\".\n    else if (!formatTypes[type]) precision === undefined && (precision = 12), trim = true, type = \"g\";\n\n    // If zero fill is specified, padding goes after sign and before digits.\n    if (zero || (fill === \"0\" && align === \"=\")) zero = true, fill = \"0\", align = \"=\";\n\n    // Compute the prefix and suffix.\n    // For SI-prefix, the suffix is lazily computed.\n    var prefix = symbol === \"$\" ? currencyPrefix : symbol === \"#\" && /[boxX]/.test(type) ? \"0\" + type.toLowerCase() : \"\",\n        suffix = symbol === \"$\" ? currencySuffix : /[%p]/.test(type) ? percent : \"\";\n\n    // What format function should we use?\n    // Is this an integer type?\n    // Can this type generate exponential notation?\n    var formatType = formatTypes[type],\n        maybeSuffix = /[defgprs%]/.test(type);\n\n    // Set the default precision if not specified,\n    // or clamp the specified precision to the supported range.\n    // For significant precision, it must be in [1, 21].\n    // For fixed precision, it must be in [0, 20].\n    precision = precision === undefined ? 6\n        : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision))\n        : Math.max(0, Math.min(20, precision));\n\n    function format(value) {\n      var valuePrefix = prefix,\n          valueSuffix = suffix,\n          i, n, c;\n\n      if (type === \"c\") {\n        valueSuffix = formatType(value) + valueSuffix;\n        value = \"\";\n      } else {\n        value = +value;\n\n        // Determine the sign. -0 is not less than 0, but 1 / -0 is!\n        var valueNegative = value < 0 || 1 / value < 0;\n\n        // Perform the initial formatting.\n        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);\n\n        // Trim insignificant zeros.\n        if (trim) value = formatTrim(value);\n\n        // If a negative value rounds to zero after formatting, and no explicit positive sign is requested, hide the sign.\n        if (valueNegative && +value === 0 && sign !== \"+\") valueNegative = false;\n\n        // Compute the prefix and suffix.\n        valuePrefix = (valueNegative ? (sign === \"(\" ? sign : minus) : sign === \"-\" || sign === \"(\" ? \"\" : sign) + valuePrefix;\n        valueSuffix = (type === \"s\" ? prefixes[8 + prefixExponent / 3] : \"\") + valueSuffix + (valueNegative && sign === \"(\" ? \")\" : \"\");\n\n        // Break the formatted value into the integer âvalueâ part that can be\n        // grouped, and fractional or exponential âsuffixâ part that is not.\n        if (maybeSuffix) {\n          i = -1, n = value.length;\n          while (++i < n) {\n            if (c = value.charCodeAt(i), 48 > c || c > 57) {\n              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;\n              value = value.slice(0, i);\n              break;\n            }\n          }\n        }\n      }\n\n      // If the fill character is not \"0\", grouping is applied before padding.\n      if (comma && !zero) value = group(value, Infinity);\n\n      // Compute the padding.\n      var length = valuePrefix.length + value.length + valueSuffix.length,\n          padding = length < width ? new Array(width - length + 1).join(fill) : \"\";\n\n      // If the fill character is \"0\", grouping is applied after padding.\n      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = \"\";\n\n      // Reconstruct the final output based on the desired alignment.\n      switch (align) {\n        case \"<\": value = valuePrefix + value + valueSuffix + padding; break;\n        case \"=\": value = valuePrefix + padding + value + valueSuffix; break;\n        case \"^\": value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length); break;\n        default: value = padding + valuePrefix + value + valueSuffix; break;\n      }\n\n      return numerals(value);\n    }\n\n    format.toString = function() {\n      return specifier + \"\";\n    };\n\n    return format;\n  }\n\n  function formatPrefix(specifier, value) {\n    var f = newFormat((specifier = formatSpecifier(specifier), specifier.type = \"f\", specifier)),\n        e = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3,\n        k = Math.pow(10, -e),\n        prefix = prefixes[8 + e / 3];\n    return function(value) {\n      return f(k * value) + prefix;\n    };\n  }\n\n  return {\n    format: newFormat,\n    formatPrefix: formatPrefix\n  };\n}\n", "import formatLocale from \"./locale.js\";\n\nvar locale;\nexport var format;\nexport var formatPrefix;\n\ndefaultLocale({\n  decimal: \".\",\n  thousands: \",\",\n  grouping: [3],\n  currency: [\"$\", \"\"],\n  minus: \"-\"\n});\n\nexport default function defaultLocale(definition) {\n  locale = formatLocale(definition);\n  format = locale.format;\n  formatPrefix = locale.formatPrefix;\n  return locale;\n}\n", "import { timeParse, utcParse } from 'd3-time-format'\n\nexport const timePrecisions = [\n    'millisecond',\n    'second',\n    'minute',\n    'hour',\n    'day',\n    'month',\n    'year',\n] as const\n\nexport type TIME_PRECISION = (typeof timePrecisions)[number]\n\nexport const precisionCutOffs: ((date: Date) => void)[] = [\n    date => date.setMilliseconds(0),\n    date => date.setSeconds(0),\n    date => date.setMinutes(0),\n    date => date.setHours(0),\n    date => date.setDate(1),\n    date => date.setMonth(0),\n]\n\nexport const precisionCutOffsByType: Record<TIME_PRECISION, ((date: Date) => void)[]> = {\n    millisecond: [],\n    second: precisionCutOffs.slice(0, 1),\n    minute: precisionCutOffs.slice(0, 2),\n    hour: precisionCutOffs.slice(0, 3),\n    day: precisionCutOffs.slice(0, 4),\n    month: precisionCutOffs.slice(0, 5),\n    year: precisionCutOffs.slice(0, 6),\n}\n\nexport const createPrecisionMethod = (precision: TIME_PRECISION) => (date: Date) => {\n    precisionCutOffsByType[precision].forEach(cutOff => {\n        cutOff(date)\n    })\n\n    return date\n}\n\nexport const createDateNormalizer = ({\n    format = 'native',\n    precision = 'millisecond',\n    useUTC = true,\n}: {\n    format?: 'native' | string\n    precision?: TIME_PRECISION\n    useUTC?: boolean\n}) => {\n    const precisionFn = createPrecisionMethod(precision)\n\n    return (value: Date | string | undefined) => {\n        if (value === undefined) {\n            return value\n        }\n\n        if (format === 'native' || value instanceof Date) {\n            return precisionFn(value as Date)\n        }\n\n        const parseTime = useUTC ? utcParse(format) : timeParse(format)\n        return precisionFn(parseTime(value as string) as Date)\n    }\n}\n", "import { NumberValue, scaleLinear, ScaleLinear as D3ScaleLinear } from 'd3-scale'\nimport { ScaleLinearSpec, ScaleLinear, ComputedSerieAxis, ScaleAxis } from './types'\n\nexport const createLinearScale = <Output extends NumberValue>(\n    {\n        min = 0,\n        max = 'auto',\n        stacked = false,\n        reverse = false,\n        clamp = false,\n        nice = false,\n    }: ScaleLinearSpec,\n    data: ComputedSerieAxis<Output>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    let minValue: NumberValue\n    if (min === 'auto') {\n        minValue = stacked === true ? data.minStacked ?? 0 : data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: NumberValue\n    if (max === 'auto') {\n        maxValue = stacked === true ? data.maxStacked ?? 0 : data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleLinear<number, Output>()\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .domain(reverse ? [maxValue, minValue] : [minValue, maxValue])\n        .clamp(clamp)\n\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'number') scale.nice(nice)\n\n    return castLinearScale<number, Output>(scale, stacked)\n}\n\nexport const castLinearScale = <Range, Output>(\n    scale: D3ScaleLinear<Range, Output>,\n    stacked = false\n) => {\n    const typedScale = scale as unknown as ScaleLinear<number>\n    typedScale.type = 'linear'\n    typedScale.stacked = stacked\n\n    return typedScale\n}\n", "import { scalePoint, ScalePoint as D3ScalePoint } from 'd3-scale'\nimport { ComputedSerieAxis, ScalePoint, ScalePointSpec, StringValue } from './types'\n\nexport const createPointScale = <Input extends StringValue>(\n    _spec: ScalePointSpec,\n    data: ComputedSerieAxis<Input>,\n    size: number\n) => {\n    const scale = scalePoint<Input>().range([0, size]).domain(data.all)\n\n    const typedScale = scale as ScalePoint<Input>\n    typedScale.type = 'point'\n\n    return typedScale\n}\n\nexport const castPointScale = <Input extends StringValue>(scale: D3ScalePoint<Input>) => {\n    const typedScale = scale as ScalePoint<Input>\n    typedScale.type = 'point'\n\n    return typedScale\n}\n", "import { scaleBand, ScaleBand as D3ScaleBand } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleBand, ScaleBandSpec, StringValue, ScaleAxis } from './types'\n\nexport const createBandScale = <Input extends StringValue>(\n    { round = true }: ScaleBandSpec,\n    data: ComputedSerieAxis<Input>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    const scale = scaleBand<Input>()\n        .range(axis === 'x' ? [0, size] : [size, 0])\n        .domain(data.all)\n        .round(round)\n\n    return castBandScale<Input>(scale)\n}\n\nexport const castBandScale = <Input extends StringValue>(scale: D3ScaleBand<Input>) => {\n    const typedScale = scale as ScaleBand<Input>\n    typedScale.type = 'band'\n\n    return typedScale\n}\n", "import { NumberValue, scaleTime, scaleUtc } from 'd3-scale'\nimport { createDateNormalizer } from './timeHelpers'\nimport { ComputedSerieAxis, ScaleTime, ScaleTimeSpec } from './types'\n\nexport const createTimeScale = <Input extends Date | NumberValue>(\n    {\n        format = 'native',\n        precision = 'millisecond',\n        min = 'auto',\n        max = 'auto',\n        useUTC = true,\n        nice = false,\n    }: ScaleTimeSpec,\n    data: ComputedSerieAxis<string | Date>,\n    size: number\n) => {\n    const normalize = createDateNormalizer({ format, precision, useUTC })\n\n    let minValue: Date | undefined\n    if (min === 'auto') {\n        minValue = normalize(data.min)\n    } else if (format !== 'native') {\n        minValue = normalize(min)\n    } else {\n        minValue = min as Date\n    }\n\n    let maxValue: Date | undefined\n    if (max === 'auto') {\n        maxValue = normalize(data.max)\n    } else if (format !== 'native') {\n        maxValue = normalize(max)\n    } else {\n        maxValue = max as Date\n    }\n\n    const scale = useUTC ? scaleUtc() : scaleTime()\n\n    scale.range([0, size])\n\n    if (minValue && maxValue) scale.domain([minValue, maxValue])\n\n    if (nice === true) scale.nice()\n    else if (typeof nice === 'object' || typeof nice === 'number') scale.nice(nice)\n\n    const typedScale = scale as unknown as ScaleTime<Input>\n\n    typedScale.type = 'time'\n    typedScale.useUTC = useUTC\n\n    return typedScale\n}\n", "import { scaleLog } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleAxis, ScaleLog, ScaleLogSpec } from './types'\n\nexport const createLogScale = (\n    { base = 10, min = 'auto', max = 'auto' }: ScaleLogSpec,\n    data: ComputedSerieAxis<number>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    const hasZero = data.all.some(v => v === 0)\n    if (hasZero) {\n        throw new Error(`a log scale domain must not include or cross zero`)\n    }\n\n    let sign: number\n    let hasMixedSign = false\n    data.all\n        .filter(v => v != null)\n        .forEach(v => {\n            if (hasMixedSign) return\n            if (sign === undefined) {\n                sign = Math.sign(v)\n            } else if (Math.sign(v) !== sign) {\n                hasMixedSign = true\n            }\n        })\n\n    if (hasMixedSign) {\n        throw new Error(`a log scale domain must be strictly-positive or strictly-negative`)\n    }\n\n    let minValue: number\n    if (min === 'auto') {\n        minValue = data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: number\n    if (max === 'auto') {\n        maxValue = data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleLog<number, number>()\n        .domain([minValue, maxValue])\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .base(base)\n        .nice()\n\n    const typedScale = scale as ScaleLog\n    typedScale.type = 'log'\n\n    return typedScale\n}\n", "import { scaleSymlog } from 'd3-scale'\nimport { ComputedSerieAxis, ScaleAxis, ScaleSymlog, ScaleSymlogSpec } from './types'\n\nexport const createSymlogScale = (\n    { constant = 1, min = 'auto', max = 'auto', reverse = false }: ScaleSymlogSpec,\n    data: ComputedSerieAxis<number>,\n    size: number,\n    axis: ScaleAxis\n) => {\n    let minValue: number\n    if (min === 'auto') {\n        minValue = data.min\n    } else {\n        minValue = min\n    }\n\n    let maxValue: number\n    if (max === 'auto') {\n        maxValue = data.max\n    } else {\n        maxValue = max\n    }\n\n    const scale = scaleSymlog<number, number>()\n        .constant(constant)\n        .rangeRound(axis === 'x' ? [0, size] : [size, 0])\n        .nice()\n\n    if (reverse === true) scale.domain([maxValue, minValue])\n    else scale.domain([minValue, maxValue])\n\n    const typedScale = scale as ScaleSymlog\n    typedScale.type = 'symlog'\n\n    return typedScale\n}\n", "import uniq from 'lodash/uniq'\nimport uniqBy from 'lodash/uniqBy'\nimport sortBy from 'lodash/sortBy'\nimport last from 'lodash/last'\nimport isDate from 'lodash/isDate'\nimport { createDateNormalizer } from './timeHelpers'\nimport { ScaleAxis, ScaleSpec, ScaleValue, SerieAxis, ComputedSerieAxis } from './types'\nimport { createLinearScale } from './linearScale'\nimport { createPointScale } from './pointScale'\nimport { createBandScale } from './bandScale'\nimport { createTimeScale } from './timeScale'\nimport { createLogScale } from './logScale'\nimport { createSymlogScale } from './symlogScale'\n\ntype XY = ReturnType<typeof generateSeriesXY>\n\ntype StackedXY = {\n    [K in keyof XY]: XY[K] & {\n        maxStacked: number\n        minStacked: number\n    }\n}\n\ninterface SerieDatum {\n    x: number | string | Date\n    // only numbers can be stacked\n    xStacked?: number | null\n    y: number | string | Date\n    // only numbers can be stacked\n    yStacked?: number | null\n}\n\ntype Serie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: D[]\n}\n\ntype NestedSerie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: {\n        data: D\n    }[]\n}\n\nexport type ComputedSerie<S = never, D extends SerieDatum = SerieDatum> = S & {\n    data: {\n        data: D\n        position: {\n            x: number | null\n            y: number | null\n        }\n    }[]\n}\n\ntype Compare = <T>(a: T, b: T) => boolean\n\nexport const getOtherAxis = (axis: ScaleAxis): ScaleAxis => (axis === 'x' ? 'y' : 'x')\n\nexport const compareValues = (a: string | number, b: string | number) => a === b\nexport const compareDateValues = (a: Date, b: Date) => a.getTime() === b.getTime()\n\nexport function computeScale<Input extends ScaleValue>(\n    spec: ScaleSpec,\n    data: ComputedSerieAxis<any>,\n    size: number,\n    axis: ScaleAxis\n) {\n    switch (spec.type) {\n        case 'linear':\n            return createLinearScale(spec, data, size, axis)\n        case 'point':\n            return createPointScale<Input>(spec, data, size)\n        case 'band':\n            return createBandScale<Input>(spec, data, size, axis)\n        case 'time':\n            return createTimeScale(spec, data, size)\n        case 'log':\n            return createLogScale(spec, data, size, axis)\n        case 'symlog':\n            return createSymlogScale(spec, data, size, axis)\n        default:\n            throw new Error('invalid scale spec')\n    }\n}\n\n/**\n * Convert serie data to have the original data stored in a nested prop.\n *\n * We do this in order to avoid conflicts between raw & computed properties.\n * <- { data: { x: 1, y: 3 }[] }\n * -> { data: { data: { x: 1, y: 3 } }[] }\n */\nconst nestSerieData = <S = never, D extends SerieDatum = SerieDatum>(\n    serie: Serie<S, D>\n): NestedSerie<S, D> => ({\n    ...serie,\n    data: serie.data.map(d => ({ data: { ...d } })),\n})\n\nconst getDatumAxisPosition = <D extends SerieDatum = SerieDatum>(\n    datum: { data: D },\n    axis: ScaleAxis,\n    scale: any\n): number | null => {\n    if ('stacked' in scale && scale.stacked) {\n        const stackedValue = datum.data[axis === 'x' ? 'xStacked' : 'yStacked']\n        if (stackedValue === null || stackedValue === undefined) {\n            return null\n        }\n\n        return scale(stackedValue)\n    }\n\n    return scale(datum.data[axis]) ?? null\n}\n\n/**\n * Compute x/y d3 scales from an array of data series, and scale specifications.\n *\n * We use generics as it's not uncommon to have extra properties such as an id\n * added to the series, or extra props on data, in such case, you should override\n * the default types.\n */\nexport const computeXYScalesForSeries = <S = never, D extends SerieDatum = SerieDatum>(\n    series: Serie<S, D>[],\n    xScaleSpec: ScaleSpec,\n    yScaleSpec: ScaleSpec,\n    width: number,\n    height: number\n) => {\n    // first nest series to avoid property conflicts\n    const nestedSeries = series.map(serie => nestSerieData<S, D>(serie))\n\n    // then compute data for each axis: all, min, max values\n    const xy = generateSeriesXY<S, D>(nestedSeries, xScaleSpec, yScaleSpec)\n\n    // stack x values depending on xScale\n    if ('stacked' in xScaleSpec && xScaleSpec.stacked === true) {\n        stackX<S, D>(xy as StackedXY, nestedSeries)\n    }\n\n    // stack y values depending on yScale\n    if ('stacked' in yScaleSpec && yScaleSpec.stacked === true) {\n        stackY<S, D>(xy as StackedXY, nestedSeries)\n    }\n\n    // computes scales\n    const xScale = computeScale<D['x']>(xScaleSpec, xy.x, width, 'x')\n    const yScale = computeScale<D['y']>(yScaleSpec, xy.y, height, 'y')\n\n    // assign position to each datum in every scale\n    const computedSeries: ComputedSerie<S, D>[] = nestedSeries.map(serie => ({\n        ...serie,\n        data: serie.data.map(datum => ({\n            ...datum,\n            position: {\n                x: getDatumAxisPosition(datum, 'x', xScale),\n                y: getDatumAxisPosition(datum, 'y', yScale),\n            },\n        })),\n    }))\n\n    return {\n        ...xy,\n        series: computedSeries,\n        xScale,\n        yScale,\n    }\n}\n\nexport const generateSeriesXY = <S = never, D extends SerieDatum = SerieDatum>(\n    series: NestedSerie<S, D>[],\n    xScaleSpec: ScaleSpec,\n    yScaleSpec: ScaleSpec\n) => ({\n    x: generateSeriesAxis<'x', D['x']>(series, 'x', xScaleSpec),\n    y: generateSeriesAxis<'y', D['y']>(series, 'y', yScaleSpec),\n})\n\n/**\n * Normalize data according to scale type, (time => Date, linear => Number)\n * compute sorted unique values and min/max.\n */\nexport const generateSeriesAxis = <Axis extends ScaleAxis, Value extends ScaleValue>(\n    series: SerieAxis<Axis, Value>,\n    axis: Axis,\n    scaleSpec: ScaleSpec,\n    {\n        getValue = d => d.data[axis],\n        setValue = (d, v) => {\n            d.data[axis] = v\n        },\n    }: {\n        getValue?: (d: { data: Record<Axis, Value | null> }) => Value | null\n        setValue?: (d: { data: Record<Axis, Value | null> }, v: Value) => void\n    } = {}\n) => {\n    if (scaleSpec.type === 'linear') {\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                const value = getValue(d)\n\n                if (value) {\n                    setValue(d, parseFloat(String(value)) as unknown as Value)\n                }\n            })\n        })\n    } else if (scaleSpec.type === 'time' && scaleSpec.format !== 'native') {\n        // `native` means we already have Date instances,\n        // otherwise we have to convert the values to Date.\n        const parseTime = createDateNormalizer(scaleSpec)\n\n        series.forEach(serie => {\n            serie.data.forEach(d => {\n                const value = getValue(d)\n\n                if (value) {\n                    setValue(d, parseTime(value as Date) as unknown as Value)\n                }\n            })\n        })\n    }\n\n    const values: unknown[] = []\n\n    series.forEach(serie => {\n        serie.data.forEach(d => {\n            values.push(getValue(d))\n        })\n    })\n\n    switch (scaleSpec.type) {\n        case 'linear': {\n            const all = sortBy(\n                // filer null values to deal with holes in linechart\n                uniq(values as number[]).filter(v => v !== null),\n                v => v\n            )\n\n            return { all, min: Math.min(...all), max: Math.max(...all) }\n        }\n        case 'time': {\n            const all = uniqBy(values as Date[], v => v.getTime())\n                .slice(0)\n                .sort((a, b) => b.getTime() - a.getTime())\n                .reverse()\n\n            return { all, min: all[0], max: last(all) }\n        }\n        default: {\n            const all = uniq(values)\n\n            return { all, min: all[0], max: last(all) }\n        }\n    }\n}\n\nexport const stackAxis = <S = never, D extends SerieDatum = SerieDatum>(\n    axis: ScaleAxis,\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => {\n    const otherAxis = getOtherAxis(axis)\n    const all: number[] = []\n\n    xy[otherAxis].all.forEach(v => {\n        const compare = (isDate(v) ? compareDateValues : compareValues) as Compare\n        const stack: Array<number | null> = []\n\n        series.forEach(serie => {\n            const datum = serie.data.find(d => compare(d.data[otherAxis], v))\n            let value = null\n            let stackValue = null\n\n            if (datum !== undefined) {\n                // stacked values only support numbers\n                value = datum.data[axis] as number\n                if (value !== null) {\n                    const head = last(stack)\n                    if (head === undefined) {\n                        stackValue = value\n                    } else if (head !== null) {\n                        stackValue = head + value\n                    }\n                }\n\n                datum.data[axis === 'x' ? 'xStacked' : 'yStacked'] = stackValue\n            }\n\n            stack.push(stackValue)\n\n            if (stackValue !== null) {\n                all.push(stackValue)\n            }\n        })\n    })\n\n    xy[axis].minStacked = Math.min(...all)\n    xy[axis].maxStacked = Math.max(...all)\n}\n\nconst stackX = <S = never, D extends SerieDatum = SerieDatum>(\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => stackAxis<S, D>('x', xy, series)\n\nconst stackY = <S = never, D extends SerieDatum = SerieDatum>(\n    xy: StackedXY,\n    series: NestedSerie<S, D>[]\n) => stackAxis<S, D>('y', xy, series)\n", "import {\n    CountableTimeInterval,\n    timeMillisecond,\n    utcMillisecond,\n    timeSecond,\n    utcSecond,\n    timeMinute,\n    utcMinute,\n    timeHour,\n    utcHour,\n    timeWeek,\n    utcWeek,\n    timeSunday,\n    utcSunday,\n    timeMonday,\n    utcMonday,\n    timeTuesday,\n    utcTuesday,\n    timeWednesday,\n    utcWednesday,\n    timeThursday,\n    utcThursday,\n    timeFriday,\n    utcFriday,\n    timeSaturday,\n    utcSaturday,\n    timeMonth,\n    utcMonth,\n    timeYear,\n    utcYear,\n    timeInterval,\n} from 'd3-time'\nimport { ScaleValue, TicksSpec, AnyScale, ScaleWithBandwidth } from './types'\n\nexport const centerScale = <Value>(scale: ScaleWithBandwidth) => {\n    const bandwidth = scale.bandwidth()\n\n    if (bandwidth === 0) return scale\n\n    let offset = bandwidth / 2\n    if (scale.round()) {\n        offset = Math.round(offset)\n    }\n\n    return <T extends Value>(d: T) => (scale(d) ?? 0) + offset\n}\n\nconst timeDay = timeInterval(\n    date => date.setHours(0, 0, 0, 0),\n    (date, step) => date.setDate(date.getDate() + step),\n    (start, end) => (end.getTime() - start.getTime()) / 864e5,\n    date => Math.floor(date.getTime() / 864e5)\n)\n\nconst utcDay = timeInterval(\n    date => date.setUTCHours(0, 0, 0, 0),\n    (date, step) => date.setUTCDate(date.getUTCDate() + step),\n    (start, end) => (end.getTime() - start.getTime()) / 864e5,\n    date => Math.floor(date.getTime() / 864e5)\n)\n\nconst timeByType: Record<string, [CountableTimeInterval, CountableTimeInterval]> = {\n    millisecond: [timeMillisecond, utcMillisecond],\n    second: [timeSecond, utcSecond],\n    minute: [timeMinute, utcMinute],\n    hour: [timeHour, utcHour],\n    day: [timeDay, utcDay],\n    week: [timeWeek, utcWeek],\n    sunday: [timeSunday, utcSunday],\n    monday: [timeMonday, utcMonday],\n    tuesday: [timeTuesday, utcTuesday],\n    wednesday: [timeWednesday, utcWednesday],\n    thursday: [timeThursday, utcThursday],\n    friday: [timeFriday, utcFriday],\n    saturday: [timeSaturday, utcSaturday],\n    month: [timeMonth, utcMonth],\n    year: [timeYear, utcYear],\n}\n\nconst timeTypes = Object.keys(timeByType)\nconst timeIntervalRegexp = new RegExp(`^every\\\\s*(\\\\d+)?\\\\s*(${timeTypes.join('|')})s?$`, 'i')\n\nconst isInteger = (value: unknown): value is number =>\n    typeof value === 'number' && isFinite(value) && Math.floor(value) === value\n\nexport const getScaleTicks = <Value extends ScaleValue>(\n    scale: AnyScale,\n    spec?: TicksSpec<Value>\n) => {\n    // specific values\n    if (Array.isArray(spec)) {\n        return spec\n    }\n\n    if (typeof spec === 'string' && 'useUTC' in scale) {\n        // time interval\n        const matches = spec.match(timeIntervalRegexp)\n\n        if (matches) {\n            const [, amount, type] = matches\n            // UTC is used as it's more predictable\n            // however local time could be used too\n            // let's see how it fits users' requirements\n            const timeType = timeByType[type][scale.useUTC ? 1 : 0]\n\n            if (type === 'day') {\n                const [start, originalStop] = scale.domain()\n                const stop = new Date(originalStop)\n\n                // Set range to include last day in the domain since `interval.range` function is exclusive stop\n                stop.setDate(stop.getDate() + 1)\n\n                return timeType.every(Number(amount ?? 1))?.range(start, stop) ?? []\n            }\n\n            if (amount === undefined) {\n                return scale.ticks(timeType)\n            }\n\n            const interval = timeType.every(Number(amount))\n\n            if (interval) {\n                return scale.ticks(interval)\n            }\n        }\n\n        throw new Error(`Invalid tickValues: ${spec}`)\n    }\n\n    // continuous scales\n    if ('ticks' in scale) {\n        // default behaviour\n        if (spec === undefined) {\n            return scale.ticks()\n        }\n\n        // specific tick count\n        if (isInteger(spec)) {\n            return scale.ticks(spec)\n        }\n    }\n\n    // non linear scale default\n    return scale.domain()\n}\n", "import { timeFormat } from 'd3-time-format'\nimport { format as d3Format } from 'd3-format'\n// @ts-ignore\nimport { textPropsByEngine } from '@nivo/core'\nimport { ScaleValue, AnyScale, TicksSpec, getScaleTicks, centerScale } from '@nivo/scales'\nimport { Point, ValueFormatter, Line } from './types'\n\nconst isArray = <T>(value: unknown): value is T[] => Array.isArray(value)\n\nexport const computeCartesianTicks = <Value extends ScaleValue>({\n    axis,\n    scale,\n    ticksPosition,\n    tickValues,\n    tickSize,\n    tickPadding,\n    tickRotation,\n    truncateTickAt,\n    engine = 'svg',\n}: {\n    axis: 'x' | 'y'\n    scale: AnyScale\n    ticksPosition?: 'after' | 'before'\n    tickValues?: TicksSpec<Value>\n    tickSize: number\n    tickPadding: number\n    tickRotation: number\n    truncateTickAt?: number\n    engine?: 'svg' | 'canvas'\n}) => {\n    const values = getScaleTicks<Value>(scale, tickValues)\n\n    const textProps = textPropsByEngine[engine]\n\n    const position = 'bandwidth' in scale ? centerScale(scale) : scale\n    const line = { lineX: 0, lineY: 0 }\n    const text = { textX: 0, textY: 0 }\n\n    const isRTL = typeof document === 'object' ? document.dir === 'rtl' : false\n    let translate: (value: Value) => Point\n    let textAlign: CanvasTextAlign = textProps.align.center\n    let textBaseline: CanvasTextBaseline = textProps.baseline.center\n\n    if (axis === 'x') {\n        translate = d => ({ x: position(d) ?? 0, y: 0 })\n\n        line.lineY = tickSize * (ticksPosition === 'after' ? 1 : -1)\n        text.textY = (tickSize + tickPadding) * (ticksPosition === 'after' ? 1 : -1)\n\n        if (ticksPosition === 'after') {\n            textBaseline = textProps.baseline.top\n        } else {\n            textBaseline = textProps.baseline.bottom\n        }\n\n        if (tickRotation === 0) {\n            textAlign = textProps.align.center\n        } else if (\n            (ticksPosition === 'after' && tickRotation < 0) ||\n            (ticksPosition === 'before' && tickRotation > 0)\n        ) {\n            textAlign = textProps.align[isRTL ? 'left' : 'right']\n            textBaseline = textProps.baseline.center\n        } else if (\n            (ticksPosition === 'after' && tickRotation > 0) ||\n            (ticksPosition === 'before' && tickRotation < 0)\n        ) {\n            textAlign = textProps.align[isRTL ? 'right' : 'left']\n            textBaseline = textProps.baseline.center\n        }\n    } else {\n        translate = d => ({ x: 0, y: position(d) ?? 0 })\n\n        line.lineX = tickSize * (ticksPosition === 'after' ? 1 : -1)\n        text.textX = (tickSize + tickPadding) * (ticksPosition === 'after' ? 1 : -1)\n\n        if (ticksPosition === 'after') {\n            textAlign = textProps.align.left\n        } else {\n            textAlign = textProps.align.right\n        }\n    }\n\n    const truncateTick = (value: string) => {\n        const valueLength = String(value).length\n\n        if (truncateTickAt && truncateTickAt > 0 && valueLength > truncateTickAt) {\n            return `${String(value).slice(0, truncateTickAt).concat('...')}`\n        }\n        return `${value}`\n    }\n\n    const ticks = values.map((value: Value) => {\n        const processedValue =\n            typeof value === 'string' ? (truncateTick(value) as unknown as Value) : value\n        return {\n            key: value instanceof Date ? `${value.valueOf()}` : `${value}`,\n            value: processedValue,\n            ...translate(value),\n            ...line,\n            ...text,\n        }\n    })\n\n    return {\n        ticks,\n        textAlign,\n        textBaseline,\n    }\n}\n\nexport const getFormatter = <Value extends ScaleValue>(\n    format: string | ValueFormatter<Value> | undefined,\n    scale: AnyScale\n): ValueFormatter<Value> | undefined => {\n    if (typeof format === 'undefined' || typeof format === 'function') return format\n\n    if (scale.type === 'time') {\n        const formatter = timeFormat(format)\n\n        return ((d: any) => formatter(d instanceof Date ? d : new Date(d))) as ValueFormatter<Value>\n    }\n\n    return d3Format(format) as unknown as ValueFormatter<Value>\n}\n\nexport const computeGridLines = <Value extends ScaleValue>({\n    width,\n    height,\n    scale,\n    axis,\n    values: _values,\n}: {\n    width: number\n    height: number\n    scale: AnyScale\n    axis: 'x' | 'y'\n    values?: TicksSpec<Value>\n}) => {\n    const lineValues = isArray<number>(_values) ? _values : undefined\n    const values = lineValues || getScaleTicks<Value>(scale, _values)\n    const position = 'bandwidth' in scale ? centerScale(scale) : scale\n\n    const lines: Line[] =\n        axis === 'x'\n            ? values.map((value: Value) => ({\n                  key: value instanceof Date ? `${value.valueOf()}` : `${value}`,\n                  x1: position(value) ?? 0,\n                  x2: position(value) ?? 0,\n                  y1: 0,\n                  y2: height,\n              }))\n            : values.map((value: Value) => ({\n                  key: value instanceof Date ? `${value.valueOf()}` : `${value}`,\n                  x1: 0,\n                  x2: width,\n                  y1: position(value) ?? 0,\n                  y2: position(value) ?? 0,\n              }))\n\n    return lines\n}\n", "import { useMemo, memo } from 'react'\nimport * as React from 'react'\nimport { animated } from '@react-spring/web'\nimport { useTheme, sanitizeSvgTextStyle } from '@nivo/core'\nimport { ScaleValue } from '@nivo/scales'\nimport { AxisTickProps } from '../types'\n\nconst AxisTick = <Value extends ScaleValue>({\n    value: _value,\n    format,\n    lineX,\n    lineY,\n    onClick,\n    textBaseline,\n    textAnchor,\n    animatedProps,\n}: AxisTickProps<Value>) => {\n    const theme = useTheme()\n    const lineStyle = theme.axis.ticks.line\n    const textStyle = theme.axis.ticks.text\n\n    const value = format?.(_value) ?? _value\n\n    const props = useMemo(() => {\n        const style = { opacity: animatedProps.opacity }\n\n        if (!onClick) {\n            return { style }\n        }\n\n        return {\n            style: { ...style, cursor: 'pointer' },\n            onClick: (event: React.MouseEvent<SVGGElement, MouseEvent>) => onClick(event, value),\n        }\n    }, [animatedProps.opacity, onClick, value])\n\n    return (\n        <animated.g transform={animatedProps.transform} {...props}>\n            <line x1={0} x2={lineX} y1={0} y2={lineY} style={lineStyle} />\n            {textStyle.outlineWidth > 0 && (\n                <animated.text\n                    dominantBaseline={textBaseline}\n                    textAnchor={textAnchor}\n                    transform={animatedProps.textTransform}\n                    style={textStyle}\n                    strokeWidth={textStyle.outlineWidth * 2}\n                    stroke={textStyle.outlineColor}\n                    strokeLinejoin=\"round\"\n                >\n                    {`${value}`}\n                </animated.text>\n            )}\n            <animated.text\n                dominantBaseline={textBaseline}\n                textAnchor={textAnchor}\n                transform={animatedProps.textTransform}\n                style={sanitizeSvgTextStyle(textStyle)}\n            >\n                {`${value}`}\n            </animated.text>\n        </animated.g>\n    )\n}\n\nconst memoizedAxisTick = memo(AxisTick) as typeof AxisTick\n\nexport { memoizedAxisTick as AxisTick }\n", "import { useMotionConfig, useTheme } from '@nivo/core'\nimport { AnyScale, ScaleValue } from '@nivo/scales'\nimport { animated, useSpring, useTransition } from '@react-spring/web'\nimport * as React from 'react'\nimport { memo, useCallback, useMemo } from 'react'\nimport { computeCartesianTicks, getFormatter } from '../compute'\nimport { AxisProps } from '../types'\nimport { AxisTick } from './AxisTick'\n\nexport const NonMemoizedAxis = <Value extends ScaleValue>({\n    axis,\n    scale,\n    x = 0,\n    y = 0,\n    length,\n    ticksPosition,\n    tickValues,\n    tickSize = 5,\n    tickPadding = 5,\n    tickRotation = 0,\n    format,\n    renderTick = AxisTick,\n    truncateTickAt,\n    legend,\n    legendPosition = 'end',\n    legendOffset = 0,\n    onClick,\n    ariaHidden,\n}: AxisProps<Value> & {\n    axis: 'x' | 'y'\n    scale: AnyScale\n    x?: number\n    y?: number\n    length: number\n    onClick?: (event: React.MouseEvent<SVGGElement, MouseEvent>, value: Value | string) => void\n}) => {\n    const theme = useTheme()\n    const legendTextStyle = theme.axis.legend.text\n\n    const formatValue = useMemo(() => getFormatter(format, scale), [format, scale])\n\n    const { ticks, textAlign, textBaseline } = computeCartesianTicks({\n        axis,\n        scale,\n        ticksPosition,\n        tickValues,\n        tickSize,\n        tickPadding,\n        tickRotation,\n        truncateTickAt,\n    })\n\n    let legendNode = null\n    if (legend !== undefined) {\n        let legendX = 0\n        let legendY = 0\n        let legendRotation = 0\n        let textAnchor\n\n        if (axis === 'y') {\n            legendRotation = -90\n            legendX = legendOffset\n            if (legendPosition === 'start') {\n                textAnchor = 'start'\n                legendY = length\n            } else if (legendPosition === 'middle') {\n                textAnchor = 'middle'\n                legendY = length / 2\n            } else if (legendPosition === 'end') {\n                textAnchor = 'end'\n            }\n        } else {\n            legendY = legendOffset\n            if (legendPosition === 'start') {\n                textAnchor = 'start'\n            } else if (legendPosition === 'middle') {\n                textAnchor = 'middle'\n                legendX = length / 2\n            } else if (legendPosition === 'end') {\n                textAnchor = 'end'\n                legendX = length\n            }\n        }\n\n        legendNode = (\n            <>\n                {legendTextStyle.outlineWidth > 0 && (\n                    <text\n                        transform={`translate(${legendX}, ${legendY}) rotate(${legendRotation})`}\n                        textAnchor={textAnchor}\n                        style={{\n                            dominantBaseline: 'central',\n                            ...legendTextStyle,\n                        }}\n                        strokeWidth={legendTextStyle.outlineWidth * 2}\n                        stroke={legendTextStyle.outlineColor}\n                        strokeLinejoin=\"round\"\n                    >\n                        {legend}\n                    </text>\n                )}\n                <text\n                    transform={`translate(${legendX}, ${legendY}) rotate(${legendRotation})`}\n                    textAnchor={textAnchor}\n                    style={{\n                        dominantBaseline: 'central',\n                        ...legendTextStyle,\n                    }}\n                >\n                    {legend}\n                </text>\n            </>\n        )\n    }\n\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const animatedProps = useSpring({\n        transform: `translate(${x},${y})`,\n        lineX2: axis === 'x' ? length : 0,\n        lineY2: axis === 'x' ? 0 : length,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    const getAnimatedProps = useCallback(\n        (tick: (typeof ticks)[0]) => {\n            return {\n                opacity: 1,\n                transform: `translate(${tick.x},${tick.y})`,\n                textTransform: `translate(${tick.textX},${tick.textY}) rotate(${tickRotation})`,\n            }\n        },\n        [tickRotation]\n    )\n    const getFromAnimatedProps = useCallback(\n        (tick: (typeof ticks)[0]) => ({\n            opacity: 0,\n            transform: `translate(${tick.x},${tick.y})`,\n            textTransform: `translate(${tick.textX},${tick.textY}) rotate(${tickRotation})`,\n        }),\n        [tickRotation]\n    )\n\n    const transition = useTransition<\n        (typeof ticks)[0],\n        { opacity: number; transform: string; textTransform: string }\n    >(ticks, {\n        keys: tick => tick.key,\n        initial: getAnimatedProps,\n        from: getFromAnimatedProps,\n        enter: getAnimatedProps,\n        update: getAnimatedProps,\n        leave: {\n            opacity: 0,\n        },\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <animated.g transform={animatedProps.transform} aria-hidden={ariaHidden}>\n            {transition((transitionProps, tick, _state, tickIndex) => {\n                return React.createElement(renderTick, {\n                    tickIndex,\n                    format: formatValue,\n                    rotate: tickRotation,\n                    textBaseline,\n                    textAnchor: textAlign,\n                    truncateTickAt: truncateTickAt,\n                    animatedProps: transitionProps,\n                    ...tick,\n                    ...(onClick ? { onClick } : {}),\n                })\n            })}\n            <animated.line\n                style={theme.axis.domain.line}\n                x1={0}\n                x2={animatedProps.lineX2}\n                y1={0}\n                y2={animatedProps.lineY2}\n            />\n            {legendNode}\n        </animated.g>\n    )\n}\n\nexport const Axis = memo(NonMemoizedAxis) as typeof NonMemoizedAxis\n", "export const positions = ['top', 'right', 'bottom', 'left'] as const\n", "import { memo } from 'react'\nimport { ScaleValue, AnyScale } from '@nivo/scales'\nimport { Axis } from './Axis'\nimport { positions } from '../props'\nimport { AxisProps } from '../types'\n\nexport const Axes = memo(\n    <X extends ScaleValue, Y extends ScaleValue>({\n        xScale,\n        yScale,\n        width,\n        height,\n        top,\n        right,\n        bottom,\n        left,\n    }: {\n        xScale: AnyScale\n        yScale: AnyScale\n        width: number\n        height: number\n        top?: AxisProps<X> | null\n        right?: AxisProps<Y> | null\n        bottom?: AxisProps<X> | null\n        left?: AxisProps<Y> | null\n    }) => {\n        const axes = { top, right, bottom, left }\n\n        return (\n            <>\n                {positions.map(position => {\n                    const axis = axes[position] as typeof position extends 'bottom' | 'top'\n                        ? AxisProps<X> | undefined\n                        : AxisProps<Y> | undefined\n\n                    if (!axis) return null\n\n                    const isXAxis = position === 'top' || position === 'bottom'\n                    const ticksPosition =\n                        position === 'top' || position === 'left' ? 'before' : 'after'\n\n                    return (\n                        <Axis\n                            key={position}\n                            {...axis}\n                            axis={isXAxis ? 'x' : 'y'}\n                            x={position === 'right' ? width : 0}\n                            y={position === 'bottom' ? height : 0}\n                            scale={isXAxis ? xScale : yScale}\n                            length={isXAxis ? width : height}\n                            ticksPosition={ticksPosition}\n                            truncateTickAt={axis.truncateTickAt}\n                        />\n                    )\n                })}\n            </>\n        )\n    }\n)\n", "import { memo, SVGAttributes } from 'react'\nimport { SpringValues, animated } from '@react-spring/web'\nimport { useTheme } from '@nivo/core'\n\nexport const GridLine = memo(\n    ({\n        animatedProps,\n    }: {\n        animatedProps: SpringValues<{\n            opacity: number\n            x1: number\n            x2: number\n            y1: number\n            y2: number\n        }>\n    }) => {\n        const theme = useTheme()\n\n        return (\n            <animated.line\n                {...animatedProps}\n                {...(theme.grid.line as SVGAttributes<SVGLineElement>)}\n            />\n        )\n    }\n)\n", "import { memo } from 'react'\nimport { useTransition } from '@react-spring/web'\nimport { useMotionConfig } from '@nivo/core'\nimport { GridLine } from './GridLine'\nimport { Line } from '../types'\n\nexport const GridLines = memo(({ lines }: { lines: Line[] }) => {\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const transition = useTransition<Line, Record<'opacity' | 'x1' | 'x2' | 'y1' | 'y2', number>>(\n        lines,\n        {\n            keys: line => line.key,\n            initial: line => ({\n                opacity: 1,\n                x1: line.x1,\n                x2: line.x2,\n                y1: line.y1,\n                y2: line.y2,\n            }),\n            from: line => ({\n                opacity: 0,\n                x1: line.x1,\n                x2: line.x2,\n                y1: line.y1,\n                y2: line.y2,\n            }),\n            enter: line => ({\n                opacity: 1,\n                x1: line.x1,\n                x2: line.x2,\n                y1: line.y1,\n                y2: line.y2,\n            }),\n            update: line => ({\n                opacity: 1,\n                x1: line.x1,\n                x2: line.x2,\n                y1: line.y1,\n                y2: line.y2,\n            }),\n            leave: {\n                opacity: 0,\n            },\n            config: springConfig,\n            immediate: !animate,\n        }\n    )\n\n    return (\n        <g>\n            {transition((animatedProps, line) => (\n                <GridLine {...line} key={line.key} animatedProps={animatedProps} />\n            ))}\n        </g>\n    )\n})\n", "import { useMemo, memo } from 'react'\nimport { ScaleValue, AnyScale, TicksSpec } from '@nivo/scales'\nimport { GridLines } from './GridLines'\nimport { computeGridLines } from '../compute'\n\nexport const Grid = memo(\n    <X extends ScaleValue, Y extends ScaleValue>({\n        width,\n        height,\n        xScale,\n        yScale,\n        xValues,\n        yValues,\n    }: {\n        width: number\n        height: number\n        xScale?: AnyScale | null\n        xValues?: TicksSpec<X>\n        yScale?: AnyScale | null\n        yValues?: TicksSpec<Y>\n    }) => {\n        const xLines = useMemo(() => {\n            if (!xScale) return false\n\n            return computeGridLines({\n                width,\n                height,\n                scale: xScale,\n                axis: 'x',\n                values: xValues,\n            })\n        }, [xScale, xValues, width, height])\n\n        const yLines = useMemo(() => {\n            if (!yScale) return false\n\n            return computeGridLines({\n                width,\n                height,\n                scale: yScale,\n                axis: 'y',\n                values: yValues,\n            })\n        }, [height, width, yScale, yValues])\n\n        return (\n            <>\n                {xLines && <GridLines lines={xLines} />}\n                {yLines && <GridLines lines={yLines} />}\n            </>\n        )\n    }\n)\n", "import { degreesToRadians, CompleteTheme } from '@nivo/core'\nimport { ScaleValue, AnyScale, TicksSpec } from '@nivo/scales'\nimport { computeCartesianTicks, getFormatter, computeGridLines } from './compute'\nimport { positions } from './props'\nimport { AxisLegendPosition, CanvasAxisProps, ValueFormatter } from './types'\n\nexport const renderAxisToCanvas = <Value extends ScaleValue>(\n    ctx: CanvasRenderingContext2D,\n    {\n        axis,\n        scale,\n        x = 0,\n        y = 0,\n        length,\n\n        ticksPosition,\n        tickValues,\n        tickSize = 5,\n        tickPadding = 5,\n        tickRotation = 0,\n        format: _format,\n\n        legend,\n        legendPosition = 'end',\n        legendOffset = 0,\n\n        theme,\n    }: {\n        axis: 'x' | 'y'\n        scale: AnyScale\n        x?: number\n        y?: number\n        length: number\n        ticksPosition: 'before' | 'after'\n        tickValues?: TicksSpec<Value>\n        tickSize?: number\n        tickPadding?: number\n        tickRotation?: number\n        format?: string | ValueFormatter<Value>\n        legend?: string\n        legendPosition?: AxisLegendPosition\n        legendOffset?: number\n        theme: CompleteTheme\n    }\n) => {\n    const { ticks, textAlign, textBaseline } = computeCartesianTicks({\n        axis,\n        scale,\n        ticksPosition,\n        tickValues,\n        tickSize,\n        tickPadding,\n        tickRotation,\n        engine: 'canvas',\n    })\n\n    ctx.save()\n    ctx.translate(x, y)\n\n    ctx.textAlign = textAlign\n    ctx.textBaseline = textBaseline\n\n    const textStyle = theme.axis.ticks.text\n    ctx.font = `${textStyle.fontWeight ? `${textStyle.fontWeight} ` : ''}${textStyle.fontSize}px ${\n        textStyle.fontFamily\n    }`\n\n    if ((theme.axis.domain.line.strokeWidth ?? 0) > 0) {\n        ctx.lineWidth = Number(theme.axis.domain.line.strokeWidth)\n        ctx.lineCap = 'square'\n\n        if (theme.axis.domain.line.stroke) {\n            ctx.strokeStyle = theme.axis.domain.line.stroke\n        }\n\n        ctx.beginPath()\n        ctx.moveTo(0, 0)\n        ctx.lineTo(axis === 'x' ? length : 0, axis === 'x' ? 0 : length)\n        ctx.stroke()\n    }\n\n    const format = typeof _format === 'function' ? _format : (value: unknown) => `${value}`\n\n    ticks.forEach(tick => {\n        if ((theme.axis.ticks.line.strokeWidth ?? 0) > 0) {\n            ctx.lineWidth = Number(theme.axis.ticks.line.strokeWidth)\n            ctx.lineCap = 'square'\n\n            if (theme.axis.ticks.line.stroke) {\n                ctx.strokeStyle = theme.axis.ticks.line.stroke\n            }\n\n            ctx.beginPath()\n            ctx.moveTo(tick.x, tick.y)\n            ctx.lineTo(tick.x + tick.lineX, tick.y + tick.lineY)\n            ctx.stroke()\n        }\n\n        const value = format(tick.value)\n\n        ctx.save()\n        ctx.translate(tick.x + tick.textX, tick.y + tick.textY)\n        ctx.rotate(degreesToRadians(tickRotation))\n\n        if (textStyle.outlineWidth > 0) {\n            ctx.strokeStyle = textStyle.outlineColor\n            ctx.lineWidth = textStyle.outlineWidth * 2\n            ctx.lineJoin = 'round'\n            ctx.strokeText(`${value}`, 0, 0)\n        }\n\n        if (theme.axis.ticks.text.fill) {\n            ctx.fillStyle = textStyle.fill\n        }\n\n        ctx.fillText(`${value}`, 0, 0)\n        ctx.restore()\n    })\n\n    if (legend !== undefined) {\n        let legendX = 0\n        let legendY = 0\n        let legendRotation = 0\n        let textAlign: CanvasTextAlign = 'center'\n\n        if (axis === 'y') {\n            legendRotation = -90\n            legendX = legendOffset\n            if (legendPosition === 'start') {\n                textAlign = 'start'\n                legendY = length\n            } else if (legendPosition === 'middle') {\n                textAlign = 'center'\n                legendY = length / 2\n            } else if (legendPosition === 'end') {\n                textAlign = 'end'\n            }\n        } else {\n            legendY = legendOffset\n            if (legendPosition === 'start') {\n                textAlign = 'start'\n            } else if (legendPosition === 'middle') {\n                textAlign = 'center'\n                legendX = length / 2\n            } else if (legendPosition === 'end') {\n                textAlign = 'end'\n                legendX = length\n            }\n        }\n\n        ctx.translate(legendX, legendY)\n        ctx.rotate(degreesToRadians(legendRotation))\n        ctx.font = `${\n            theme.axis.legend.text.fontWeight ? `${theme.axis.legend.text.fontWeight} ` : ''\n        }${theme.axis.legend.text.fontSize}px ${theme.axis.legend.text.fontFamily}`\n\n        if (theme.axis.legend.text.fill) {\n            ctx.fillStyle = theme.axis.legend.text.fill\n        }\n\n        ctx.textAlign = textAlign\n        ctx.textBaseline = 'middle'\n        ctx.fillText(legend, 0, 0)\n    }\n\n    ctx.restore()\n}\n\nexport const renderAxesToCanvas = <X extends ScaleValue, Y extends ScaleValue>(\n    ctx: CanvasRenderingContext2D,\n    {\n        xScale,\n        yScale,\n        width,\n        height,\n\n        top,\n        right,\n        bottom,\n        left,\n\n        theme,\n    }: {\n        xScale: AnyScale\n        yScale: AnyScale\n        width: number\n        height: number\n        top?: CanvasAxisProps<X> | null\n        right?: CanvasAxisProps<Y> | null\n        bottom?: CanvasAxisProps<X> | null\n        left?: CanvasAxisProps<Y> | null\n        theme: CompleteTheme\n    }\n) => {\n    const axes = { top, right, bottom, left }\n\n    positions.forEach(position => {\n        const axis = axes[position] as typeof position extends 'bottom' | 'top'\n            ? CanvasAxisProps<X> | undefined\n            : CanvasAxisProps<Y> | undefined\n\n        if (!axis) return null\n\n        const isXAxis = position === 'top' || position === 'bottom'\n        const ticksPosition = position === 'top' || position === 'left' ? 'before' : 'after'\n        const scale = isXAxis ? xScale : yScale\n        const format = getFormatter(axis.format, scale)\n\n        renderAxisToCanvas(ctx, {\n            ...axis,\n            axis: isXAxis ? 'x' : 'y',\n            x: position === 'right' ? width : 0,\n            y: position === 'bottom' ? height : 0,\n            scale,\n            format,\n            length: isXAxis ? width : height,\n            ticksPosition,\n            theme,\n        })\n    })\n}\n\nexport const renderGridLinesToCanvas = <Value extends ScaleValue>(\n    ctx: CanvasRenderingContext2D,\n    {\n        width,\n        height,\n        scale,\n        axis,\n        values,\n    }: {\n        width: number\n        height: number\n        scale: AnyScale\n        axis: 'x' | 'y'\n        values?: TicksSpec<Value>\n    }\n) => {\n    const lines = computeGridLines({ width, height, scale, axis, values })\n\n    lines.forEach(line => {\n        ctx.beginPath()\n        ctx.moveTo(line.x1, line.y1)\n        ctx.lineTo(line.x2, line.y2)\n        ctx.stroke()\n    })\n}\n", "export const defaultProps = {\n    dotSize: 4,\n    noteWidth: 120,\n    noteTextOffset: 8,\n    animate: true,\n}\n", "import {\n    AnnotationSpec,\n    CircleAnnotationSpec,\n    DotAnnotationSpec,\n    Note,\n    NoteCanvas,\n    NoteSvg,\n    RectAnnotationSpec,\n} from './types'\nimport { isValidElement } from 'react'\n\nexport const isSvgNote = <Datum>(note: Note<Datum>): note is NoteSvg<Datum> => {\n    const noteType = typeof note\n\n    return (\n        isValidElement(note) ||\n        noteType === 'string' ||\n        noteType === 'function' ||\n        noteType === 'object'\n    )\n}\n\nexport const isCanvasNote = <Datum>(note: Note<Datum>): note is NoteCanvas<Datum> => {\n    const noteType = typeof note\n\n    return noteType === 'string' || noteType === 'function'\n}\n\nexport const isCircleAnnotation = <Datum>(\n    annotationSpec: AnnotationSpec<Datum>\n): annotationSpec is CircleAnnotationSpec<Datum> => annotationSpec.type === 'circle'\n\nexport const isDotAnnotation = <Datum>(\n    annotationSpec: AnnotationSpec<Datum>\n): annotationSpec is DotAnnotationSpec<Datum> => annotationSpec.type === 'dot'\n\nexport const isRectAnnotation = <Datum>(\n    annotationSpec: AnnotationSpec<Datum>\n): annotationSpec is RectAnnotationSpec<Datum> => annotationSpec.type === 'rect'\n", "import filter from 'lodash/filter'\nimport isNumber from 'lodash/isNumber'\nimport omit from 'lodash/omit'\nimport {\n    radiansToDegrees,\n    absoluteAngleDegrees,\n    degreesToRadians,\n    positionFromAngle,\n} from '@nivo/core'\nimport { defaultProps } from './props'\nimport {\n    AnnotationPositionGetter,\n    AnnotationDimensionsGetter,\n    BoundAnnotation,\n    AnnotationMatcher,\n    AnnotationInstructions,\n} from './types'\nimport { isCircleAnnotation, isRectAnnotation } from './utils'\n\nexport const bindAnnotations = <\n    Datum = {\n        x: number\n        y: number\n    }\n>({\n    data,\n    annotations,\n    getPosition,\n    getDimensions,\n}: {\n    data: readonly Datum[]\n    annotations: readonly AnnotationMatcher<Datum>[]\n    getPosition: AnnotationPositionGetter<Datum>\n    getDimensions: AnnotationDimensionsGetter<Datum>\n}): BoundAnnotation<Datum>[] =>\n    annotations.reduce((acc: BoundAnnotation<Datum>[], annotation) => {\n        const offset = annotation.offset || 0\n\n        return [\n            ...acc,\n            ...filter<Datum>(data, annotation.match).map(datum => {\n                const position = getPosition(datum)\n                const dimensions = getDimensions(datum)\n\n                if (isCircleAnnotation(annotation) || isRectAnnotation(annotation)) {\n                    dimensions.size = dimensions.size + offset * 2\n                    dimensions.width = dimensions.width + offset * 2\n                    dimensions.height = dimensions.height + offset * 2\n                }\n\n                // acc.push({\n                //     ...omit(annotation, ['match', 'offset']),\n                //     ...position,\n                //     ...dimensions,\n                //     size: annotation.size || dimensions.size,\n                //     datum,\n                // } as any)\n                // return [\n                //     ...acc,\n                //     {\n                //         ...omit(annotation, ['match', 'offset']),\n                //         ...position,\n                //         ...dimensions,\n                //         size: annotation.size || dimensions.size,\n                //         datum,\n                //     },\n                // ]\n                return {\n                    ...omit(annotation, ['match', 'offset']),\n                    ...position,\n                    ...dimensions,\n                    size: annotation.size || dimensions.size,\n                    datum,\n                } as Required<BoundAnnotation<Datum>>\n            }),\n        ]\n\n        // return acc\n    }, [])\n\nexport const getLinkAngle = (\n    sourceX: number,\n    sourceY: number,\n    targetX: number,\n    targetY: number\n) => {\n    const angle = Math.atan2(targetY - sourceY, targetX - sourceX)\n\n    return absoluteAngleDegrees(radiansToDegrees(angle))\n}\n\nexport const computeAnnotation = <Datum>(\n    annotation: BoundAnnotation<Datum>\n): AnnotationInstructions => {\n    const {\n        x,\n        y,\n        noteX,\n        noteY,\n        noteWidth = defaultProps.noteWidth,\n        noteTextOffset = defaultProps.noteTextOffset,\n    } = annotation\n\n    let computedNoteX: number\n    let computedNoteY: number\n\n    if (isNumber(noteX)) {\n        computedNoteX = x + noteX\n    } else if (noteX.abs !== undefined) {\n        computedNoteX = noteX.abs\n    } else {\n        throw new Error(`noteX should be either a number or an object containing an 'abs' property`)\n    }\n\n    if (isNumber(noteY)) {\n        computedNoteY = y + noteY\n    } else if (noteY.abs !== undefined) {\n        computedNoteY = noteY.abs\n    } else {\n        throw new Error(`noteY should be either a number or an object containing an 'abs' property`)\n    }\n\n    let computedX = x\n    let computedY = y\n\n    const angle = getLinkAngle(x, y, computedNoteX, computedNoteY)\n\n    if (isCircleAnnotation<Datum>(annotation)) {\n        const position = positionFromAngle(degreesToRadians(angle), annotation.size / 2)\n        computedX += position.x\n        computedY += position.y\n    }\n\n    if (isRectAnnotation<Datum>(annotation)) {\n        const eighth = Math.round((angle + 90) / 45) % 8\n        if (eighth === 0) {\n            computedY -= annotation.height / 2\n        }\n        if (eighth === 1) {\n            computedX += annotation.width / 2\n            computedY -= annotation.height / 2\n        }\n        if (eighth === 2) {\n            computedX += annotation.width / 2\n        }\n        if (eighth === 3) {\n            computedX += annotation.width / 2\n            computedY += annotation.height / 2\n        }\n        if (eighth === 4) {\n            computedY += annotation.height / 2\n        }\n        if (eighth === 5) {\n            computedX -= annotation.width / 2\n            computedY += annotation.height / 2\n        }\n        if (eighth === 6) {\n            computedX -= annotation.width / 2\n        }\n        if (eighth === 7) {\n            computedX -= annotation.width / 2\n            computedY -= annotation.height / 2\n        }\n    }\n\n    let textX = computedNoteX\n    const textY = computedNoteY - noteTextOffset\n\n    let noteLineX = computedNoteX\n    const noteLineY = computedNoteY\n\n    if ((angle + 90) % 360 > 180) {\n        textX -= noteWidth\n        noteLineX -= noteWidth\n    } else {\n        noteLineX += noteWidth\n    }\n\n    return {\n        points: [\n            [computedX, computedY],\n            [computedNoteX, computedNoteY],\n            [noteLineX, noteLineY],\n        ] as [number, number][],\n        text: [textX, textY],\n        angle: angle + 90,\n    }\n}\n", "import { useMemo } from 'react'\nimport { bindAnnotations, computeAnnotation } from './compute'\nimport {\n    AnnotationDimensionsGetter,\n    AnnotationMatcher,\n    AnnotationPositionGetter,\n    BoundAnnotation,\n} from './types'\n\n/**\n * Bind annotations to a dataset.\n */\nexport const useAnnotations = <Datum>({\n    data,\n    annotations,\n    getPosition,\n    getDimensions,\n}: {\n    data: readonly Datum[]\n    annotations: readonly AnnotationMatcher<Datum>[]\n    getPosition: AnnotationPositionGetter<Datum>\n    getDimensions: AnnotationDimensionsGetter<Datum>\n}) =>\n    useMemo(\n        () =>\n            bindAnnotations<Datum>({\n                data,\n                annotations,\n                getPosition,\n                getDimensions,\n            }),\n        [data, annotations, getPosition, getDimensions]\n    )\n\nexport const useComputedAnnotations = <Datum>({\n    annotations,\n}: {\n    annotations: readonly BoundAnnotation<Datum>[]\n}) =>\n    useMemo(\n        () =>\n            annotations.map(annotation => ({\n                ...annotation,\n                computed: computeAnnotation<Datum>({\n                    ...annotation,\n                }),\n            })),\n        [annotations]\n    )\n\nexport const useComputedAnnotation = <Datum>(annotation: BoundAnnotation<Datum>) =>\n    useMemo(() => computeAnnotation<Datum>(annotation), [annotation])\n", "import { createElement } from 'react'\nimport omit from 'lodash/omit'\nimport { useSpring, animated } from '@react-spring/web'\nimport { useTheme, useMotionConfig } from '@nivo/core'\nimport { NoteSvg } from './types'\n\nexport const AnnotationNote = <Datum,>({\n    datum,\n    x,\n    y,\n    note,\n}: {\n    datum: Datum\n    x: number\n    y: number\n    note: NoteSvg<Datum>\n}) => {\n    const theme = useTheme()\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const animatedProps = useSpring({\n        x,\n        y,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    if (typeof note === 'function') {\n        return createElement(note, { x, y, datum })\n    }\n\n    return (\n        <>\n            {theme.annotations.text.outlineWidth > 0 && (\n                <animated.text\n                    x={animatedProps.x}\n                    y={animatedProps.y}\n                    style={{\n                        ...theme.annotations.text,\n                        strokeLinejoin: 'round',\n                        strokeWidth: theme.annotations.text.outlineWidth * 2,\n                        stroke: theme.annotations.text.outlineColor,\n                    }}\n                >\n                    {note}\n                </animated.text>\n            )}\n            <animated.text\n                x={animatedProps.x}\n                y={animatedProps.y}\n                style={omit(theme.annotations.text, ['outlineWidth', 'outlineColor'])}\n            >\n                {note}\n            </animated.text>\n        </>\n    )\n}\n", "import { useMemo } from 'react'\nimport { animated } from '@react-spring/web'\nimport { useAnimatedPath, useTheme } from '@nivo/core'\n\nexport const AnnotationLink = ({\n    points,\n    isOutline = false,\n}: {\n    points: [number, number][]\n    isOutline?: boolean\n}) => {\n    const theme = useTheme()\n\n    const path = useMemo(() => {\n        const [firstPoint, ...otherPoints] = points\n\n        return otherPoints.reduce(\n            (acc, [x, y]) => `${acc} L${x},${y}`,\n            `M${firstPoint[0]},${firstPoint[1]}`\n        )\n    }, [points])\n\n    const animatedPath = useAnimatedPath(path)\n\n    if (isOutline && theme.annotations.link.outlineWidth <= 0) {\n        return null\n    }\n\n    const style = { ...theme.annotations.link }\n    if (isOutline) {\n        style.strokeLinecap = 'square'\n        style.strokeWidth =\n            theme.annotations.link.strokeWidth + theme.annotations.link.outlineWidth * 2\n        style.stroke = theme.annotations.link.outlineColor\n        style.opacity = theme.annotations.link.outlineOpacity\n    }\n\n    return <animated.path fill=\"none\" d={animatedPath} style={style} />\n}\n", "import { useSpring, animated } from '@react-spring/web'\nimport { useMotionConfig, useTheme } from '@nivo/core'\n\nexport const CircleAnnotationOutline = ({ x, y, size }: { x: number; y: number; size: number }) => {\n    const theme = useTheme()\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const animatedProps = useSpring({\n        x,\n        y,\n        radius: size / 2,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <>\n            {theme.annotations.outline.outlineWidth > 0 && (\n                <animated.circle\n                    cx={animatedProps.x}\n                    cy={animatedProps.y}\n                    r={animatedProps.radius}\n                    style={{\n                        ...theme.annotations.outline,\n                        fill: 'none',\n                        strokeWidth:\n                            theme.annotations.outline.strokeWidth +\n                            theme.annotations.outline.outlineWidth * 2,\n                        stroke: theme.annotations.outline.outlineColor,\n                        opacity: theme.annotations.outline.outlineOpacity,\n                    }}\n                />\n            )}\n            <animated.circle\n                cx={animatedProps.x}\n                cy={animatedProps.y}\n                r={animatedProps.radius}\n                style={theme.annotations.outline}\n            />\n        </>\n    )\n}\n", "import { useSpring, animated } from '@react-spring/web'\nimport { useMotionConfig, useTheme } from '@nivo/core'\nimport { defaultProps } from './props'\n\nexport const DotAnnotationOutline = ({\n    x,\n    y,\n    size = defaultProps.dotSize,\n}: {\n    x: number\n    y: number\n    size?: number\n}) => {\n    const theme = useTheme()\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const animatedProps = useSpring({\n        x,\n        y,\n        radius: size / 2,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <>\n            {theme.annotations.outline.outlineWidth > 0 && (\n                <animated.circle\n                    cx={animatedProps.x}\n                    cy={animatedProps.y}\n                    r={animatedProps.radius}\n                    style={{\n                        ...theme.annotations.outline,\n                        fill: 'none',\n                        strokeWidth: theme.annotations.outline.outlineWidth * 2,\n                        stroke: theme.annotations.outline.outlineColor,\n                        opacity: theme.annotations.outline.outlineOpacity,\n                    }}\n                />\n            )}\n            <animated.circle\n                cx={animatedProps.x}\n                cy={animatedProps.y}\n                r={animatedProps.radius}\n                style={theme.annotations.symbol}\n            />\n        </>\n    )\n}\n", "import { useSpring, animated } from '@react-spring/web'\nimport { useMotionConfig, useTheme } from '@nivo/core'\n\nexport const RectAnnotationOutline = ({\n    x,\n    y,\n    width,\n    height,\n    borderRadius = 6,\n}: {\n    x: number\n    y: number\n    width: number\n    height: number\n    borderRadius?: number\n}) => {\n    const theme = useTheme()\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const animatedProps = useSpring({\n        x: x - width / 2,\n        y: y - height / 2,\n        width,\n        height,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    return (\n        <>\n            {theme.annotations.outline.outlineWidth > 0 && (\n                <animated.rect\n                    x={animatedProps.x}\n                    y={animatedProps.y}\n                    rx={borderRadius}\n                    ry={borderRadius}\n                    width={animatedProps.width}\n                    height={animatedProps.height}\n                    style={{\n                        ...theme.annotations.outline,\n                        fill: 'none',\n                        strokeWidth:\n                            theme.annotations.outline.strokeWidth +\n                            theme.annotations.outline.outlineWidth * 2,\n                        stroke: theme.annotations.outline.outlineColor,\n                        opacity: theme.annotations.outline.outlineOpacity,\n                    }}\n                />\n            )}\n            <animated.rect\n                x={animatedProps.x}\n                y={animatedProps.y}\n                rx={borderRadius}\n                ry={borderRadius}\n                width={animatedProps.width}\n                height={animatedProps.height}\n                style={theme.annotations.outline}\n            />\n        </>\n    )\n}\n", "import { useComputedAnnotation } from './hooks'\nimport { AnnotationNote } from './AnnotationNote'\nimport { AnnotationLink } from './AnnotationLink'\nimport { CircleAnnotationOutline } from './CircleAnnotationOutline'\nimport { DotAnnotationOutline } from './DotAnnotationOutline'\nimport { RectAnnotationOutline } from './RectAnnotationOutline'\nimport { BoundAnnotation } from './types'\nimport { isCircleAnnotation, isDotAnnotation, isRectAnnotation, isSvgNote } from './utils'\n\nexport const Annotation = <Datum,>(annotation: BoundAnnotation<Datum>) => {\n    const { datum, x, y, note } = annotation\n    const computed = useComputedAnnotation(annotation)\n\n    if (!isSvgNote(note)) {\n        throw new Error('note should be a valid react element')\n    }\n\n    return (\n        <>\n            <AnnotationLink points={computed.points} isOutline={true} />\n            {isCircleAnnotation(annotation) && (\n                <CircleAnnotationOutline x={x} y={y} size={annotation.size} />\n            )}\n            {isDotAnnotation(annotation) && (\n                <DotAnnotationOutline x={x} y={y} size={annotation.size} />\n            )}\n            {isRectAnnotation(annotation) && (\n                <RectAnnotationOutline\n                    x={x}\n                    y={y}\n                    width={annotation.width}\n                    height={annotation.height}\n                    borderRadius={annotation.borderRadius}\n                />\n            )}\n            <AnnotationLink points={computed.points} />\n            <AnnotationNote datum={datum} x={computed.text[0]} y={computed.text[1]} note={note} />\n        </>\n    )\n}\n", "import { CompleteTheme } from '@nivo/core'\nimport { ComputedAnnotation } from './types'\nimport { isCanvasNote, isCircleAnnotation, isDotAnnotation, isRectAnnotation } from './utils'\n\nconst drawPoints = (ctx: CanvasRenderingContext2D, points: [number, number][]) => {\n    points.forEach(([x, y], index) => {\n        if (index === 0) {\n            ctx.moveTo(x, y)\n        } else {\n            ctx.lineTo(x, y)\n        }\n    })\n}\n\nexport const renderAnnotationsToCanvas = <Datum>(\n    ctx: CanvasRenderingContext2D,\n    {\n        annotations,\n        theme,\n    }: {\n        annotations: ComputedAnnotation<Datum>[]\n        theme: CompleteTheme\n    }\n) => {\n    if (annotations.length === 0) return\n\n    ctx.save()\n    annotations.forEach(annotation => {\n        if (!isCanvasNote(annotation.note)) {\n            throw new Error('note is invalid for canvas implementation')\n        }\n\n        if (theme.annotations.link.outlineWidth > 0) {\n            ctx.lineCap = 'square'\n            ctx.strokeStyle = theme.annotations.link.outlineColor\n            ctx.lineWidth =\n                theme.annotations.link.strokeWidth + theme.annotations.link.outlineWidth * 2\n            ctx.beginPath()\n            drawPoints(ctx, annotation.computed.points)\n            ctx.stroke()\n            ctx.lineCap = 'butt'\n        }\n\n        if (isCircleAnnotation(annotation) && theme.annotations.outline.outlineWidth > 0) {\n            ctx.strokeStyle = theme.annotations.outline.outlineColor\n            ctx.lineWidth =\n                theme.annotations.outline.strokeWidth + theme.annotations.outline.outlineWidth * 2\n            ctx.beginPath()\n            ctx.arc(annotation.x, annotation.y, annotation.size / 2, 0, 2 * Math.PI)\n            ctx.stroke()\n        }\n\n        if (isDotAnnotation(annotation) && theme.annotations.symbol.outlineWidth > 0) {\n            ctx.strokeStyle = theme.annotations.symbol.outlineColor\n            ctx.lineWidth = theme.annotations.symbol.outlineWidth * 2\n            ctx.beginPath()\n            ctx.arc(annotation.x, annotation.y, annotation.size / 2, 0, 2 * Math.PI)\n            ctx.stroke()\n        }\n\n        if (isRectAnnotation(annotation) && theme.annotations.outline.outlineWidth > 0) {\n            ctx.strokeStyle = theme.annotations.outline.outlineColor\n            ctx.lineWidth =\n                theme.annotations.outline.strokeWidth + theme.annotations.outline.outlineWidth * 2\n            ctx.beginPath()\n            ctx.rect(\n                annotation.x - annotation.width / 2,\n                annotation.y - annotation.height / 2,\n                annotation.width,\n                annotation.height\n            )\n            ctx.stroke()\n        }\n\n        ctx.strokeStyle = theme.annotations.link.stroke\n        ctx.lineWidth = theme.annotations.link.strokeWidth\n        ctx.beginPath()\n        drawPoints(ctx, annotation.computed.points)\n        ctx.stroke()\n\n        if (isCircleAnnotation(annotation)) {\n            ctx.strokeStyle = theme.annotations.outline.stroke\n            ctx.lineWidth = theme.annotations.outline.strokeWidth\n            ctx.beginPath()\n            ctx.arc(annotation.x, annotation.y, annotation.size / 2, 0, 2 * Math.PI)\n            ctx.stroke()\n        }\n\n        if (isDotAnnotation(annotation)) {\n            ctx.fillStyle = theme.annotations.symbol.fill\n            ctx.beginPath()\n            ctx.arc(annotation.x, annotation.y, annotation.size / 2, 0, 2 * Math.PI)\n            ctx.fill()\n        }\n\n        if (isRectAnnotation(annotation)) {\n            ctx.strokeStyle = theme.annotations.outline.stroke\n            ctx.lineWidth = theme.annotations.outline.strokeWidth\n            ctx.beginPath()\n            ctx.rect(\n                annotation.x - annotation.width / 2,\n                annotation.y - annotation.height / 2,\n                annotation.width,\n                annotation.height\n            )\n            ctx.stroke()\n        }\n\n        if (typeof annotation.note === 'function') {\n            annotation.note(ctx, {\n                datum: annotation.datum,\n                x: annotation.computed.text[0],\n                y: annotation.computed.text[1],\n                theme,\n            })\n        } else {\n            ctx.font = `${theme.annotations.text.fontSize}px ${theme.annotations.text.fontFamily}`\n            ctx.textAlign = 'left'\n            ctx.textBaseline = 'alphabetic'\n\n            ctx.fillStyle = theme.annotations.text.fill\n            ctx.strokeStyle = theme.annotations.text.outlineColor\n            ctx.lineWidth = theme.annotations.text.outlineWidth * 2\n\n            if (theme.annotations.text.outlineWidth > 0) {\n                ctx.lineJoin = 'round'\n                ctx.strokeText(\n                    annotation.note,\n                    annotation.computed.text[0],\n                    annotation.computed.text[1]\n                )\n                ctx.lineJoin = 'miter'\n            }\n            ctx.fillText(annotation.note, annotation.computed.text[0], annotation.computed.text[1])\n        }\n    })\n    ctx.restore()\n}\n", "import { memo } from 'react'\nimport { BasicTooltip } from '@nivo/tooltip'\nimport { HeatMapDatum, TooltipProps } from './types'\n\nconst NonMemoizedHeatMapTooltip = <Datum extends HeatMapDatum>({ cell }: TooltipProps<Datum>) => {\n    if (cell.formattedValue === null) return null\n\n    return (\n        <BasicTooltip\n            id={`${cell.serieId} - ${cell.data.x}`}\n            value={cell.formattedValue}\n            enableChip={true}\n            color={cell.color}\n        />\n    )\n}\n\nexport const HeatMapTooltip = memo(NonMemoizedHeatMapTooltip) as typeof NonMemoizedHeatMapTooltip\n", "import { DefaultHeatMapDatum, HeatMapCommonProps, LayerId } from './types'\nimport { HeatMapTooltip } from './HeatMapTooltip'\n\nexport const commonDefaultProps: Omit<\n    HeatMapCommonProps<DefaultHeatMapDatum>,\n    | 'margin'\n    | 'theme'\n    | 'valueFormat'\n    | 'onClick'\n    | 'renderWrapper'\n    | 'role'\n    | 'ariaLabel'\n    | 'ariaLabelledBy'\n    | 'ariaDescribedBy'\n> & {\n    layers: LayerId[]\n} = {\n    layers: ['grid', 'axes', 'cells', 'legends', 'annotations'],\n\n    forceSquare: false,\n    xInnerPadding: 0,\n    xOuterPadding: 0,\n    yInnerPadding: 0,\n    yOuterPadding: 0,\n    sizeVariation: false,\n\n    opacity: 1,\n    activeOpacity: 1,\n    inactiveOpacity: 0.15,\n    borderWidth: 0,\n    borderColor: { from: 'color', modifiers: [['darker', 0.8]] },\n\n    enableGridX: false,\n    enableGridY: false,\n\n    enableLabels: true,\n    label: 'formattedValue',\n    labelTextColor: { from: 'color', modifiers: [['darker', 2]] },\n\n    colors: {\n        type: 'sequential',\n        scheme: 'brown_blueGreen',\n    },\n    emptyColor: '#000000',\n\n    legends: [],\n    annotations: [],\n\n    isInteractive: true,\n    hoverTarget: 'rowColumn',\n    tooltip: HeatMapTooltip,\n\n    animate: true,\n    motionConfig: 'gentle' as const,\n}\n\nexport const svgDefaultProps = {\n    ...commonDefaultProps,\n    axisTop: {},\n    axisRight: null,\n    axisBottom: null,\n    axisLeft: {},\n    borderRadius: 0,\n    cellComponent: 'rect' as const,\n}\n\nexport const canvasDefaultProps = {\n    ...commonDefaultProps,\n    axisTop: {},\n    axisRight: null,\n    axisBottom: null,\n    axisLeft: {},\n    renderCell: 'rect' as const,\n    pixelRatio: typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1,\n}\n", "import { scaleBand, scaleLinear } from 'd3-scale'\nimport { castBandScale } from '@nivo/scales'\nimport {\n    ComputedCell,\n    HeatMapCommonProps,\n    HeatMapDataProps,\n    HeatMapDatum,\n    SizeVariationConfig,\n} from './types'\n\nexport const computeLayout = ({\n    width: _width,\n    height: _height,\n    rows,\n    columns,\n    forceSquare,\n}: {\n    width: number\n    height: number\n    rows: number\n    columns: number\n    forceSquare: boolean\n}) => {\n    let width = _width\n    let height = _height\n\n    let offsetX = 0\n    let offsetY = 0\n\n    if (forceSquare) {\n        const cellWidth = Math.max(_width / columns, 0)\n        const cellHeight = Math.max(_height / rows, 0)\n        const cellSize = Math.min(cellWidth, cellHeight)\n\n        width = cellSize * columns\n        height = cellSize * rows\n\n        offsetX = (_width - width) / 2\n        offsetY = (_height - height) / 2\n    }\n\n    return {\n        offsetX,\n        offsetY,\n        width,\n        height,\n    }\n}\n\nexport const computeCells = <Datum extends HeatMapDatum, ExtraProps extends object>({\n    data,\n    width: _width,\n    height: _height,\n    xInnerPadding,\n    xOuterPadding,\n    yInnerPadding,\n    yOuterPadding,\n    forceSquare,\n}: {\n    data: HeatMapDataProps<Datum, ExtraProps>['data']\n    width: number\n    height: number\n} & Pick<\n    HeatMapCommonProps<Datum>,\n    'xOuterPadding' | 'xInnerPadding' | 'yOuterPadding' | 'yInnerPadding' | 'forceSquare'\n>) => {\n    const xValuesSet = new Set<Datum['x']>()\n    const serieIds: string[] = []\n    const allValues: number[] = []\n\n    const cells: Pick<ComputedCell<Datum>, 'id' | 'serieId' | 'value' | 'data'>[] = []\n\n    data.forEach(serie => {\n        serieIds.push(serie.id)\n\n        serie.data.forEach(datum => {\n            xValuesSet.add(datum.x)\n\n            let value: number | null = null\n            if (datum.y !== undefined && datum.y !== null) {\n                allValues.push(datum.y)\n                value = datum.y\n            }\n\n            cells.push({\n                id: `${serie.id}.${datum.x}`,\n                serieId: serie.id,\n                value,\n                data: datum,\n            })\n        })\n    })\n\n    const xValues = Array.from(xValuesSet)\n\n    const { width, height, offsetX, offsetY } = computeLayout({\n        width: _width,\n        height: _height,\n        columns: xValues.length,\n        rows: serieIds.length,\n        forceSquare,\n    })\n\n    const xScale = castBandScale<Datum['x']>(\n        scaleBand<Datum['x']>()\n            .domain(xValues)\n            .range([0, width])\n            .paddingOuter(xOuterPadding)\n            .paddingInner(xInnerPadding)\n    )\n\n    const yScale = castBandScale<string>(\n        scaleBand<string>()\n            .domain(serieIds)\n            .range([0, height])\n            .paddingOuter(yOuterPadding)\n            .paddingInner(yInnerPadding)\n    )\n\n    const cellWidth = xScale.bandwidth()\n    const cellHeight = yScale.bandwidth()\n\n    const cellsWithPosition: Omit<\n        ComputedCell<Datum>,\n        'formattedValue' | 'color' | 'opacity' | 'borderColor' | 'label' | 'labelTextColor'\n    >[] = cells.map(cell => ({\n        ...cell,\n        x: xScale(cell.data.x)! + cellWidth / 2,\n        y: yScale(cell.serieId)! + cellHeight / 2,\n        width: cellWidth,\n        height: cellHeight,\n    }))\n\n    return {\n        width,\n        height,\n        offsetX,\n        offsetY,\n        xScale,\n        yScale,\n        minValue: Math.min(...allValues),\n        maxValue: Math.max(...allValues),\n        cells: cellsWithPosition,\n    }\n}\n\nexport const computeSizeScale = (\n    size: false | SizeVariationConfig,\n    min: number,\n    max: number\n): ((value: number | null) => number) => {\n    if (!size) return () => 1\n\n    const scale = scaleLinear()\n        .domain(size.values ? size.values : [min, max])\n        .range(size.sizes)\n\n    return (value: number | null) => {\n        if (value === null) return 1\n        return scale(value)\n    }\n}\n\nexport const getCellAnnotationPosition = <Datum extends HeatMapDatum>(\n    cell: ComputedCell<Datum>\n) => ({\n    x: cell.x,\n    y: cell.y,\n})\n\nexport const getCellAnnotationDimensions = <Datum extends HeatMapDatum>(\n    cell: ComputedCell<Datum>\n) => ({\n    size: Math.max(cell.width, cell.height),\n    width: cell.width,\n    height: cell.height,\n})\n", "import { useMemo, useCallback, useState } from 'react'\nimport { useTheme, usePropertyAccessor, useValueFormatter } from '@nivo/core'\nimport { useInheritedColor, getContinuousColorScale } from '@nivo/colors'\nimport { AnnotationMatcher, useAnnotations } from '@nivo/annotations'\nimport {\n    ComputedCell,\n    DefaultHeatMapDatum,\n    HeatMapCommonProps,\n    HeatMapDataProps,\n    HeatMapDatum,\n    SizeVariationConfig,\n} from './types'\nimport { commonDefaultProps } from './defaults'\nimport {\n    computeCells,\n    computeSizeScale,\n    getCellAnnotationPosition,\n    getCellAnnotationDimensions,\n} from './compute'\n\nexport const useComputeCells = <Datum extends HeatMapDatum, ExtraProps extends object>({\n    data,\n    width,\n    height,\n    xInnerPadding,\n    xOuterPadding,\n    yInnerPadding,\n    yOuterPadding,\n    forceSquare,\n}: {\n    data: HeatMapDataProps<Datum, ExtraProps>['data']\n    width: number\n    height: number\n} & Pick<\n    HeatMapCommonProps<Datum>,\n    'xOuterPadding' | 'xInnerPadding' | 'yOuterPadding' | 'yInnerPadding' | 'forceSquare'\n>) =>\n    useMemo(\n        () =>\n            computeCells<Datum, ExtraProps>({\n                data,\n                width,\n                height,\n                xInnerPadding,\n                xOuterPadding,\n                yInnerPadding,\n                yOuterPadding,\n                forceSquare,\n            }),\n        [\n            data,\n            width,\n            height,\n            xInnerPadding,\n            xOuterPadding,\n            yInnerPadding,\n            yOuterPadding,\n            forceSquare,\n        ]\n    )\n\nconst isHoverTargetByType = {\n    cell: <Datum extends HeatMapDatum>(\n        cell: Omit<\n            ComputedCell<Datum>,\n            'formattedValue' | 'color' | 'opacity' | 'borderColor' | 'label' | 'labelTextColor'\n        >,\n        current: ComputedCell<Datum>\n    ) => cell.id === current.id,\n    row: <Datum extends HeatMapDatum>(\n        cell: Omit<\n            ComputedCell<Datum>,\n            'formattedValue' | 'color' | 'opacity' | 'borderColor' | 'label' | 'labelTextColor'\n        >,\n        current: ComputedCell<Datum>\n    ) => cell.serieId === current.serieId,\n    column: <Datum extends HeatMapDatum>(\n        cell: Omit<\n            ComputedCell<Datum>,\n            'formattedValue' | 'color' | 'opacity' | 'borderColor' | 'label' | 'labelTextColor'\n        >,\n        current: ComputedCell<Datum>\n    ) => cell.data.x === current.data.x,\n    rowColumn: <Datum extends HeatMapDatum>(\n        cell: Omit<\n            ComputedCell<Datum>,\n            'formattedValue' | 'color' | 'opacity' | 'borderColor' | 'label' | 'labelTextColor'\n        >,\n        current: ComputedCell<Datum>\n    ) => cell.serieId === current.serieId || cell.data.x === current.data.x,\n}\n\nconst useSizeScale = (\n    size: false | SizeVariationConfig,\n    min: number,\n    max: number\n): ((value: number | null) => number) =>\n    useMemo(() => computeSizeScale(size, min, max), [size, min, max])\n\nconst useCellsStyle = <Datum extends HeatMapDatum = DefaultHeatMapDatum>({\n    cells,\n    minValue,\n    maxValue,\n    sizeVariation,\n    colors,\n    emptyColor,\n    opacity,\n    activeOpacity,\n    inactiveOpacity,\n    borderColor,\n    label,\n    labelTextColor,\n    valueFormat,\n    activeIds,\n}: {\n    cells: Omit<\n        ComputedCell<Datum>,\n        'formattedValue' | 'color' | 'opacity' | 'borderColor' | 'label' | 'labelTextColor'\n    >[]\n    minValue: number\n    maxValue: number\n    valueFormat?: HeatMapCommonProps<Datum>['valueFormat']\n    activeIds: string[]\n} & Pick<\n    HeatMapCommonProps<Datum>,\n    | 'sizeVariation'\n    | 'colors'\n    | 'emptyColor'\n    | 'opacity'\n    | 'activeOpacity'\n    | 'inactiveOpacity'\n    | 'borderColor'\n    | 'label'\n    | 'labelTextColor'\n>) => {\n    const getSize = useSizeScale(sizeVariation, minValue, maxValue)\n\n    const colorScale = useMemo(() => {\n        if (typeof colors === 'function') return null\n\n        return getContinuousColorScale(colors, {\n            min: minValue,\n            max: maxValue,\n        })\n    }, [colors, minValue, maxValue])\n\n    const getColor = useCallback(\n        (cell: Omit<ComputedCell<Datum>, 'color' | 'opacity' | 'borderColor'>) => {\n            if (cell.value !== null) {\n                if (typeof colors === 'function') return colors(cell)\n                if (colorScale !== null) return colorScale(cell.value)\n            }\n\n            return emptyColor\n        },\n        [colors, colorScale, emptyColor]\n    )\n    const theme = useTheme()\n    const getBorderColor = useInheritedColor(borderColor, theme)\n    const getLabelTextColor = useInheritedColor(labelTextColor, theme)\n\n    const formatValue = useValueFormatter(valueFormat)\n    const getLabel = usePropertyAccessor(label)\n\n    const styledCells = useMemo(\n        () =>\n            cells.map(cell => {\n                let computedOpacity = opacity\n                if (activeIds.length > 0) {\n                    computedOpacity = activeIds.includes(cell.id) ? activeOpacity : inactiveOpacity\n                }\n\n                const sizeMultiplier = getSize(cell.value)\n\n                const computedCell = {\n                    ...cell,\n                    width: cell.width * sizeMultiplier,\n                    height: cell.height * sizeMultiplier,\n                    formattedValue: cell.value !== null ? formatValue(cell.value) : null,\n                    opacity: computedOpacity,\n                } as ComputedCell<Datum>\n\n                computedCell.label = getLabel(computedCell)\n                computedCell.color = getColor(computedCell)\n                computedCell.borderColor = getBorderColor(computedCell)\n                computedCell.labelTextColor = getLabelTextColor(computedCell)\n\n                return computedCell\n            }),\n        [\n            cells,\n            getSize,\n            getColor,\n            getBorderColor,\n            getLabelTextColor,\n            formatValue,\n            getLabel,\n            activeIds,\n            opacity,\n            activeOpacity,\n            inactiveOpacity,\n        ]\n    )\n\n    return {\n        cells: styledCells,\n        colorScale,\n    }\n}\n\nexport const useHeatMap = <\n    Datum extends HeatMapDatum = DefaultHeatMapDatum,\n    ExtraProps extends object = Record<string, never>\n>({\n    data,\n    valueFormat,\n    width: _width,\n    height: _height,\n    xOuterPadding = commonDefaultProps.xOuterPadding,\n    xInnerPadding = commonDefaultProps.xInnerPadding,\n    yOuterPadding = commonDefaultProps.yOuterPadding,\n    yInnerPadding = commonDefaultProps.yInnerPadding,\n    forceSquare = commonDefaultProps.forceSquare,\n    sizeVariation = commonDefaultProps.sizeVariation,\n    colors = commonDefaultProps.colors as HeatMapCommonProps<Datum>['colors'],\n    emptyColor = commonDefaultProps.emptyColor,\n    opacity = commonDefaultProps.opacity,\n    activeOpacity = commonDefaultProps.activeOpacity,\n    inactiveOpacity = commonDefaultProps.inactiveOpacity,\n    borderColor = commonDefaultProps.borderColor as HeatMapCommonProps<Datum>['borderColor'],\n    label = commonDefaultProps.label as HeatMapCommonProps<Datum>['label'],\n    labelTextColor = commonDefaultProps.labelTextColor as HeatMapCommonProps<Datum>['labelTextColor'],\n    hoverTarget = commonDefaultProps.hoverTarget,\n}: {\n    data: HeatMapDataProps<Datum, ExtraProps>['data']\n    width: number\n    height: number\n} & Partial<\n    Pick<\n        HeatMapCommonProps<Datum>,\n        | 'valueFormat'\n        | 'xOuterPadding'\n        | 'xInnerPadding'\n        | 'yOuterPadding'\n        | 'yInnerPadding'\n        | 'forceSquare'\n        | 'sizeVariation'\n        | 'colors'\n        | 'emptyColor'\n        | 'opacity'\n        | 'activeOpacity'\n        | 'inactiveOpacity'\n        | 'borderColor'\n        | 'label'\n        | 'labelTextColor'\n        | 'hoverTarget'\n    >\n>) => {\n    const [activeCell, setActiveCell] = useState<ComputedCell<Datum> | null>(null)\n\n    const { width, height, offsetX, offsetY, cells, xScale, yScale, minValue, maxValue } =\n        useComputeCells<Datum, ExtraProps>({\n            data,\n            width: _width,\n            height: _height,\n            xOuterPadding,\n            xInnerPadding,\n            yOuterPadding,\n            yInnerPadding,\n            forceSquare,\n        })\n\n    const activeIds = useMemo(() => {\n        if (!activeCell) return []\n\n        const isHoverTarget = isHoverTargetByType[hoverTarget]\n\n        return cells.filter(cell => isHoverTarget(cell, activeCell)).map(cell => cell.id)\n    }, [cells, activeCell, hoverTarget])\n\n    const { cells: computedCells, colorScale } = useCellsStyle<Datum>({\n        cells,\n        minValue,\n        maxValue,\n        sizeVariation,\n        colors,\n        emptyColor,\n        opacity,\n        activeOpacity,\n        inactiveOpacity,\n        borderColor,\n        label,\n        labelTextColor,\n        valueFormat,\n        activeIds,\n    })\n\n    return {\n        width,\n        height,\n        offsetX,\n        offsetY,\n        cells: computedCells,\n        xScale,\n        yScale,\n        colorScale,\n        activeCell,\n        setActiveCell,\n    }\n}\n\nexport const useCellAnnotations = <Datum extends HeatMapDatum>(\n    cells: ComputedCell<Datum>[],\n    annotations: AnnotationMatcher<ComputedCell<Datum>>[]\n) =>\n    useAnnotations<ComputedCell<Datum>>({\n        data: cells,\n        annotations,\n        getPosition: getCellAnnotationPosition,\n        getDimensions: getCellAnnotationDimensions,\n    })\n", "import { memo, useMemo } from 'react'\nimport { animated, to } from '@react-spring/web'\nimport { useTheme } from '@nivo/core'\nimport { CellComponentProps, HeatMapDatum } from './types'\n\nconst NonMemoizedHeatMapCellRect = <Datum extends HeatMapDatum>({\n    cell,\n    borderWidth,\n    borderRadius,\n    animatedProps,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onClick,\n    enableLabels,\n}: CellComponentProps<Datum>) => {\n    const theme = useTheme()\n\n    const handlers = useMemo(\n        () => ({\n            onMouseEnter: onMouseEnter ? onMouseEnter(cell) : undefined,\n            onMouseMove: onMouseMove ? onMouseMove(cell) : undefined,\n            onMouseLeave: onMouseLeave ? onMouseLeave(cell) : undefined,\n            onClick: onClick ? onClick(cell) : undefined,\n        }),\n        [cell, onMouseEnter, onMouseMove, onMouseLeave, onClick]\n    )\n\n    return (\n        <animated.g\n            data-testid={`cell.${cell.id}`}\n            style={{ cursor: 'pointer' }}\n            opacity={animatedProps.opacity}\n            {...handlers}\n            transform={to(\n                [animatedProps.x, animatedProps.y, animatedProps.scale],\n                (x, y, scale) => `translate(${x}, ${y}) scale(${scale})`\n            )}\n        >\n            <animated.rect\n                transform={to(\n                    [animatedProps.width, animatedProps.height],\n                    (width, height) => `translate(${width * -0.5}, ${height * -0.5})`\n                )}\n                key={cell.id}\n                fill={animatedProps.color}\n                width={animatedProps.width}\n                height={animatedProps.height}\n                stroke={animatedProps.borderColor}\n                strokeWidth={borderWidth}\n                rx={borderRadius}\n                ry={borderRadius}\n            />\n            {enableLabels && (\n                <animated.text\n                    textAnchor=\"middle\"\n                    dominantBaseline=\"central\"\n                    fill={animatedProps.labelTextColor}\n                    style={{\n                        ...theme.labels.text,\n                        fill: undefined,\n                        userSelect: 'none',\n                    }}\n                >\n                    {cell.label}\n                </animated.text>\n            )}\n        </animated.g>\n    )\n}\n\nexport const HeatMapCellRect = memo(NonMemoizedHeatMapCellRect) as typeof NonMemoizedHeatMapCellRect\n", "import { memo, useMemo } from 'react'\nimport { animated, to } from '@react-spring/web'\nimport { useTheme } from '@nivo/core'\nimport { HeatMapDatum, CellComponentProps } from './types'\n\nconst NonMemoizedHeatMapCellCircle = <Datum extends HeatMapDatum>({\n    cell,\n    borderWidth,\n    animatedProps,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onClick,\n    enableLabels,\n}: CellComponentProps<Datum>) => {\n    const theme = useTheme()\n\n    const handlers = useMemo(\n        () => ({\n            onMouseEnter: onMouseEnter ? onMouseEnter(cell) : undefined,\n            onMouseMove: onMouseMove ? onMouseMove(cell) : undefined,\n            onMouseLeave: onMouseLeave ? onMouseLeave(cell) : undefined,\n            onClick: onClick ? onClick(cell) : undefined,\n        }),\n        [cell, onMouseEnter, onMouseMove, onMouseLeave, onClick]\n    )\n\n    return (\n        <animated.g\n            data-testid={`cell.${cell.id}`}\n            style={{ cursor: 'pointer' }}\n            opacity={animatedProps.opacity}\n            {...handlers}\n            transform={to([animatedProps.x, animatedProps.y], (x, y) => `translate(${x}, ${y})`)}\n        >\n            <animated.circle\n                r={to(\n                    [animatedProps.width, animatedProps.height],\n                    (width, height) => Math.min(width, height) / 2\n                )}\n                fill={animatedProps.color}\n                fillOpacity={animatedProps.opacity}\n                strokeWidth={borderWidth}\n                stroke={animatedProps.borderColor}\n            />\n            {enableLabels && (\n                <animated.text\n                    dominantBaseline=\"central\"\n                    textAnchor=\"middle\"\n                    fill={animatedProps.labelTextColor}\n                    style={{\n                        ...theme.labels.text,\n                        fill: undefined,\n                    }}\n                >\n                    {cell.label}\n                </animated.text>\n            )}\n        </animated.g>\n    )\n}\n\nexport const HeatMapCellCircle = memo(\n    NonMemoizedHeatMapCellCircle\n) as typeof NonMemoizedHeatMapCellCircle\n", "import { createElement, MouseEvent, useMemo } from 'react'\nimport { useTransition } from '@react-spring/web'\nimport { useMotionConfig } from '@nivo/core'\nimport { useTooltip } from '@nivo/tooltip'\nimport {\n    CellComponent,\n    ComputedCell,\n    HeatMapDatum,\n    HeatMapSvgProps,\n    CellAnimatedProps,\n} from './types'\nimport { HeatMapCellRect } from './HeatMapCellRect'\nimport { HeatMapCellCircle } from './HeatMapCellCircle'\n\ninterface HeatMapCellsProps<Datum extends HeatMapDatum, ExtraProps extends object> {\n    cells: ComputedCell<Datum>[]\n    cellComponent: NonNullable<HeatMapSvgProps<Datum, ExtraProps>['cellComponent']>\n    borderRadius: NonNullable<HeatMapSvgProps<Datum, ExtraProps>['borderRadius']>\n    borderWidth: NonNullable<HeatMapSvgProps<Datum, ExtraProps>['borderWidth']>\n    isInteractive: NonNullable<HeatMapSvgProps<Datum, ExtraProps>['isInteractive']>\n    setActiveCell: (cell: ComputedCell<Datum> | null) => void\n    onMouseEnter: HeatMapSvgProps<Datum, ExtraProps>['onMouseEnter']\n    onMouseMove: HeatMapSvgProps<Datum, ExtraProps>['onMouseMove']\n    onMouseLeave: HeatMapSvgProps<Datum, ExtraProps>['onMouseLeave']\n    onClick: HeatMapSvgProps<Datum, ExtraProps>['onClick']\n    tooltip: NonNullable<HeatMapSvgProps<Datum, ExtraProps>['tooltip']>\n    enableLabels: NonNullable<HeatMapSvgProps<Datum, ExtraProps>['enableLabels']>\n}\n\nconst enterTransition = <Datum extends HeatMapDatum>(cell: ComputedCell<Datum>) => ({\n    x: cell.x,\n    y: cell.y,\n    width: cell.width,\n    height: cell.height,\n    color: cell.color,\n    opacity: 0,\n    borderColor: cell.borderColor,\n    labelTextColor: cell.labelTextColor,\n    scale: 0,\n})\n\nconst regularTransition = <Datum extends HeatMapDatum>(cell: ComputedCell<Datum>) => ({\n    x: cell.x,\n    y: cell.y,\n    width: cell.width,\n    height: cell.height,\n    color: cell.color,\n    opacity: cell.opacity,\n    borderColor: cell.borderColor,\n    labelTextColor: cell.labelTextColor,\n    scale: 1,\n})\n\nconst exitTransition = <Datum extends HeatMapDatum>(cell: ComputedCell<Datum>) => ({\n    x: cell.x,\n    y: cell.y,\n    width: cell.width,\n    height: cell.height,\n    color: cell.color,\n    opacity: 0,\n    borderColor: cell.borderColor,\n    labelTextColor: cell.labelTextColor,\n    scale: 0,\n})\n\nexport const HeatMapCells = <Datum extends HeatMapDatum, ExtraProps extends object>({\n    cells,\n    cellComponent,\n    borderRadius,\n    borderWidth,\n    isInteractive,\n    setActiveCell,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onClick,\n    tooltip,\n    enableLabels,\n}: HeatMapCellsProps<Datum, ExtraProps>) => {\n    const { animate, config: springConfig } = useMotionConfig()\n\n    const transition = useTransition<ComputedCell<Datum>, CellAnimatedProps>(cells, {\n        keys: (cell: ComputedCell<Datum>) => cell.id,\n        initial: regularTransition,\n        from: enterTransition,\n        enter: regularTransition,\n        update: regularTransition,\n        leave: exitTransition,\n        config: springConfig,\n        immediate: !animate,\n    })\n\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n\n    const handleMouseEnter = useMemo(() => {\n        if (!isInteractive) return undefined\n\n        return (cell: ComputedCell<Datum>) => (event: MouseEvent) => {\n            showTooltipFromEvent(createElement(tooltip, { cell }), event)\n            setActiveCell(cell)\n            onMouseEnter?.(cell, event)\n        }\n    }, [isInteractive, showTooltipFromEvent, tooltip, setActiveCell, onMouseEnter])\n\n    const handleMouseMove = useMemo(() => {\n        if (!isInteractive) return undefined\n\n        return (cell: ComputedCell<Datum>) => (event: MouseEvent) => {\n            showTooltipFromEvent(createElement(tooltip, { cell }), event)\n            onMouseMove?.(cell, event)\n        }\n    }, [isInteractive, showTooltipFromEvent, tooltip, onMouseMove])\n\n    const handleMouseLeave = useMemo(() => {\n        if (!isInteractive) return undefined\n\n        return (cell: ComputedCell<Datum>) => (event: MouseEvent) => {\n            hideTooltip()\n            setActiveCell(null)\n            onMouseLeave?.(cell, event)\n        }\n    }, [isInteractive, hideTooltip, setActiveCell, onMouseLeave])\n\n    const handleClick = useMemo(() => {\n        if (!isInteractive) return undefined\n\n        return (cell: ComputedCell<Datum>) => (event: MouseEvent) => {\n            onClick?.(cell, event)\n        }\n    }, [isInteractive, onClick])\n\n    let Cell: CellComponent<Datum>\n    if (cellComponent === 'rect') {\n        Cell = HeatMapCellRect\n    } else if (cellComponent === 'circle') {\n        Cell = HeatMapCellCircle\n    } else {\n        Cell = cellComponent\n    }\n\n    return (\n        <>\n            {transition((animatedProps, cell) =>\n                createElement(Cell, {\n                    cell,\n                    borderRadius,\n                    borderWidth,\n                    animatedProps,\n                    enableLabels,\n                    onMouseEnter: handleMouseEnter,\n                    onMouseMove: handleMouseMove,\n                    onMouseLeave: handleMouseLeave,\n                    onClick: handleClick,\n                })\n            )}\n        </>\n    )\n}\n", "import { Annotation } from '@nivo/annotations'\nimport { ComputedCell, HeatMapCommonProps, HeatMapDatum } from './types'\nimport { useCellAnnotations } from './hooks'\n\ninterface HeatMapCellAnnotationsProps<Datum extends HeatMapDatum> {\n    cells: ComputedCell<Datum>[]\n    annotations: NonNullable<HeatMapCommonProps<Datum>['annotations']>\n}\n\nexport const HeatMapCellAnnotations = <Datum extends HeatMapDatum>({\n    cells,\n    annotations,\n}: HeatMapCellAnnotationsProps<Datum>) => {\n    const boundAnnotations = useCellAnnotations<Datum>(cells, annotations)\n\n    return (\n        <>\n            {boundAnnotations.map((annotation, i) => (\n                <Annotation key={i} {...annotation} />\n            ))}\n        </>\n    )\n}\n", "import { ReactNode, Fragment, createElement, useMemo } from 'react'\nimport { SvgWrapper, Container, useDimensions } from '@nivo/core'\nimport { Axes, Grid } from '@nivo/axes'\nimport { AnchoredContinuousColorsLegendSvg } from '@nivo/legends'\nimport {\n    DefaultHeatMapDatum,\n    HeatMapDatum,\n    HeatMapCommonProps,\n    HeatMapSvgProps,\n    LayerId,\n    CustomLayerProps,\n} from './types'\nimport { useHeatMap } from './hooks'\nimport { svgDefaultProps } from './defaults'\nimport { HeatMapCells } from './HeatMapCells'\nimport { HeatMapCellAnnotations } from './HeatMapCellAnnotations'\n\ntype InnerHeatMapProps<Datum extends HeatMapDatum, ExtraProps extends object> = Omit<\n    HeatMapSvgProps<Datum, ExtraProps>,\n    'animate' | 'motionConfig' | 'renderWrapper' | 'theme'\n>\n\nconst InnerHeatMap = <Datum extends HeatMapDatum, ExtraProps extends object>({\n    data,\n    layers = svgDefaultProps.layers,\n    valueFormat,\n    width,\n    height,\n    margin: partialMargin,\n    forceSquare = svgDefaultProps.forceSquare,\n    xInnerPadding = svgDefaultProps.xInnerPadding,\n    xOuterPadding = svgDefaultProps.xOuterPadding,\n    yInnerPadding = svgDefaultProps.yInnerPadding,\n    yOuterPadding = svgDefaultProps.yOuterPadding,\n    sizeVariation = svgDefaultProps.sizeVariation,\n    cellComponent = svgDefaultProps.cellComponent as NonNullable<\n        HeatMapSvgProps<Datum, ExtraProps>['cellComponent']\n    >,\n    opacity = svgDefaultProps.opacity,\n    activeOpacity = svgDefaultProps.activeOpacity,\n    inactiveOpacity = svgDefaultProps.inactiveOpacity,\n    borderRadius = svgDefaultProps.borderRadius,\n    borderWidth = svgDefaultProps.borderWidth,\n    borderColor = svgDefaultProps.borderColor as HeatMapCommonProps<Datum>['borderColor'],\n    enableGridX = svgDefaultProps.enableGridX,\n    enableGridY = svgDefaultProps.enableGridY,\n    axisTop = svgDefaultProps.axisTop,\n    axisRight = svgDefaultProps.axisRight,\n    axisBottom = svgDefaultProps.axisBottom,\n    axisLeft = svgDefaultProps.axisLeft,\n    enableLabels = svgDefaultProps.enableLabels,\n    label = svgDefaultProps.label as HeatMapCommonProps<Datum>['label'],\n    labelTextColor = svgDefaultProps.labelTextColor as HeatMapCommonProps<Datum>['labelTextColor'],\n    colors = svgDefaultProps.colors as HeatMapCommonProps<Datum>['colors'],\n    emptyColor = svgDefaultProps.emptyColor,\n    legends = svgDefaultProps.legends,\n    annotations = svgDefaultProps.annotations as HeatMapCommonProps<Datum>['annotations'],\n    isInteractive = svgDefaultProps.isInteractive,\n    onMouseEnter,\n    onMouseMove,\n    onMouseLeave,\n    onClick,\n    hoverTarget = svgDefaultProps.hoverTarget,\n    tooltip = svgDefaultProps.tooltip as HeatMapCommonProps<Datum>['tooltip'],\n    role,\n    ariaLabel,\n    ariaLabelledBy,\n    ariaDescribedBy,\n}: InnerHeatMapProps<Datum, ExtraProps>) => {\n    const {\n        margin: _margin,\n        innerWidth: _innerWidth,\n        innerHeight: _innerHeight,\n        outerWidth,\n        outerHeight,\n    } = useDimensions(width, height, partialMargin)\n\n    const {\n        width: innerWidth,\n        height: innerHeight,\n        offsetX,\n        offsetY,\n        xScale,\n        yScale,\n        cells,\n        colorScale,\n        activeCell,\n        setActiveCell,\n    } = useHeatMap<Datum, ExtraProps>({\n        data,\n        valueFormat,\n        width: _innerWidth,\n        height: _innerHeight,\n        forceSquare,\n        xInnerPadding,\n        xOuterPadding,\n        yInnerPadding,\n        yOuterPadding,\n        sizeVariation,\n        colors,\n        emptyColor,\n        opacity,\n        activeOpacity,\n        inactiveOpacity,\n        borderColor,\n        label,\n        labelTextColor,\n        hoverTarget,\n    })\n\n    const margin = useMemo(\n        () => ({\n            ..._margin,\n            top: _margin.top + offsetY,\n            left: _margin.left + offsetX,\n        }),\n        [_margin, offsetX, offsetY]\n    )\n\n    const layerById: Record<LayerId, ReactNode> = {\n        grid: null,\n        axes: null,\n        cells: null,\n        legends: null,\n        annotations: null,\n    }\n\n    if (layers.includes('grid')) {\n        layerById.grid = (\n            <Grid\n                key=\"grid\"\n                width={innerWidth} // - offsetX * 2\n                height={innerHeight} // - offsetY * 2\n                xScale={enableGridX ? xScale : null}\n                yScale={enableGridY ? yScale : null}\n            />\n        )\n    }\n\n    if (layers.includes('axes')) {\n        layerById.axes = (\n            <Axes\n                key=\"axes\"\n                xScale={xScale}\n                yScale={yScale}\n                width={innerWidth} // - offsetX * 2\n                height={innerHeight} // - offsetY * 2\n                top={axisTop}\n                right={axisRight}\n                bottom={axisBottom}\n                left={axisLeft}\n            />\n        )\n    }\n\n    if (layers.includes('cells')) {\n        layerById.cells = (\n            <Fragment key=\"cells\">\n                <HeatMapCells<Datum, ExtraProps>\n                    cells={cells}\n                    cellComponent={cellComponent}\n                    borderRadius={borderRadius}\n                    borderWidth={borderWidth}\n                    isInteractive={isInteractive}\n                    setActiveCell={setActiveCell}\n                    onMouseEnter={onMouseEnter}\n                    onMouseMove={onMouseMove}\n                    onMouseLeave={onMouseLeave}\n                    onClick={onClick}\n                    tooltip={tooltip}\n                    enableLabels={enableLabels}\n                />\n            </Fragment>\n        )\n    }\n\n    if (layers.includes('legends') && colorScale !== null) {\n        layerById.legends = (\n            <Fragment key=\"legends\">\n                {legends.map((legend, index) => (\n                    <AnchoredContinuousColorsLegendSvg\n                        {...legend}\n                        key={index}\n                        containerWidth={innerWidth}\n                        containerHeight={innerHeight}\n                        scale={colorScale}\n                    />\n                ))}\n            </Fragment>\n        )\n    }\n\n    if (layers.includes('annotations') && annotations.length > 0) {\n        layerById.annotations = (\n            <HeatMapCellAnnotations<Datum>\n                key=\"annotations\"\n                cells={cells}\n                annotations={annotations}\n            />\n        )\n    }\n\n    const customLayerProps: CustomLayerProps<Datum> = {\n        cells,\n        activeCell,\n        setActiveCell,\n    }\n\n    return (\n        <SvgWrapper\n            width={outerWidth}\n            height={outerHeight}\n            margin={Object.assign({}, margin, {\n                top: margin.top, //+ offsetY,\n                left: margin.left, // + offsetX,\n            })}\n            role={role}\n            ariaLabel={ariaLabel}\n            ariaLabelledBy={ariaLabelledBy}\n            ariaDescribedBy={ariaDescribedBy}\n        >\n            {layers.map((layer, i) => {\n                if (typeof layer === 'function') {\n                    return <Fragment key={i}>{createElement(layer, customLayerProps)}</Fragment>\n                }\n\n                return layerById?.[layer] ?? null\n            })}\n        </SvgWrapper>\n    )\n}\n\nexport const HeatMap = <\n    Datum extends HeatMapDatum = DefaultHeatMapDatum,\n    ExtraProps extends object = Record<string, never>\n>({\n    isInteractive = svgDefaultProps.isInteractive,\n    animate = svgDefaultProps.animate,\n    motionConfig = svgDefaultProps.motionConfig,\n    theme,\n    renderWrapper,\n    ...otherProps\n}: HeatMapSvgProps<Datum, ExtraProps>) => (\n    <Container\n        {...{\n            animate,\n            isInteractive,\n            motionConfig,\n            renderWrapper,\n            theme,\n        }}\n    >\n        <InnerHeatMap<Datum, ExtraProps> isInteractive={isInteractive} {...otherProps} />\n    </Container>\n)\n", "import { ResponsiveWrapper } from '@nivo/core'\nimport { DefaultHeatMapDatum, HeatMapDatum, HeatMapSvgProps } from './types'\nimport { HeatMap } from './HeatMap'\n\nexport const ResponsiveHeatMap = <\n    Datum extends HeatMapDatum = DefaultHeatMapDatum,\n    ExtraProps extends object = Record<string, never>\n>(\n    props: Omit<HeatMapSvgProps<Datum, ExtraProps>, 'height' | 'width'>\n) => (\n    <ResponsiveWrapper>\n        {({ width, height }) => (\n            <HeatMap<Datum, ExtraProps> width={width} height={height} {...props} />\n        )}\n    </ResponsiveWrapper>\n)\n", "import { CellCanvasRendererProps, HeatMapDatum } from './types'\n\nexport const renderRect = <Datum extends HeatMapDatum>(\n    ctx: CanvasRenderingContext2D,\n    {\n        cell: { x, y, width, height, color, borderColor, opacity, labelTextColor, label },\n        borderWidth,\n        enableLabels,\n        theme,\n    }: CellCanvasRendererProps<Datum>\n) => {\n    ctx.save()\n    ctx.globalAlpha = opacity\n\n    ctx.fillStyle = color\n    if (borderWidth > 0) {\n        ctx.strokeStyle = borderColor\n        ctx.lineWidth = borderWidth\n    }\n\n    ctx.fillRect(x - width / 2, y - height / 2, width, height)\n    if (borderWidth > 0) {\n        ctx.strokeRect(x - width / 2, y - height / 2, width, height)\n    }\n\n    if (enableLabels) {\n        ctx.fillStyle = labelTextColor\n        ctx.font = `${theme.labels.text.fontWeight ? `${theme.labels.text.fontWeight} ` : ''}${\n            theme.labels.text.fontSize\n        }px ${theme.labels.text.fontFamily}`\n        ctx.textAlign = 'center'\n        ctx.textBaseline = 'middle'\n        ctx.fillText(label, x, y)\n    }\n\n    ctx.restore()\n}\n\nexport const renderCircle = <Datum extends HeatMapDatum>(\n    ctx: CanvasRenderingContext2D,\n    {\n        cell: { x, y, width, height, color, borderColor, opacity, labelTextColor, label },\n        borderWidth,\n        enableLabels,\n        theme,\n    }: CellCanvasRendererProps<Datum>\n) => {\n    ctx.save()\n    ctx.globalAlpha = opacity\n\n    const radius = Math.min(width, height) / 2\n\n    ctx.fillStyle = color\n    if (borderWidth > 0) {\n        ctx.strokeStyle = borderColor\n        ctx.lineWidth = borderWidth\n    }\n\n    ctx.beginPath()\n    ctx.arc(x, y, radius, 0, 2 * Math.PI)\n\n    ctx.fill()\n    if (borderWidth > 0) {\n        ctx.stroke()\n    }\n\n    if (enableLabels) {\n        ctx.fillStyle = labelTextColor\n        ctx.font = `${theme.labels.text.fontWeight ? `${theme.labels.text.fontWeight} ` : ''}${\n            theme.labels.text.fontSize\n        }px ${theme.labels.text.fontFamily}`\n        ctx.textAlign = 'center'\n        ctx.textBaseline = 'middle'\n        ctx.fillText(label, x, y)\n    }\n\n    ctx.restore()\n}\n", "import { useEffect, useRef, useCallback, createElement, useMemo, MouseEvent } from 'react'\nimport { getRelativeCursor, isCursorInRect, useDimensions, useTheme, Container } from '@nivo/core'\nimport { renderAxesToCanvas, renderGridLinesToCanvas } from '@nivo/axes'\nimport { useTooltip } from '@nivo/tooltip'\nimport { renderContinuousColorLegendToCanvas } from '@nivo/legends'\nimport { renderAnnotationsToCanvas, useComputedAnnotations } from '@nivo/annotations'\nimport { useHeatMap, useCellAnnotations } from './hooks'\nimport { renderRect, renderCircle } from './canvas'\nimport { canvasDefaultProps } from './defaults'\nimport {\n    CellCanvasRenderer,\n    DefaultHeatMapDatum,\n    HeatMapCanvasProps,\n    HeatMapCommonProps,\n    HeatMapDatum,\n    CellShape,\n    CustomLayerProps,\n} from './types'\n\ntype InnerNetworkCanvasProps<Datum extends HeatMapDatum, ExtraProps extends object> = Omit<\n    HeatMapCanvasProps<Datum, ExtraProps>,\n    'renderWrapper' | 'theme'\n>\n\nconst InnerHeatMapCanvas = <Datum extends HeatMapDatum, ExtraProps extends object>({\n    data,\n    layers = canvasDefaultProps.layers,\n    valueFormat,\n    width,\n    height,\n    margin: partialMargin,\n    xInnerPadding = canvasDefaultProps.xInnerPadding,\n    xOuterPadding = canvasDefaultProps.xOuterPadding,\n    yInnerPadding = canvasDefaultProps.yInnerPadding,\n    yOuterPadding = canvasDefaultProps.yOuterPadding,\n    forceSquare = canvasDefaultProps.forceSquare,\n    sizeVariation = canvasDefaultProps.sizeVariation,\n    renderCell: _renderCell = canvasDefaultProps.renderCell as CellShape,\n    opacity = canvasDefaultProps.opacity,\n    activeOpacity = canvasDefaultProps.activeOpacity,\n    inactiveOpacity = canvasDefaultProps.inactiveOpacity,\n    borderWidth = canvasDefaultProps.borderWidth,\n    borderColor = canvasDefaultProps.borderColor as HeatMapCommonProps<Datum>['borderColor'],\n    enableGridX = canvasDefaultProps.enableGridX,\n    enableGridY = canvasDefaultProps.enableGridY,\n    axisTop = canvasDefaultProps.axisTop,\n    axisRight = canvasDefaultProps.axisRight,\n    axisBottom = canvasDefaultProps.axisBottom,\n    axisLeft = canvasDefaultProps.axisLeft,\n    enableLabels = canvasDefaultProps.enableLabels,\n    label = canvasDefaultProps.label as HeatMapCommonProps<Datum>['label'],\n    labelTextColor = canvasDefaultProps.labelTextColor as HeatMapCommonProps<Datum>['labelTextColor'],\n    colors = canvasDefaultProps.colors as HeatMapCommonProps<Datum>['colors'],\n    emptyColor = canvasDefaultProps.emptyColor,\n    legends = canvasDefaultProps.legends,\n    annotations = canvasDefaultProps.annotations as HeatMapCommonProps<Datum>['annotations'],\n    isInteractive = canvasDefaultProps.isInteractive,\n    onClick,\n    hoverTarget = canvasDefaultProps.hoverTarget,\n    tooltip = canvasDefaultProps.tooltip as HeatMapCommonProps<Datum>['tooltip'],\n    role,\n    ariaLabel,\n    ariaLabelledBy,\n    ariaDescribedBy,\n    pixelRatio = canvasDefaultProps.pixelRatio,\n}: InnerNetworkCanvasProps<Datum, ExtraProps>) => {\n    const canvasEl = useRef<HTMLCanvasElement | null>(null)\n\n    const {\n        margin: _margin,\n        innerWidth: _innerWidth,\n        innerHeight: _innerHeight,\n        outerWidth,\n        outerHeight,\n    } = useDimensions(width, height, partialMargin)\n\n    const {\n        width: innerWidth,\n        height: innerHeight,\n        offsetX,\n        offsetY,\n        xScale,\n        yScale,\n        cells,\n        colorScale,\n        activeCell,\n        setActiveCell,\n    } = useHeatMap<Datum, ExtraProps>({\n        data,\n        valueFormat,\n        width: _innerWidth,\n        height: _innerHeight,\n        xInnerPadding,\n        xOuterPadding,\n        yInnerPadding,\n        yOuterPadding,\n        forceSquare,\n        sizeVariation,\n        colors,\n        emptyColor,\n        opacity,\n        activeOpacity,\n        inactiveOpacity,\n        borderColor,\n        label,\n        labelTextColor,\n        hoverTarget,\n    })\n\n    const margin = useMemo(\n        () => ({\n            ..._margin,\n            top: _margin.top + offsetY,\n            left: _margin.left + offsetX,\n        }),\n        [_margin, offsetX, offsetY]\n    )\n\n    const boundAnnotations = useCellAnnotations(cells, annotations)\n    const computedAnnotations = useComputedAnnotations({\n        annotations: boundAnnotations,\n    })\n\n    let renderCell: CellCanvasRenderer<Datum>\n    if (typeof _renderCell === 'function') {\n        renderCell = _renderCell\n    } else if (_renderCell === 'circle') {\n        renderCell = renderCircle\n    } else {\n        renderCell = renderRect\n    }\n\n    const theme = useTheme()\n\n    const customLayerProps: CustomLayerProps<Datum> = useMemo(\n        () => ({\n            cells,\n            activeCell,\n            setActiveCell,\n        }),\n        [cells, activeCell, setActiveCell]\n    )\n\n    useEffect(() => {\n        if (canvasEl.current === null) return\n\n        const ctx = canvasEl.current.getContext('2d')\n        if (!ctx) return\n\n        canvasEl.current.width = outerWidth * pixelRatio\n        canvasEl.current.height = outerHeight * pixelRatio\n\n        ctx.scale(pixelRatio, pixelRatio)\n\n        ctx.fillStyle = theme.background\n        ctx.fillRect(0, 0, outerWidth, outerHeight)\n        ctx.translate(margin.left, margin.top) // + offsetX, margin.top + offsetY)\n\n        layers.forEach(layer => {\n            if (layer === 'grid') {\n                ctx.lineWidth = theme.grid.line.strokeWidth as number\n                ctx.strokeStyle = theme.grid.line.stroke as string\n\n                if (enableGridX) {\n                    renderGridLinesToCanvas(ctx, {\n                        width: innerWidth,\n                        height: innerHeight,\n                        scale: xScale,\n                        axis: 'x',\n                    })\n                }\n                if (enableGridY) {\n                    renderGridLinesToCanvas(ctx, {\n                        width: innerWidth,\n                        height: innerHeight,\n                        scale: yScale,\n                        axis: 'y',\n                    })\n                }\n            } else if (layer === 'axes') {\n                renderAxesToCanvas(ctx, {\n                    xScale,\n                    yScale,\n                    width: innerWidth, // - offsetX * 2,\n                    height: innerHeight, // - offsetY * 2,\n                    top: axisTop,\n                    right: axisRight,\n                    bottom: axisBottom,\n                    left: axisLeft,\n                    theme,\n                })\n            } else if (layer === 'cells') {\n                ctx.textAlign = 'center'\n                ctx.textBaseline = 'middle'\n\n                cells.forEach(cell => {\n                    renderCell(ctx, { cell, borderWidth, enableLabels, theme })\n                })\n            } else if (layer === 'legends' && colorScale !== null) {\n                legends.forEach(legend => {\n                    renderContinuousColorLegendToCanvas(ctx, {\n                        ...legend,\n                        containerWidth: innerWidth,\n                        containerHeight: innerHeight,\n                        scale: colorScale,\n                        theme,\n                    })\n                })\n            } else if (layer === 'annotations') {\n                renderAnnotationsToCanvas(ctx, {\n                    annotations: computedAnnotations,\n                    theme,\n                })\n            } else if (typeof layer === 'function') {\n                layer(ctx, customLayerProps)\n            }\n        })\n    }, [\n        canvasEl,\n        pixelRatio,\n        outerWidth,\n        outerHeight,\n        innerWidth,\n        innerHeight,\n        margin,\n        layers,\n        customLayerProps,\n        cells,\n        renderCell,\n        enableGridX,\n        enableGridY,\n        axisTop,\n        axisRight,\n        axisBottom,\n        axisLeft,\n        xScale,\n        yScale,\n        theme,\n        borderWidth,\n        enableLabels,\n        colorScale,\n        legends,\n        computedAnnotations,\n    ])\n\n    const { showTooltipFromEvent, hideTooltip } = useTooltip()\n\n    const handleMouseHover = useCallback(\n        (event: MouseEvent<HTMLCanvasElement>) => {\n            if (canvasEl.current === null) return\n\n            const [x, y] = getRelativeCursor(canvasEl.current, event)\n\n            const cell = cells.find(c =>\n                isCursorInRect(\n                    c.x + margin.left - c.width / 2, // + offsetX - c.width / 2,\n                    c.y + margin.top - c.height / 2, //+ offsetY - c.height / 2,\n                    c.width,\n                    c.height,\n                    x,\n                    y\n                )\n            )\n            if (cell !== undefined) {\n                setActiveCell(cell)\n                showTooltipFromEvent(createElement(tooltip, { cell }), event)\n            } else {\n                setActiveCell(null)\n                hideTooltip()\n            }\n        },\n        [\n            canvasEl,\n            cells,\n            margin,\n            // offsetX,\n            // offsetY,\n            setActiveCell,\n            showTooltipFromEvent,\n            hideTooltip,\n            tooltip,\n        ]\n    )\n\n    const handleMouseLeave = useCallback(() => {\n        setActiveCell(null)\n        hideTooltip()\n    }, [setActiveCell, hideTooltip])\n\n    const handleClick = useCallback(\n        (event: MouseEvent<HTMLCanvasElement>) => {\n            if (activeCell === null) return\n\n            onClick?.(activeCell, event)\n        },\n        [activeCell, onClick]\n    )\n\n    return (\n        <canvas\n            ref={canvasEl}\n            width={outerWidth * pixelRatio}\n            height={outerHeight * pixelRatio}\n            style={{\n                width: outerWidth,\n                height: outerHeight,\n            }}\n            onMouseEnter={isInteractive ? handleMouseHover : undefined}\n            onMouseMove={isInteractive ? handleMouseHover : undefined}\n            onMouseLeave={isInteractive ? handleMouseLeave : undefined}\n            onClick={isInteractive ? handleClick : undefined}\n            role={role}\n            aria-label={ariaLabel}\n            aria-labelledby={ariaLabelledBy}\n            aria-describedby={ariaDescribedBy}\n        />\n    )\n}\n\nexport const HeatMapCanvas = <\n    Datum extends HeatMapDatum = DefaultHeatMapDatum,\n    ExtraProps extends object = Record<string, never>\n>({\n    theme,\n    isInteractive = canvasDefaultProps.isInteractive,\n    animate = canvasDefaultProps.animate,\n    motionConfig = canvasDefaultProps.motionConfig,\n    renderWrapper,\n    ...otherProps\n}: HeatMapCanvasProps<Datum, ExtraProps>) => (\n    <Container {...{ isInteractive, animate, motionConfig, theme, renderWrapper }}>\n        <InnerHeatMapCanvas<Datum, ExtraProps> isInteractive={isInteractive} {...otherProps} />\n    </Container>\n)\n", "import { ResponsiveWrapper } from '@nivo/core'\nimport { DefaultHeatMapDatum, HeatMapCanvasProps, HeatMapDatum } from './types'\nimport { HeatMapCanvas } from './HeatMapCanvas'\n\nexport const ResponsiveHeatMapCanvas = <\n    Datum extends HeatMapDatum = DefaultHeatMapDatum,\n    ExtraProps extends object = Record<string, never>\n>(\n    props: Omit<HeatMapCanvasProps<Datum, ExtraProps>, 'height' | 'width'>\n) => (\n    <ResponsiveWrapper>\n        {({ width, height }) => (\n            <HeatMapCanvas<Datum, ExtraProps> width={width} height={height} {...props} />\n        )}\n    </ResponsiveWrapper>\n)\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA,QAAI,WAAW;AAoBf,aAAS,KAAK,OAAO;AACnB,aAAQ,SAAS,MAAM,SAAU,SAAS,KAAK,IAAI,CAAC;AAAA,IACtD;AAEA,WAAO,UAAU;AAAA;AAAA;;;ACxBjB;AAAA;AAAA,QAAI,aAAa;AAAjB,QACI,eAAe;AAGnB,QAAI,UAAU;AASd,aAAS,WAAW,OAAO;AACzB,aAAO,aAAa,KAAK,KAAK,WAAW,KAAK,KAAK;AAAA,IACrD;AAEA,WAAO,UAAU;AAAA;AAAA;;;ACjBjB;AAAA;AAAA,QAAI,aAAa;AAAjB,QACI,YAAY;AADhB,QAEI,WAAW;AAGf,QAAI,aAAa,YAAY,SAAS;AAmBtC,QAAI,SAAS,aAAa,UAAU,UAAU,IAAI;AAElD,WAAO,UAAU;AAAA;AAAA;;;AC1BjB;AAAA;AAAA,QAAI,WAAW;AAUf,aAAS,WAAW,YAAY,WAAW;AACzC,UAAI,SAAS,CAAC;AACd,eAAS,YAAY,SAAS,OAAO,OAAOA,aAAY;AACtD,YAAI,UAAU,OAAO,OAAOA,WAAU,GAAG;AACvC,iBAAO,KAAK,KAAK;AAAA,QACnB;AAAA,MACF,CAAC;AACD,aAAO;AAAA,IACT;AAEA,WAAO,UAAU;AAAA;AAAA;;;ACpBjB;AAAA;AAAA,QAAI,cAAc;AAAlB,QACI,aAAa;AADjB,QAEI,eAAe;AAFnB,QAGI,UAAU;AA2Cd,aAAS,OAAO,YAAY,WAAW;AACrC,UAAI,OAAO,QAAQ,UAAU,IAAI,cAAc;AAC/C,aAAO,KAAK,YAAY,aAAa,WAAW,CAAC,CAAC;AAAA,IACpD;AAEA,WAAO,UAAU;AAAA;AAAA;;;;;;;;;;;ACnDF,SAAR,sBAAiBC,IAAG;AACzB,SAAO,KAAK,IAAIA,KAAI,KAAK,MAAMA,EAAC,CAAC,KAAK,OAChCA,GAAE,eAAe,IAAI,EAAE,QAAQ,MAAM,EAAE,IACvCA,GAAE,SAAS,EAAE;AACrB;AAKO,SAAS,mBAAmBA,IAAGC,IAAG;AACvC,OAAKC,MAAKF,KAAIC,KAAID,GAAE,cAAcC,KAAI,CAAC,IAAID,GAAE,cAAc,GAAG,QAAQ,GAAG,KAAK,EAAG,QAAO;AACxF,MAAIE,IAAG,cAAcF,GAAE,MAAM,GAAGE,EAAC;AAIjC,SAAO;AAAA,IACL,YAAY,SAAS,IAAI,YAAY,CAAC,IAAI,YAAY,MAAM,CAAC,IAAI;AAAA,IACjE,CAACF,GAAE,MAAME,KAAI,CAAC;AAAA,EAChB;AACF;;;ACjBe,SAAR,iBAAiBC,IAAG;AACzB,SAAOA,KAAI,mBAAmB,KAAK,IAAIA,EAAC,CAAC,GAAGA,KAAIA,GAAE,CAAC,IAAI;AACzD;;;ACJe,SAAR,oBAAiB,UAAU,WAAW;AAC3C,SAAO,SAAS,OAAO,OAAO;AAC5B,QAAIC,KAAI,MAAM,QACVC,KAAI,CAAC,GACLC,KAAI,GACJC,KAAI,SAAS,CAAC,GACd,SAAS;AAEb,WAAOH,KAAI,KAAKG,KAAI,GAAG;AACrB,UAAI,SAASA,KAAI,IAAI,MAAO,CAAAA,KAAI,KAAK,IAAI,GAAG,QAAQ,MAAM;AAC1D,MAAAF,GAAE,KAAK,MAAM,UAAUD,MAAKG,IAAGH,KAAIG,EAAC,CAAC;AACrC,WAAK,UAAUA,KAAI,KAAK,MAAO;AAC/B,MAAAA,KAAI,SAASD,MAAKA,KAAI,KAAK,SAAS,MAAM;AAAA,IAC5C;AAEA,WAAOD,GAAE,QAAQ,EAAE,KAAK,SAAS;AAAA,EACnC;AACF;;;ACjBe,SAAR,uBAAiB,UAAU;AAChC,SAAO,SAAS,OAAO;AACrB,WAAO,MAAM,QAAQ,UAAU,SAASG,IAAG;AACzC,aAAO,SAAS,CAACA,EAAC;AAAA,IACpB,CAAC;AAAA,EACH;AACF;;;ACLA,IAAI,KAAK;AAEM,SAAR,gBAAiC,WAAW;AACjD,MAAI,EAAE,QAAQ,GAAG,KAAK,SAAS,GAAI,OAAM,IAAI,MAAM,qBAAqB,SAAS;AACjF,MAAI;AACJ,SAAO,IAAI,gBAAgB;AAAA,IACzB,MAAM,MAAM,CAAC;AAAA,IACb,OAAO,MAAM,CAAC;AAAA,IACd,MAAM,MAAM,CAAC;AAAA,IACb,QAAQ,MAAM,CAAC;AAAA,IACf,MAAM,MAAM,CAAC;AAAA,IACb,OAAO,MAAM,CAAC;AAAA,IACd,OAAO,MAAM,CAAC;AAAA,IACd,WAAW,MAAM,CAAC,KAAK,MAAM,CAAC,EAAE,MAAM,CAAC;AAAA,IACvC,MAAM,MAAM,CAAC;AAAA,IACb,MAAM,MAAM,EAAE;AAAA,EAChB,CAAC;AACH;AAEA,gBAAgB,YAAY,gBAAgB;AAErC,SAAS,gBAAgB,WAAW;AACzC,OAAK,OAAO,UAAU,SAAS,SAAY,MAAM,UAAU,OAAO;AAClE,OAAK,QAAQ,UAAU,UAAU,SAAY,MAAM,UAAU,QAAQ;AACrE,OAAK,OAAO,UAAU,SAAS,SAAY,MAAM,UAAU,OAAO;AAClE,OAAK,SAAS,UAAU,WAAW,SAAY,KAAK,UAAU,SAAS;AACvE,OAAK,OAAO,CAAC,CAAC,UAAU;AACxB,OAAK,QAAQ,UAAU,UAAU,SAAY,SAAY,CAAC,UAAU;AACpE,OAAK,QAAQ,CAAC,CAAC,UAAU;AACzB,OAAK,YAAY,UAAU,cAAc,SAAY,SAAY,CAAC,UAAU;AAC5E,OAAK,OAAO,CAAC,CAAC,UAAU;AACxB,OAAK,OAAO,UAAU,SAAS,SAAY,KAAK,UAAU,OAAO;AACnE;AAEA,gBAAgB,UAAU,WAAW,WAAW;AAC9C,SAAO,KAAK,OACN,KAAK,QACL,KAAK,OACL,KAAK,UACJ,KAAK,OAAO,MAAM,OAClB,KAAK,UAAU,SAAY,KAAK,KAAK,IAAI,GAAG,KAAK,QAAQ,CAAC,MAC1D,KAAK,QAAQ,MAAM,OACnB,KAAK,cAAc,SAAY,KAAK,MAAM,KAAK,IAAI,GAAG,KAAK,YAAY,CAAC,MACxE,KAAK,OAAO,MAAM,MACnB,KAAK;AACb;;;AC7Ce,SAAR,mBAAiB,GAAG;AACzB,MAAK,UAASC,KAAI,EAAE,QAAQC,KAAI,GAAG,KAAK,IAAI,IAAIA,KAAID,IAAG,EAAEC,IAAG;AAC1D,YAAQ,EAAEA,EAAC,GAAG;AAAA,MACZ,KAAK;AAAK,aAAK,KAAKA;AAAG;AAAA,MACvB,KAAK;AAAK,YAAI,OAAO,EAAG,MAAKA;AAAG,aAAKA;AAAG;AAAA,MACxC;AAAS,YAAI,CAAC,CAAC,EAAEA,EAAC,EAAG,OAAM;AAAK,YAAI,KAAK,EAAG,MAAK;AAAG;AAAA,IACtD;AAAA,EACF;AACA,SAAO,KAAK,IAAI,EAAE,MAAM,GAAG,EAAE,IAAI,EAAE,MAAM,KAAK,CAAC,IAAI;AACrD;;;ACRO,IAAI;AAEI,SAAR,yBAAiBC,IAAGC,IAAG;AAC5B,MAAI,IAAI,mBAAmBD,IAAGC,EAAC;AAC/B,MAAI,CAAC,EAAG,QAAOD,KAAI;AACnB,MAAI,cAAc,EAAE,CAAC,GACjB,WAAW,EAAE,CAAC,GACdE,KAAI,YAAY,iBAAiB,KAAK,IAAI,IAAI,KAAK,IAAI,GAAG,KAAK,MAAM,WAAW,CAAC,CAAC,CAAC,IAAI,KAAK,GAC5FC,KAAI,YAAY;AACpB,SAAOD,OAAMC,KAAI,cACXD,KAAIC,KAAI,cAAc,IAAI,MAAMD,KAAIC,KAAI,CAAC,EAAE,KAAK,GAAG,IACnDD,KAAI,IAAI,YAAY,MAAM,GAAGA,EAAC,IAAI,MAAM,YAAY,MAAMA,EAAC,IAC3D,OAAO,IAAI,MAAM,IAAIA,EAAC,EAAE,KAAK,GAAG,IAAI,mBAAmBF,IAAG,KAAK,IAAI,GAAGC,KAAIC,KAAI,CAAC,CAAC,EAAE,CAAC;AAC3F;;;ACbe,SAAR,sBAAiBE,IAAGC,IAAG;AAC5B,MAAI,IAAI,mBAAmBD,IAAGC,EAAC;AAC/B,MAAI,CAAC,EAAG,QAAOD,KAAI;AACnB,MAAI,cAAc,EAAE,CAAC,GACjB,WAAW,EAAE,CAAC;AAClB,SAAO,WAAW,IAAI,OAAO,IAAI,MAAM,CAAC,QAAQ,EAAE,KAAK,GAAG,IAAI,cACxD,YAAY,SAAS,WAAW,IAAI,YAAY,MAAM,GAAG,WAAW,CAAC,IAAI,MAAM,YAAY,MAAM,WAAW,CAAC,IAC7G,cAAc,IAAI,MAAM,WAAW,YAAY,SAAS,CAAC,EAAE,KAAK,GAAG;AAC3E;;;ACNA,IAAO,sBAAQ;AAAA,EACb,KAAK,SAASE,IAAGC,IAAG;AAAE,YAAQD,KAAI,KAAK,QAAQC,EAAC;AAAA,EAAG;AAAA,EACnD,KAAK,SAASD,IAAG;AAAE,WAAO,KAAK,MAAMA,EAAC,EAAE,SAAS,CAAC;AAAA,EAAG;AAAA,EACrD,KAAK,SAASA,IAAG;AAAE,WAAOA,KAAI;AAAA,EAAI;AAAA,EAClC,KAAK;AAAA,EACL,KAAK,SAASA,IAAGC,IAAG;AAAE,WAAOD,GAAE,cAAcC,EAAC;AAAA,EAAG;AAAA,EACjD,KAAK,SAASD,IAAGC,IAAG;AAAE,WAAOD,GAAE,QAAQC,EAAC;AAAA,EAAG;AAAA,EAC3C,KAAK,SAASD,IAAGC,IAAG;AAAE,WAAOD,GAAE,YAAYC,EAAC;AAAA,EAAG;AAAA,EAC/C,KAAK,SAASD,IAAG;AAAE,WAAO,KAAK,MAAMA,EAAC,EAAE,SAAS,CAAC;AAAA,EAAG;AAAA,EACrD,KAAK,SAASA,IAAGC,IAAG;AAAE,WAAO,sBAAcD,KAAI,KAAKC,EAAC;AAAA,EAAG;AAAA,EACxD,KAAK;AAAA,EACL,KAAK;AAAA,EACL,KAAK,SAASD,IAAG;AAAE,WAAO,KAAK,MAAMA,EAAC,EAAE,SAAS,EAAE,EAAE,YAAY;AAAA,EAAG;AAAA,EACpE,KAAK,SAASA,IAAG;AAAE,WAAO,KAAK,MAAMA,EAAC,EAAE,SAAS,EAAE;AAAA,EAAG;AACxD;;;AClBe,SAAR,iBAAiBE,IAAG;AACzB,SAAOA;AACT;;;ACOA,IAAI,MAAM,MAAM,UAAU;AAA1B,IACI,WAAW,CAAC,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,IAAG,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,KAAI,GAAG;AAEnE,SAAR,eAAiBC,SAAQ;AAC9B,MAAI,QAAQA,QAAO,aAAa,UAAaA,QAAO,cAAc,SAAY,mBAAW,oBAAY,IAAI,KAAKA,QAAO,UAAU,MAAM,GAAGA,QAAO,YAAY,EAAE,GACzJ,iBAAiBA,QAAO,aAAa,SAAY,KAAKA,QAAO,SAAS,CAAC,IAAI,IAC3E,iBAAiBA,QAAO,aAAa,SAAY,KAAKA,QAAO,SAAS,CAAC,IAAI,IAC3E,UAAUA,QAAO,YAAY,SAAY,MAAMA,QAAO,UAAU,IAChE,WAAWA,QAAO,aAAa,SAAY,mBAAW,uBAAe,IAAI,KAAKA,QAAO,UAAU,MAAM,CAAC,GACtG,UAAUA,QAAO,YAAY,SAAY,MAAMA,QAAO,UAAU,IAChE,QAAQA,QAAO,UAAU,SAAY,MAAMA,QAAO,QAAQ,IAC1D,MAAMA,QAAO,QAAQ,SAAY,QAAQA,QAAO,MAAM;AAE1D,WAAS,UAAU,WAAW;AAC5B,gBAAY,gBAAgB,SAAS;AAErC,QAAI,OAAO,UAAU,MACjB,QAAQ,UAAU,OAClB,OAAO,UAAU,MACjB,SAAS,UAAU,QACnB,OAAO,UAAU,MACjB,QAAQ,UAAU,OAClB,QAAQ,UAAU,OAClB,YAAY,UAAU,WACtB,OAAO,UAAU,MACjB,OAAO,UAAU;AAGrB,QAAI,SAAS,IAAK,SAAQ,MAAM,OAAO;AAAA,aAG9B,CAAC,oBAAY,IAAI,EAAG,eAAc,WAAc,YAAY,KAAK,OAAO,MAAM,OAAO;AAG9F,QAAI,QAAS,SAAS,OAAO,UAAU,IAAM,QAAO,MAAM,OAAO,KAAK,QAAQ;AAI9E,QAAI,SAAS,WAAW,MAAM,iBAAiB,WAAW,OAAO,SAAS,KAAK,IAAI,IAAI,MAAM,KAAK,YAAY,IAAI,IAC9G,SAAS,WAAW,MAAM,iBAAiB,OAAO,KAAK,IAAI,IAAI,UAAU;AAK7E,QAAI,aAAa,oBAAY,IAAI,GAC7B,cAAc,aAAa,KAAK,IAAI;AAMxC,gBAAY,cAAc,SAAY,IAChC,SAAS,KAAK,IAAI,IAAI,KAAK,IAAI,GAAG,KAAK,IAAI,IAAI,SAAS,CAAC,IACzD,KAAK,IAAI,GAAG,KAAK,IAAI,IAAI,SAAS,CAAC;AAEzC,aAASC,QAAO,OAAO;AACrB,UAAI,cAAc,QACd,cAAc,QACdC,IAAGC,IAAG;AAEV,UAAI,SAAS,KAAK;AAChB,sBAAc,WAAW,KAAK,IAAI;AAClC,gBAAQ;AAAA,MACV,OAAO;AACL,gBAAQ,CAAC;AAGT,YAAI,gBAAgB,QAAQ,KAAK,IAAI,QAAQ;AAG7C,gBAAQ,MAAM,KAAK,IAAI,MAAM,WAAW,KAAK,IAAI,KAAK,GAAG,SAAS;AAGlE,YAAI,KAAM,SAAQ,mBAAW,KAAK;AAGlC,YAAI,iBAAiB,CAAC,UAAU,KAAK,SAAS,IAAK,iBAAgB;AAGnE,uBAAe,gBAAiB,SAAS,MAAM,OAAO,QAAS,SAAS,OAAO,SAAS,MAAM,KAAK,QAAQ;AAC3G,uBAAe,SAAS,MAAM,SAAS,IAAI,iBAAiB,CAAC,IAAI,MAAM,eAAe,iBAAiB,SAAS,MAAM,MAAM;AAI5H,YAAI,aAAa;AACf,UAAAD,KAAI,IAAIC,KAAI,MAAM;AAClB,iBAAO,EAAED,KAAIC,IAAG;AACd,gBAAI,IAAI,MAAM,WAAWD,EAAC,GAAG,KAAK,KAAK,IAAI,IAAI;AAC7C,6BAAe,MAAM,KAAK,UAAU,MAAM,MAAMA,KAAI,CAAC,IAAI,MAAM,MAAMA,EAAC,KAAK;AAC3E,sBAAQ,MAAM,MAAM,GAAGA,EAAC;AACxB;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAGA,UAAI,SAAS,CAAC,KAAM,SAAQ,MAAM,OAAO,QAAQ;AAGjD,UAAI,SAAS,YAAY,SAAS,MAAM,SAAS,YAAY,QACzD,UAAU,SAAS,QAAQ,IAAI,MAAM,QAAQ,SAAS,CAAC,EAAE,KAAK,IAAI,IAAI;AAG1E,UAAI,SAAS,KAAM,SAAQ,MAAM,UAAU,OAAO,QAAQ,SAAS,QAAQ,YAAY,SAAS,QAAQ,GAAG,UAAU;AAGrH,cAAQ,OAAO;AAAA,QACb,KAAK;AAAK,kBAAQ,cAAc,QAAQ,cAAc;AAAS;AAAA,QAC/D,KAAK;AAAK,kBAAQ,cAAc,UAAU,QAAQ;AAAa;AAAA,QAC/D,KAAK;AAAK,kBAAQ,QAAQ,MAAM,GAAG,SAAS,QAAQ,UAAU,CAAC,IAAI,cAAc,QAAQ,cAAc,QAAQ,MAAM,MAAM;AAAG;AAAA,QAC9H;AAAS,kBAAQ,UAAU,cAAc,QAAQ;AAAa;AAAA,MAChE;AAEA,aAAO,SAAS,KAAK;AAAA,IACvB;AAEA,IAAAD,QAAO,WAAW,WAAW;AAC3B,aAAO,YAAY;AAAA,IACrB;AAEA,WAAOA;AAAA,EACT;AAEA,WAASG,cAAa,WAAW,OAAO;AACtC,QAAI,IAAI,WAAW,YAAY,gBAAgB,SAAS,GAAG,UAAU,OAAO,KAAK,UAAU,GACvFC,KAAI,KAAK,IAAI,IAAI,KAAK,IAAI,GAAG,KAAK,MAAM,iBAAS,KAAK,IAAI,CAAC,CAAC,CAAC,IAAI,GACjEC,KAAI,KAAK,IAAI,IAAI,CAACD,EAAC,GACnB,SAAS,SAAS,IAAIA,KAAI,CAAC;AAC/B,WAAO,SAASE,QAAO;AACrB,aAAO,EAAED,KAAIC,MAAK,IAAI;AAAA,IACxB;AAAA,EACF;AAEA,SAAO;AAAA,IACL,QAAQ;AAAA,IACR,cAAcH;AAAA,EAChB;AACF;;;ACjJA,IAAI;AACG,IAAI;AACJ,IAAI;AAEX,cAAc;AAAA,EACZ,SAAS;AAAA,EACT,WAAW;AAAA,EACX,UAAU,CAAC,CAAC;AAAA,EACZ,UAAU,CAAC,KAAK,EAAE;AAAA,EAClB,OAAO;AACT,CAAC;AAEc,SAAR,cAA+B,YAAY;AAChD,WAAS,eAAa,UAAU;AAChC,WAAS,OAAO;AAChB,iBAAe,OAAO;AACtB,SAAO;AACT;;;;;;;;;;;ICLaI,IAA6C,CACtD,SAAAC,IAAAA;AAAI,SAAIA,GAAKC,gBAAgB,CAAA;AAAE,GAC/B,SAAAD,IAAAA;AAAI,SAAIA,GAAKE,WAAW,CAAA;AAAE,GAC1B,SAAAF,IAAAA;AAAI,SAAIA,GAAKG,WAAW,CAAA;AAAE,GAC1B,SAAAH,IAAAA;AAAI,SAAIA,GAAKI,SAAS,CAAA;AAAE,GACxB,SAAAJ,IAAAA;AAAI,SAAIA,GAAKK,QAAQ,CAAA;AAAE,GACvB,SAAAL,IAAAA;AAAI,SAAIA,GAAKM,SAAS,CAAA;AAAE,CAAA;IAGfC,IAA2E,EACpFC,aAAa,CAAA,GACbC,QAAQV,EAAiBW,MAAM,GAAG,CAAA,GAClCC,QAAQZ,EAAiBW,MAAM,GAAG,CAAA,GAClCE,MAAMb,EAAiBW,MAAM,GAAG,CAAA,GAChCG,KAAKd,EAAiBW,MAAM,GAAG,CAAA,GAC/BI,OAAOf,EAAiBW,MAAM,GAAG,CAAA,GACjCK,MAAMhB,EAAiBW,MAAM,GAAG,CAAA,EAAA;IGbvBM,KAAgB,SAA4BC,IAAAA;AACrD,MAAMC,KAAaD;AAGnB,SAFAC,GAAWC,OAAO,QAEXD;AACX;AIoEA,ICxDaE,KAAc,SAAQC,IAAAA;AAC/B,MAAMC,KAAYD,GAAMC,UAAAA;AAExB,MAAkB,MAAdA,GAAiB,QAAOD;AAE5B,MAAIE,KAASD,KAAY;AAKzB,SAJID,GAAMG,MAAAA,MACND,KAASE,KAAKD,MAAMD,EAAAA,IAGjB,SAAkBG,IAAAA;AAAI,QAAAC;AAAA,YAAc,SAATA,KAACN,GAAMK,EAAAA,KAAEC,KAAI,KAAKJ;EAAM;AAC9D;AD6CA,IC7BMK,KAA6E,EAC/EC,aAAa,CAACC,qBAAiBC,mBAAAA,GAC/BC,QAAQ,CAACC,gBAAYC,cAAAA,GACrBC,QAAQ,CAACC,gBAAYC,iBAAAA,GACrBC,MAAM,CAACC,cAAUC,eAAAA,GACjBC,KAAK,CAnBOC,YACZ,SAAAC,IAAAA;AAAI,SAAIA,GAAKC,SAAS,GAAG,GAAG,GAAG,CAAA;AAAE,GACjC,SAACD,IAAME,IAAAA;AAAI,SAAKF,GAAKG,QAAQH,GAAKI,QAAAA,IAAYF,EAAAA;AAAK,GACnD,SAACG,IAAOC,IAAAA;AAAG,UAAMA,GAAIC,QAAAA,IAAYF,GAAME,QAAAA,KAAa;AAAK,GACzD,SAAAP,IAAAA;AAAI,SAAIlB,KAAK0B,MAAMR,GAAKO,QAAAA,IAAY,KAAA;AAAM,CAAA,GAG/BR,YACX,SAAAC,IAAAA;AAAI,SAAIA,GAAKS,YAAY,GAAG,GAAG,GAAG,CAAA;AAAE,GACpC,SAACT,IAAME,IAAAA;AAAI,SAAKF,GAAKU,WAAWV,GAAKW,WAAAA,IAAeT,EAAAA;AAAK,GACzD,SAACG,IAAOC,IAAAA;AAAG,UAAMA,GAAIC,QAAAA,IAAYF,GAAME,QAAAA,KAAa;AAAK,GACzD,SAAAP,IAAAA;AAAI,SAAIlB,KAAK0B,MAAMR,GAAKO,QAAAA,IAAY,KAAA;AAAM,CAAA,CAAA,GAS1CK,MAAM,CAACC,QAAUC,SAAAA,GACjBC,QAAQ,CAACC,QAAYC,SAAAA,GACrBC,QAAQ,CAACC,QAAYC,SAAAA,GACrBC,SAAS,CAACC,SAAaC,UAAAA,GACvBC,WAAW,CAACC,WAAeC,YAAAA,GAC3BC,UAAU,CAACC,UAAcC,WAAAA,GACzBC,QAAQ,CAACC,QAAYC,SAAAA,GACrBC,UAAU,CAACC,UAAcC,WAAAA,GACzBC,OAAO,CAACC,eAAWC,gBAAAA,GACnBC,MAAM,CAACC,cAAUC,eAAAA,EAAAA;ADcrB,ICXMC,MAAYC,OAAOC,KAAK3D,EAAAA;ADW9B,ICVM4D,KAAqB,IAAIC,OAAgCJ,2BAAAA,IAAUK,KAAK,GAAA,IAAI,QAAQ,GAAA;ADU1F,ICLaC,KAAgB,SACzBtE,IACAuE,IAAAA;AAGA,MAAIC,MAAMC,QAAQF,EAAAA,EACd,QAAOA;AAGX,MAAoB,YAAA,OAATA,MAAqB,YAAYvE,IAAO;AAE/C,QAAM0E,KAAUH,GAAKI,MAAMR,EAAAA;AAE3B,QAAIO,IAAS;AACT,UAASE,KAAgBF,GAAO,CAAA,GAAfG,KAAQH,GAAO,CAAA,GAI1BI,KAAWvE,GAAWsE,EAAAA,EAAM7E,GAAM+E,SAAS,IAAI,CAAA;AAErD,UAAa,UAATF,IAAgB;AAAA,YAAAG,IAAAC,GAChBC,IAA8BlF,GAAMmF,OAAAA,GAA7BxD,IAAKuD,EAAA,CAAA,GAAEE,IAAYF,EAAA,CAAA,GACpBG,IAAO,IAAIC,KAAKF,CAAAA;AAKtB,eAFAC,EAAK5D,QAAQ4D,EAAK3D,QAAAA,IAAY,CAAA,GAEgCsD,SAA9DA,KAA0C,SAA1CC,IAAOH,GAASS,MAAMC,OAAa,QAANZ,KAAAA,KAAU,CAAA,CAAA,KAAA,SAAhCK,EAAqCQ,MAAM9D,GAAO0D,CAAAA,KAAKL,KAAI,CAAA;MACtE;AAEA,UAAA,WAAIJ,GACA,QAAO5E,GAAM0F,MAAMZ,EAAAA;AAGvB,UAAMa,KAAWb,GAASS,MAAMC,OAAOZ,EAAAA,CAAAA;AAEvC,UAAIe,GACA,QAAO3F,GAAM0F,MAAMC,EAAAA;IAE3B;AAEA,UAAM,IAAIC,MAA6BrB,yBAAAA,EAAAA;EAC3C;AAGA,MAAI,WAAWvE,IAAO;AAElB,QAAA,WAAIuE,GACA,QAAOvE,GAAM0F,MAAAA;AAIjB,QAtDa,YAAA,QADFG,KAuDGtB,OAtDWuB,SAASD,EAAAA,KAAUzF,KAAK0B,MAAM+D,EAAAA,MAAWA,GAuD9D,QAAO7F,GAAM0F,MAAMnB,EAAAA;EAE3B;AA1Dc,MAACsB;AA6Df,SAAO7F,GAAMmF,OAAAA;AACjB;;;;;;;;;;;;;ACzIA,IAEaY,IAAwB,SAAHC,IAAAA;AAoB5B,MAUEC,IA7BJC,KAAIF,GAAJE,MACAC,KAAKH,GAALG,OACAC,KAAaJ,GAAbI,eACAC,KAAUL,GAAVK,YACAC,KAAQN,GAARM,UACAC,IAAWP,GAAXO,aACAC,IAAYR,GAAZQ,cACAC,IAAcT,GAAdS,gBAAcC,IAAAV,GACdW,QAAAA,IAAAA,WAAMD,IAAG,QAAKA,GAYRE,KAASC,GAAqBV,IAAOE,EAAAA,GAErCS,KAAYC,GAAkBJ,CAAAA,GAE9BK,KAAW,eAAeb,KAAQc,GAAYd,EAAAA,IAASA,IACvDe,KAAO,EAAEC,OAAO,GAAGC,OAAO,EAAA,GAC1BC,KAAO,EAAEC,OAAO,GAAGC,OAAO,EAAA,GAE1BC,KAA4B,YAAA,OAAbC,YAAyC,UAAjBA,SAASC,KAElDC,KAA6Bb,GAAUc,MAAMC,QAC7CC,KAAmChB,GAAUiB,SAASF;AAE7C,UAAT3B,MACAD,KAAY,SAAA+B,IAAAA;AAAC,QAAAC;AAAA,WAAK,EAAEC,GAAc,SAAbD,KAAEjB,GAASgB,EAAAA,KAAEC,KAAI,GAAGE,GAAG,EAAA;EAAA,GAE5CjB,GAAKE,QAAQd,MAA8B,YAAlBF,KAA4B,IAAA,KACrDiB,GAAKE,SAASjB,KAAWC,MAAkC,YAAlBH,KAA4B,IAAA,KAGjE0B,KADkB,YAAlB1B,KACeU,GAAUiB,SAASK,MAEnBtB,GAAUiB,SAASM,QAGjB,MAAjB7B,IACAmB,KAAYb,GAAUc,MAAMC,SAET,YAAlBzB,MAA6BI,IAAe,KAC1B,aAAlBJ,MAA8BI,IAAe,KAE9CmB,KAAYb,GAAUc,MAAMJ,KAAQ,SAAS,OAAA,GAC7CM,KAAehB,GAAUiB,SAASF,WAEf,YAAlBzB,MAA6BI,IAAe,KAC1B,aAAlBJ,MAA8BI,IAAe,OAE9CmB,KAAYb,GAAUc,MAAMJ,KAAQ,UAAU,MAAA,GAC9CM,KAAehB,GAAUiB,SAASF,YAGtC5B,KAAY,SAAA+B,IAAAA;AAAC,QAAAM;AAAA,WAAK,EAAEJ,GAAG,GAAGC,GAAcG,SAAbA,KAAEtB,GAASgB,EAAAA,KAAEM,KAAI,EAAA;EAAA,GAE5CpB,GAAKC,QAAQb,MAA8B,YAAlBF,KAA4B,IAAA,KACrDiB,GAAKC,SAAShB,KAAWC,MAAkC,YAAlBH,KAA4B,IAAA,KAGjEuB,KADkB,YAAlBvB,KACYU,GAAUc,MAAMW,OAEhBzB,GAAUc,MAAMY;AAyBpC,SAAO,EACHC,OAbU7B,GAAO8B,IAAI,SAACC,IAAAA;AACtB,QAAMC,KACe,YAAA,OAAVD,KAXM,SAACA,IAAAA;AAClB,UAAME,KAAcC,OAAOH,EAAAA,EAAOI;AAElC,aAAItC,KAAkBA,IAAiB,KAAKoC,KAAcpC,IACtD,KAAUqC,OAAOH,EAAAA,EAAOK,MAAM,GAAGvC,CAAAA,EAAgBwC,OAAO,KAAA,IAE5D,KAAUN;IAAAA,EAKoCA,EAAAA,IAA8BA;AAC5E,WAAAO,EAAA,EACIC,KAAKR,cAAiBS,OAAI,KAAMT,GAAMU,QAAAA,IAAS,KAAQV,IACvDA,OAAOC,GAAAA,GACJ3C,GAAU0C,EAAAA,GACVzB,IACAG,EAAAA;EAEX,CAAA,GAIIM,WAAAA,IACAG,cAAAA,GAAAA;AAER;AAtGA,IAwGawB,IAAe,SACxBC,IACApD,IAAAA;AAEA,MAAA,WAAWoD,MAA4C,cAAA,OAAXA,GAAuB,QAAOA;AAE1E,MAAmB,WAAfpD,GAAMqD,MAAiB;AACvB,QAAMC,KAAYC,WAAWH,EAAAA;AAE7B,WAAQ,SAACvB,IAAAA;AAAM,aAAKyB,GAAUzB,cAAaoB,OAAOpB,KAAI,IAAIoB,KAAKpB,EAAAA,CAAAA;IAAG;EACtE;AAEA,SAAO2B,OAASJ,EAAAA;AACpB;AArHA,IAuHaK,IAAmB,SAAHC,IAAAA;AAYvB,MAnIclB,IAwHhBmB,KAAKD,GAALC,OACAC,KAAMF,GAANE,QACA5D,KAAK0D,GAAL1D,OACAD,KAAI2D,GAAJ3D,MACQ8D,KAAOH,GAAfjD,QASMA,MArIU+B,KAoImBqB,IApIcC,MAAMC,QAAQvB,EAAAA,IAoIjBqB,KAAAA,WACjBnD,GAAqBV,IAAO6D,EAAAA,GACnDhD,IAAW,eAAeb,KAAQc,GAAYd,EAAAA,IAASA,IAEvDgE,IACO,QAATjE,KACMU,GAAO8B,IAAI,SAACC,IAAAA;AAAY,QAAAyB,IAAAC;AAAA,WAAM,EAC1BlB,KAAKR,cAAiBS,OAAI,KAAMT,GAAMU,QAAAA,IAAS,KAAQV,IACvD2B,IAAmB,SAAjBF,KAAEpD,EAAS2B,EAAAA,KAAMyB,KAAI,GACvBG,IAAmB,SAAjBF,KAAErD,EAAS2B,EAAAA,KAAM0B,KAAI,GACvBG,IAAI,GACJC,IAAIV,GAAAA;EACN,CAAA,IACFnD,GAAO8B,IAAI,SAACC,IAAAA;AAAY,QAAA+B,IAAAC;AAAA,WAAM,EAC1BxB,KAAKR,cAAiBS,OAAI,KAAMT,GAAMU,QAAAA,IAAS,KAAQV,IACvD2B,IAAI,GACJC,IAAIT,IACJU,IAAmB,SAAjBE,KAAE1D,EAAS2B,EAAAA,KAAM+B,KAAI,GACvBD,IAAmBE,SAAjBA,KAAE3D,EAAS2B,EAAAA,KAAMgC,KAAI,EAAA;EAC1B,CAAA;AAEX,SAAOR;AACX;AA1JA,ICyDMS,QAAmBC,aAAAA,MAzDR,SAAH7E,IAAAA;AASc,MAAA8E,IARjBC,KAAM/E,GAAb2C,OACAY,KAAMvD,GAANuD,QACApC,KAAKnB,GAALmB,OACAC,IAAKpB,GAALoB,OACA4D,IAAOhF,GAAPgF,SACAlD,IAAY9B,GAAZ8B,cACAmD,IAAUjF,GAAViF,YACAC,KAAalF,GAAbkF,eAEMC,KAAQC,GAAAA,GACRC,IAAYF,GAAMjF,KAAKuC,MAAMvB,MAC7BoE,IAAYH,GAAMjF,KAAKuC,MAAMpB,MAE7BsB,KAAwBmC,SAAnBA,KAAS,QAANvB,KAAAA,SAAAA,GAASwB,EAAAA,KAAOD,KAAIC,IAE5BQ,SAAQC,aAAAA,SAAQ,WAAA;AAClB,QAAMC,KAAQ,EAAEC,SAASR,GAAcQ,QAAAA;AAEvC,WAAKV,IAIE,EACHS,OAAKvC,EAAA,CAAA,GAAOuC,IAAK,EAAEE,QAAQ,UAAA,CAAA,GAC3BX,SAAS,SAACY,IAAAA;AAAgD,aAAKZ,EAAQY,IAAOjD,EAAAA;IAAM,EAAA,IAL7E,EAAE8C,OAAAA,GAAAA;EAOhB,GAAE,CAACP,GAAcQ,SAASV,GAASrC,EAAAA,CAAAA;AAEpC,aACIkD,mBAAAA,MAACC,SAASC,GAAC7C,EAAA,EAAC8C,WAAWd,GAAcc,UAAAA,GAAeT,IAAK,EAAAU,UAAAA,KACrDC,mBAAAA,KAAA,QAAA,EAAM5B,IAAI,GAAGC,IAAIpD,IAAOqD,IAAI,GAAGC,IAAIrD,GAAOqE,OAAOJ,EAAAA,CAAAA,GAChDC,EAAUa,eAAe,SACtBD,mBAAAA,KAACJ,SAASzE,MAAI,EACV+E,kBAAkBtE,GAClBmD,YAAYA,GACZe,WAAWd,GAAcmB,eACzBZ,OAAOH,GACPgB,aAAsC,IAAzBhB,EAAUa,cACvBI,QAAQjB,EAAUkB,cAClBC,gBAAe,SAAOR,UAElBtD,KAAAA,GAAAA,CAAAA,OAGZuD,mBAAAA,KAACJ,SAASzE,MAAI,EACV+E,kBAAkBtE,GAClBmD,YAAYA,GACZe,WAAWd,GAAcmB,eACzBZ,OAAOiB,GAAqBpB,CAAAA,GAAWW,UAEnCtD,KAAAA,GAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA;AAIpB,CAAA;ADvDA,IEEagE,IAAkB,SAAH3G,IAAAA;AA0BtB,MAzBFE,KAAIF,GAAJE,MACAC,KAAKH,GAALG,OAAKyG,KAAA5G,GACLkC,GAAAA,IAAAA,WAAC0E,KAAG,IAACA,IAAAC,KAAA7G,GACLmC,GAAAA,KAAAA,WAAC0E,KAAG,IAACA,IACL9D,IAAM/C,GAAN+C,QACA3C,IAAaJ,GAAbI,eACAC,KAAUL,GAAVK,YAAUyG,KAAA9G,GACVM,UAAAA,KAAAA,WAAQwG,KAAG,IAACA,IAAAC,KAAA/G,GACZO,aAAAA,KAAAA,WAAWwG,KAAG,IAACA,IAAAC,KAAAhH,GACfQ,cAAAA,KAAAA,WAAYwG,KAAG,IAACA,IAChBzD,KAAMvD,GAANuD,QAAM0D,KAAAjH,GACNkH,YAAAA,KAAAA,WAAUD,KAAGE,IAAQF,IACrBxG,KAAcT,GAAdS,gBACA2G,KAAMpH,GAANoH,QAAMC,KAAArH,GACNsH,gBAAAA,KAAAA,WAAcD,KAAG,QAAKA,IAAAE,KAAAvH,GACtBwH,cAAAA,KAAAA,WAAYD,KAAG,IAACA,IAChBvC,IAAOhF,GAAPgF,SACAyC,KAAUzH,GAAVyH,YASMtC,KAAQC,GAAAA,GACRsC,KAAkBvC,GAAMjF,KAAKkH,OAAO/F,MAEpCsG,SAAcnC,aAAAA,SAAQ,WAAA;AAAA,WAAMlC,EAAaC,IAAQpD,EAAAA;EAAM,GAAE,CAACoD,IAAQpD,EAAAA,CAAAA,GAExEyH,KAA2C7H,EAAsB,EAC7DG,MAAAA,IACAC,OAAAA,IACAC,eAAAA,GACAC,YAAAA,IACAC,UAAAA,IACAC,aAAAA,IACAC,cAAAA,IACAC,gBAAAA,GAAAA,CAAAA,GARIgC,KAAKmF,GAALnF,OAAOd,KAASiG,GAATjG,WAAWG,KAAY8F,GAAZ9F,cAWtB+F,KAAa;AACjB,MAAA,WAAIT,IAAsB;AACtB,QAGInC,IAHA6C,KAAU,GACVC,KAAU,GACVC,KAAiB;AAGR,YAAT9H,MACA8H,KAAAA,KACAF,KAAUN,IACa,YAAnBF,MACArC,KAAa,SACb8C,KAAUhF,KACgB,aAAnBuE,MACPrC,KAAa,UACb8C,KAAUhF,IAAS,KACO,UAAnBuE,OACPrC,KAAa,WAGjB8C,KAAUP,IACa,YAAnBF,KACArC,KAAa,UACa,aAAnBqC,MACPrC,KAAa,UACb6C,KAAU/E,IAAS,KACO,UAAnBuE,OACPrC,KAAa,OACb6C,KAAU/E,KAIlB8E,SACIhC,mBAAAA,MAAAoC,mBAAAA,UAAA,EAAAhC,UAAAA,CACKyB,GAAgBvB,eAAe,SAC5BD,mBAAAA,KAAA,QAAA,EACIF,WAAAA,eAAwB8B,KAAO,OAAKC,KAAO,cAAYC,KAAkB,KACzE/C,YAAYA,IACZQ,OAAKvC,EAAA,EACDkD,kBAAkB,UAAA,GACfsB,EAAAA,GAEPpB,aAA4C,IAA/BoB,GAAgBvB,cAC7BI,QAAQmB,GAAgBlB,cACxBC,gBAAe,SAAOR,UAErBmB,GAAAA,CAAAA,OAGTlB,mBAAAA,KAAA,QAAA,EACIF,WAAAA,eAAwB8B,KAAO,OAAKC,KAAO,cAAYC,KAAkB,KACzE/C,YAAYA,IACZQ,OAAKvC,EAAA,EACDkD,kBAAkB,UAAA,GACfsB,EAAAA,GACLzB,UAEDmB,GAAAA,CAAAA,CAAAA,EAAAA,CAAAA;EAIjB;AAEA,MAAAc,KAA0CC,GAAAA,GAAlCC,KAAOF,GAAPE,SAAiBC,KAAYH,GAApBI,QAEXpD,KAAgBqD,UAAU,EAC5BvC,WAAwB9D,eAAAA,IAAKC,MAAAA,KAAI,KACjCqG,QAAiB,QAATtI,KAAe6C,IAAS,GAChC0F,QAAiB,QAATvI,KAAe,IAAI6C,GAC3BuF,QAAQD,IACRK,WAAAA,CAAYN,GAAAA,CAAAA,GAGVO,SAAmBC,aAAAA,aACrB,SAACC,IAAAA;AACG,WAAO,EACHnD,SAAS,GACTM,WAAS,eAAe6C,GAAK3G,IAAAA,MAAK2G,GAAK1G,IAAI,KAC3CkE,eAAa,eAAewC,GAAKvH,QAAAA,MAASuH,GAAKtH,QAAK,cAAYf,KAAY,IAAA;EAEpF,GACA,CAACA,EAAAA,CAAAA,GAECsI,SAAuBF,aAAAA,aACzB,SAACC,IAAAA;AAAuB,WAAM,EAC1BnD,SAAS,GACTM,WAAS,eAAe6C,GAAK3G,IAAAA,MAAK2G,GAAK1G,IAAI,KAC3CkE,eAAa,eAAewC,GAAKvH,QAAAA,MAASuH,GAAKtH,QAAK,cAAYf,KAAY,IAAA;EAC/E,GACD,CAACA,EAAAA,CAAAA,GAGCuI,KAAaC,cAGjBvG,IAAO,EACLwG,MAAM,SAAAJ,IAAAA;AAAI,WAAIA,GAAK1F;EAAG,GACtB+F,SAASP,IACTQ,MAAML,IACNM,OAAOT,IACPU,QAAQV,IACRW,OAAO,EACH5D,SAAS,EAAA,GAEb4C,QAAQD,IACRK,WAAAA,CAAYN,GAAAA,CAAAA;AAGhB,aACIvC,mBAAAA,MAACC,SAASC,GAAC,EAACC,WAAWd,GAAcc,WAAW,eAAayB,IAAWxB,UAAA,CACnE8C,GAAW,SAACQ,IAAiBV,IAAMW,IAAQC,IAAAA;AACxC,WAAaC,iBAAcxC,IAAUhE,EAAA,EACjCuG,WAAAA,IACAlG,QAAQoE,IACRgC,QAAQnJ,IACRsB,cAAAA,IACAmD,YAAYtD,IACZlB,gBAAgBA,IAChByE,eAAeqE,GAAAA,GACZV,IACC7D,IAAU,EAAEA,SAAAA,EAAAA,IAAY,CAAA,CAAA,CAAA;EAEpC,CAAA,OACAkB,mBAAAA,KAACJ,SAAS5E,MAAI,EACVuE,OAAON,GAAMjF,KAAK0J,OAAO1I,MACzBoD,IAAI,GACJC,IAAIW,GAAcsD,QAClBhE,IAAI,GACJC,IAAIS,GAAcuD,OAAAA,CAAAA,GAErBZ,EAAAA,EAAAA,CAAAA;AAGb;AFlLA,IEoLagC,QAAOhF,aAAAA,MAAK8B,CAAAA;AFpLzB,IGPamD,KAAY,CAAC,OAAO,SAAS,UAAU,MAAA;AHOpD,IIDaC,QAAOlF,aAAAA,MAChB,SAAA7E,IAAAA;AAkBM,MAjBFgK,KAAMhK,GAANgK,QACAC,KAAMjK,GAANiK,QACAnG,KAAK9D,GAAL8D,OACAC,KAAM/D,GAAN+D,QAeMmG,KAAO,EAAE9H,KAdZpC,GAAHoC,KAcoBI,OAbfxC,GAALwC,OAa2BH,QAZrBrC,GAANqC,QAYmCE,MAX/BvC,GAAJuC,KAAAA;AAaA,aACI2D,mBAAAA,KAAA+B,mBAAAA,UAAA,EAAAhC,UACK6D,GAAUpH,IAAI,SAAA1B,IAAAA;AACX,QAAMd,KAAOgK,GAAKlJ,EAAAA;AAIlB,QAAA,CAAKd,GAAM,QAAO;AAElB,QAAMiK,KAAuB,UAAbnJ,MAAmC,aAAbA;AAItC,eACIkF,mBAAAA,KAAC2D,GAAI3G,EAAAA,CAAAA,GAEGhD,IAAI,EACRA,MAAMiK,KAAU,MAAM,KACtBjI,GAAgB,YAAblB,KAAuB8C,KAAQ,GAClC3B,GAAgB,aAAbnB,KAAwB+C,KAAS,GACpC5D,OAAOgK,KAAUH,KAASC,IAC1BlH,QAAQoH,KAAUrG,KAAQC,IAC1B3D,eAXS,UAAbY,MAAmC,WAAbA,KAAsB,WAAW,SAYnDP,gBAAgBP,GAAKO,eAAAA,CAAAA,GARhBO,EAAAA;EAAAA,CAAAA,EAAAA,CAAAA;AAc7B,CAAA;AJlDJ,IKHaoJ,QAAWvF,aAAAA,MACpB,SAAA7E,IAAAA;AAUM,MATFkF,KAAalF,GAAbkF,eAUMC,KAAQC,GAAAA;AAEd,aACIc,mBAAAA,KAACJ,SAAS5E,MAAIgC,EAAA,CAAA,GACNgC,IACCC,GAAMkF,KAAKnJ,IAAAA,CAAAA;AAG5B,CAAA;ALjBJ,IMDaoJ,QAAYzF,aAAAA,MAAK,SAAA7E,IAAAA;AAAkC,MAA/BmE,KAAKnE,GAALmE,OAC7B+D,KAA0CC,GAAAA,GAAlCC,KAAOF,GAAPE,SAAiBC,KAAYH,GAApBI,QAEXS,KAAaC,cACf7E,IACA,EACI8E,MAAM,SAAA/H,IAAAA;AAAI,WAAIA,GAAKiC;EAAG,GACtB+F,SAAS,SAAAhI,IAAAA;AAAI,WAAK,EACdwE,SAAS,GACTpB,IAAIpD,GAAKoD,IACTC,IAAIrD,GAAKqD,IACTC,IAAItD,GAAKsD,IACTC,IAAIvD,GAAKuD,GAAAA;EACX,GACF0E,MAAM,SAAAjI,IAAAA;AAAI,WAAK,EACXwE,SAAS,GACTpB,IAAIpD,GAAKoD,IACTC,IAAIrD,GAAKqD,IACTC,IAAItD,GAAKsD,IACTC,IAAIvD,GAAKuD,GAAAA;EACX,GACF2E,OAAO,SAAAlI,IAAAA;AAAI,WAAK,EACZwE,SAAS,GACTpB,IAAIpD,GAAKoD,IACTC,IAAIrD,GAAKqD,IACTC,IAAItD,GAAKsD,IACTC,IAAIvD,GAAKuD,GAAAA;EACX,GACF4E,QAAQ,SAAAnI,IAAAA;AAAI,WAAK,EACbwE,SAAS,GACTpB,IAAIpD,GAAKoD,IACTC,IAAIrD,GAAKqD,IACTC,IAAItD,GAAKsD,IACTC,IAAIvD,GAAKuD,GAAAA;EACX,GACF6E,OAAO,EACH5D,SAAS,EAAA,GAEb4C,QAAQD,IACRK,WAAAA,CAAYN,GAAAA,CAAAA;AAIpB,aACIlC,mBAAAA,KAAA,KAAA,EAAAD,UACK8C,GAAW,SAAC7D,IAAehE,IAAAA;AAAI,eAC5BqJ,aAAAA,eAACH,GAAQlH,EAAAA,CAAAA,GAAKhC,IAAI,EAAEiC,KAAKjC,GAAKiC,KAAK+B,eAAeA,GAAAA,CAAAA,CAAAA;EAAAA,CAAAA,EAAAA,CAAAA;AAIlE,CAAA;ANjDA,IOFasF,SAAO3F,aAAAA,MAChB,SAAA7E,IAAAA;AAcM,MAbF8D,KAAK9D,GAAL8D,OACAC,KAAM/D,GAAN+D,QACAiG,KAAMhK,GAANgK,QACAC,KAAMjK,GAANiK,QACAQ,KAAOzK,GAAPyK,SACAC,KAAO1K,GAAP0K,SASMC,QAASnF,aAAAA,SAAQ,WAAA;AACnB,WAAA,CAAA,CAAKwE,MAEEpG,EAAiB,EACpBE,OAAAA,IACAC,QAAAA,IACA5D,OAAO6J,IACP9J,MAAM,KACNU,QAAQ6J,GAAAA,CAAAA;EAEf,GAAE,CAACT,IAAQS,IAAS3G,IAAOC,EAAAA,CAAAA,GAEtB6G,QAASpF,aAAAA,SAAQ,WAAA;AACnB,WAAA,CAAA,CAAKyE,MAEErG,EAAiB,EACpBE,OAAAA,IACAC,QAAAA,IACA5D,OAAO8J,IACP/J,MAAM,KACNU,QAAQ8J,GAAAA,CAAAA;EAEf,GAAE,CAAC3G,IAAQD,IAAOmG,IAAQS,EAAAA,CAAAA;AAE3B,aACI7E,mBAAAA,MAAAoC,mBAAAA,UAAA,EAAAhC,UACK0E,CAAAA,SAAUzE,mBAAAA,KAACoE,GAAS,EAACnG,OAAOwG,EAAAA,CAAAA,GAC5BC,SAAU1E,mBAAAA,KAACoE,GAAS,EAACnG,OAAOyG,EAAAA,CAAAA,CAAAA,EAAAA,CAAAA;AAGzC,CAAA;AP5CJ,IQDaC,IAAqB,SAC9BC,IAA6B9K,IAAAA;AAqC5B,MAAA+K,IAnCG7K,KAAIF,GAAJE,MACAC,KAAKH,GAALG,OAAKyG,KAAA5G,GACLkC,GAAAA,KAAAA,WAAC0E,KAAG,IAACA,IAAAC,KAAA7G,GACLmC,GAAAA,IAAAA,WAAC0E,KAAG,IAACA,IACL9D,IAAM/C,GAAN+C,QAEA3C,IAAaJ,GAAbI,eACAC,IAAUL,GAAVK,YAAUyG,KAAA9G,GACVM,UAAAA,KAAAA,WAAQwG,KAAG,IAACA,IAAAC,IAAA/G,GACZO,aAAAA,IAAAA,WAAWwG,IAAG,IAACA,GAAAC,KAAAhH,GACfQ,cAAAA,KAAAA,WAAYwG,KAAG,IAACA,IACRlC,KAAO9E,GAAfuD,QAEA6D,KAAMpH,GAANoH,QAAMC,KAAArH,GACNsH,gBAAAA,KAAAA,WAAcD,KAAG,QAAKA,IAAAE,KAAAvH,GACtBwH,cAAAA,KAAAA,WAAYD,KAAG,IAACA,IAEhBpC,KAAKnF,GAALmF,OAmBJyC,KAA2C7H,EAAsB,EAC7DG,MAAAA,IACAC,OAAAA,IACAC,eAAAA,GACAC,YAAAA,GACAC,UAAAA,IACAC,aAAAA,GACAC,cAAAA,IACAG,QAAQ,SAAA,CAAA,GARJ8B,KAAKmF,GAALnF,OAAOd,KAASiG,GAATjG,WAAWG,KAAY8F,GAAZ9F;AAW1BgJ,EAAAA,GAAIE,KAAAA,GACJF,GAAI7K,UAAUiC,IAAGC,CAAAA,GAEjB2I,GAAInJ,YAAYA,IAChBmJ,GAAIhJ,eAAeA;AAEnB,MAAMwD,KAAYH,GAAMjF,KAAKuC,MAAMpB;AACnCyJ,EAAAA,GAAIG,QAAU3F,GAAU4F,aAAgB5F,GAAU4F,aAAgB,MAAA,MAAK5F,GAAU6F,WAC7E7F,QAAAA,GAAU8F,aAGyBL,SAAnCA,KAAC5F,GAAMjF,KAAK0J,OAAO1I,KAAKoF,eAAWyE,KAAI,KAAK,MAC5CD,GAAIO,YAAYC,OAAOnG,GAAMjF,KAAK0J,OAAO1I,KAAKoF,WAAAA,GAC9CwE,GAAIS,UAAU,UAEVpG,GAAMjF,KAAK0J,OAAO1I,KAAKqF,WACvBuE,GAAIU,cAAcrG,GAAMjF,KAAK0J,OAAO1I,KAAKqF,SAG7CuE,GAAIW,UAAAA,GACJX,GAAIY,OAAO,GAAG,CAAA,GACdZ,GAAIa,OAAgB,QAATzL,KAAe6C,IAAS,GAAY,QAAT7C,KAAe,IAAI6C,CAAAA,GACzD+H,GAAIvE,OAAAA;AAGR,MAAMhD,KAA4B,cAAA,OAAZuB,KAAyBA,KAAU,SAACnC,IAAAA;AAAc,WAAA,KAAQA;EAAAA;AAsChF,MApCAF,GAAMmJ,QAAQ,SAAA/C,IAAAA;AAAQ,QAAAgD;AAAAA,KACoBA,SAAlCA,KAAC1G,GAAMjF,KAAKuC,MAAMvB,KAAKoF,eAAWuF,KAAI,KAAK,MAC3Cf,GAAIO,YAAYC,OAAOnG,GAAMjF,KAAKuC,MAAMvB,KAAKoF,WAAAA,GAC7CwE,GAAIS,UAAU,UAEVpG,GAAMjF,KAAKuC,MAAMvB,KAAKqF,WACtBuE,GAAIU,cAAcrG,GAAMjF,KAAKuC,MAAMvB,KAAKqF,SAG5CuE,GAAIW,UAAAA,GACJX,GAAIY,OAAO7C,GAAK3G,GAAG2G,GAAK1G,CAAAA,GACxB2I,GAAIa,OAAO9C,GAAK3G,IAAI2G,GAAK1H,OAAO0H,GAAK1G,IAAI0G,GAAKzH,KAAAA,GAC9C0J,GAAIvE,OAAAA;AAGR,QAAM5D,KAAQY,GAAOsF,GAAKlG,KAAAA;AAE1BmI,IAAAA,GAAIE,KAAAA,GACJF,GAAI7K,UAAU4I,GAAK3G,IAAI2G,GAAKvH,OAAOuH,GAAK1G,IAAI0G,GAAKtH,KAAAA,GACjDuJ,GAAInB,OAAOmC,GAAiBtL,EAAAA,CAAAA,GAExB8E,GAAUa,eAAe,MACzB2E,GAAIU,cAAclG,GAAUkB,cAC5BsE,GAAIO,YAAqC,IAAzB/F,GAAUa,cAC1B2E,GAAIiB,WAAW,SACfjB,GAAIkB,WAAcrJ,KAAAA,IAAS,GAAG,CAAA,IAG9BwC,GAAMjF,KAAKuC,MAAMpB,KAAK4K,SACtBnB,GAAIoB,YAAY5G,GAAU2G,OAG9BnB,GAAIqB,SAAYxJ,KAAAA,IAAS,GAAG,CAAA,GAC5BmI,GAAIsB,QAAAA;EACR,CAAA,GAAA,WAEIhF,IAAsB;AACtB,QAAIU,KAAU,GACVC,KAAU,GACVC,KAAiB,GACjBrG,KAA6B;AAEpB,YAATzB,MACA8H,KAAAA,KACAF,KAAUN,IACa,YAAnBF,MACA3F,KAAY,SACZoG,KAAUhF,KACgB,aAAnBuE,MACP3F,KAAY,UACZoG,KAAUhF,IAAS,KACO,UAAnBuE,OACP3F,KAAY,WAGhBoG,KAAUP,IACa,YAAnBF,KACA3F,KAAY,UACc,aAAnB2F,MACP3F,KAAY,UACZmG,KAAU/E,IAAS,KACO,UAAnBuE,OACP3F,KAAY,OACZmG,KAAU/E,KAIlB+H,GAAI7K,UAAU6H,IAASC,EAAAA,GACvB+C,GAAInB,OAAOmC,GAAiB9D,EAAAA,CAAAA,GAC5B8C,GAAIG,QACA9F,GAAMjF,KAAKkH,OAAO/F,KAAK6J,aAAgB/F,GAAMjF,KAAKkH,OAAO/F,KAAK6J,aAAgB,MAAA,MAC/E/F,GAAMjF,KAAKkH,OAAO/F,KAAK8J,WAAchG,QAAAA,GAAMjF,KAAKkH,OAAO/F,KAAK+J,YAE3DjG,GAAMjF,KAAKkH,OAAO/F,KAAK4K,SACvBnB,GAAIoB,YAAY/G,GAAMjF,KAAKkH,OAAO/F,KAAK4K,OAG3CnB,GAAInJ,YAAYA,IAChBmJ,GAAIhJ,eAAe,UACnBgJ,GAAIqB,SAAS/E,IAAQ,GAAG,CAAA;EAC5B;AAEA0D,EAAAA,GAAIsB,QAAAA;AACR;AR/JA,IQiKaC,IAAqB,SAC9BvB,IAA6BjH,IAAAA;AAwB5B,MAtBGmG,KAAMnG,GAANmG,QACAC,KAAMpG,GAANoG,QACAnG,KAAKD,GAALC,OACAC,KAAMF,GAANE,QAEA3B,KAAGyB,GAAHzB,KACAI,KAAKqB,GAALrB,OACAH,IAAMwB,GAANxB,QACAE,IAAIsB,GAAJtB,MAEA4C,IAAKtB,GAALsB,OAaE+E,IAAO,EAAE9H,KAAAA,IAAKI,OAAAA,IAAOH,QAAAA,GAAQE,MAAAA,EAAAA;AAEnCuH,EAAAA,GAAU8B,QAAQ,SAAA5K,IAAAA;AACd,QAAMd,KAAOgK,EAAKlJ,EAAAA;AAIlB,QAAA,CAAKd,GAAM,QAAO;AAElB,QAAMiK,KAAuB,UAAbnJ,MAAmC,aAAbA,IAChCZ,KAA6B,UAAbY,MAAmC,WAAbA,KAAsB,WAAW,SACvEb,KAAQgK,KAAUH,KAASC,IAC3B1G,IAASD,EAAapD,GAAKqD,QAAQpD,EAAAA;AAEzC0K,MAAmBC,IAAG5H,EAAAA,CAAAA,GACfhD,IAAI,EACPA,MAAMiK,KAAU,MAAM,KACtBjI,GAAgB,YAAblB,KAAuB8C,KAAQ,GAClC3B,GAAgB,aAAbnB,KAAwB+C,KAAS,GACpC5D,OAAAA,IACAoD,QAAAA,GACAR,QAAQoH,KAAUrG,KAAQC,IAC1B3D,eAAAA,IACA+E,OAAAA,EAAAA,CAAAA,CAAAA;EAER,CAAA;AACJ;ARrNA,IQuNamH,IAA0B,SACnCxB,IAA6ByB,IAAAA;AAc5B,MAZGzI,KAAKyI,GAALzI,OACAC,KAAMwI,GAANxI,QACA5D,KAAKoM,GAALpM,OACAD,KAAIqM,GAAJrM,MACAU,KAAM2L,GAAN3L;AASUgD,IAAiB,EAAEE,OAAAA,IAAOC,QAAAA,IAAQ5D,OAAAA,IAAOD,MAAAA,IAAMU,QAAAA,GAAAA,CAAAA,EAEvDgL,QAAQ,SAAA1K,IAAAA;AACV4J,IAAAA,GAAIW,UAAAA,GACJX,GAAIY,OAAOxK,GAAKoD,IAAIpD,GAAKsD,EAAAA,GACzBsG,GAAIa,OAAOzK,GAAKqD,IAAIrD,GAAKuD,EAAAA,GACzBqG,GAAIvE,OAAAA;EACR,CAAA;AACJ;;;;;;;;;;;;;;;;;ACtPO,IAAMiG,KAAe,EACxBC,SAAS,GACTC,WAAW,KACXC,gBAAgB,GAChBC,SAAAA,KAAS;AAJN,ICWMC,KAAY,SAAQC,IAAAA;AAC7B,MAAMC,KAAAA,OAAkBD;AAExB,aACIE,cAAAA,gBAAeF,EAAAA,KACF,aAAbC,MACa,eAAbA,MACa,aAAbA;AAER;ADpBO,ICsBME,KAAe,SAAQH,IAAAA;AAChC,MAAMC,KAAAA,OAAkBD;AAExB,SAAoB,aAAbC,MAAsC,eAAbA;AACpC;AD1BO,IC4BMG,KAAqB,SAC9BC,IAAAA;AAAqC,SACmC,aAAxBA,GAAeC;AAAiB;AD9B7E,ICgCMC,KAAkB,SAC3BF,IAAAA;AAAqC,SACgC,UAAxBA,GAAeC;AAAc;ADlCvE,ICoCME,KAAmB,SAC5BH,IAAAA;AAAqC,SACiC,WAAxBA,GAAeC;AAAe;ADtCzE,IEmBMG,KAAkB,SAAHC,IAAAA;AAAA,MAMxBC,KAAID,GAAJC,MACAC,KAAWF,GAAXE,aACAC,KAAWH,GAAXG,aACAC,KAAaJ,GAAbI;AAAa,SAObF,GAAYG,OAAO,SAACC,IAA+BC,IAAAA;AAC/C,QAAMC,IAASD,GAAWC,UAAU;AAEpC,WAAA,CAAA,EAAAC,OACOH,QACAI,cAAAA,SAAcT,IAAMM,GAAWI,KAAAA,EAAOC,IAAI,SAAAC,IAAAA;AACzC,UAAMC,KAAWX,GAAYU,EAAAA,GACvBE,KAAaX,GAAcS,EAAAA;AAyBjC,cAvBInB,GAAmBa,EAAAA,KAAeT,GAAiBS,EAAAA,OACnDQ,GAAWC,OAAOD,GAAWC,OAAgB,IAATR,GACpCO,GAAWE,QAAQF,GAAWE,QAAiB,IAATT,GACtCO,GAAWG,SAASH,GAAWG,SAAkB,IAATV,IAoB5CW,GAAA,CAAA,OACOC,YAAAA,SAAKb,IAAY,CAAC,SAAS,QAAA,CAAA,GAC3BO,IACAC,IAAU,EACbC,MAAMT,GAAWS,QAAQD,GAAWC,MACpCH,OAAAA,GAAAA,CAAAA;IAEP,CAAA,CAAA;EAIR,GAAE,CAAA,CAAA;AAAG;AF9EH,IEgFMQ,KAAe,SACxBC,IACAC,IACAC,IACAC,IAAAA;AAEA,MAAMC,KAAQC,KAAKC,MAAMH,KAAUF,IAASC,KAAUF,EAAAA;AAEtD,SAAOO,GAAqBC,GAAiBJ,EAAAA,CAAAA;AACjD;AFzFO,IE2FMK,KAAoB,SAC7BxB,IAAAA;AAEA,MASIyB,IACAC,IATAC,KAMA3B,GANA2B,GACAC,KAKA5B,GALA4B,GACAC,KAIA7B,GAJA6B,OACAC,IAGA9B,GAHA8B,OAAKC,IAGL/B,GAFArB,WAAAA,IAAAA,WAASoD,IAAGtD,GAAaE,YAASoD,GAAAC,IAElChC,GADApB,gBAAAA,IAAAA,WAAcoD,IAAGvD,GAAaG,iBAAcoD;AAMhD,UAAIC,gBAAAA,SAASJ,EAAAA,EACTJ,CAAAA,KAAgBE,KAAIE;OACjB;AAAA,QAAA,WAAIA,GAAMK,IAGb,OAAM,IAAIC,MAAK,2EAAA;AAFfV,IAAAA,KAAgBI,GAAMK;EAG1B;AAEA,UAAID,gBAAAA,SAASH,CAAAA,EACTJ,CAAAA,KAAgBE,KAAIE;OACjB;AAAA,QAAA,WAAIA,EAAMI,IAGb,OAAM,IAAIC,MAAK,2EAAA;AAFfT,IAAAA,KAAgBI,EAAMI;EAG1B;AAEA,MAAIE,IAAYT,IACZU,KAAYT,IAEVT,KAAQL,GAAaa,IAAGC,IAAGH,IAAeC,EAAAA;AAEhD,MAAIvC,GAA0Ba,EAAAA,GAAa;AACvC,QAAMO,KAAW+B,GAAkBC,GAAiBpB,EAAAA,GAAQnB,GAAWS,OAAO,CAAA;AAC9E2B,SAAa7B,GAASoB,GACtBU,MAAa9B,GAASqB;EAC1B;AAEA,MAAIrC,GAAwBS,EAAAA,GAAa;AACrC,QAAMwC,KAASpB,KAAKqB,OAAOtB,KAAQ,MAAM,EAAA,IAAM;AAChC,UAAXqB,OACAH,MAAarC,GAAWW,SAAS,IAEtB,MAAX6B,OACAJ,KAAapC,GAAWU,QAAQ,GAChC2B,MAAarC,GAAWW,SAAS,IAEtB,MAAX6B,OACAJ,KAAapC,GAAWU,QAAQ,IAErB,MAAX8B,OACAJ,KAAapC,GAAWU,QAAQ,GAChC2B,MAAarC,GAAWW,SAAS,IAEtB,MAAX6B,OACAH,MAAarC,GAAWW,SAAS,IAEtB,MAAX6B,OACAJ,KAAapC,GAAWU,QAAQ,GAChC2B,MAAarC,GAAWW,SAAS,IAEtB,MAAX6B,OACAJ,KAAapC,GAAWU,QAAQ,IAErB,MAAX8B,OACAJ,KAAapC,GAAWU,QAAQ,GAChC2B,MAAarC,GAAWW,SAAS;EAEzC;AAEA,MAAI+B,KAAQjB,IAGRkB,KAAYlB;AAUhB,UAPKN,KAAQ,MAAM,MAAM,OACrBuB,MAAS/D,GACTgE,MAAahE,KAEbgE,MAAahE,GAGV,EACHiE,QAAQ,CACJ,CAACR,GAAWC,EAAAA,GACZ,CAACZ,IAAeC,EAAAA,GAChB,CAACiB,IAbSjB,EAAAA,CAAAA,GAedmB,MAAM,CAACH,IAlBGhB,KAAgB9C,CAAAA,GAmB1BuC,OAAOA,KAAQ,GAAA;AAEvB;AF3LO,IGYM2B,KAAiB,SAAHrD,IAAAA;AAAA,MACvBC,KAAID,GAAJC,MACAC,KAAWF,GAAXE,aACAC,KAAWH,GAAXG,aACAC,KAAaJ,GAAbI;AAAa,aAObkD,cAAAA,SACI,WAAA;AAAA,WACIvD,GAAuB,EACnBE,MAAAA,IACAC,aAAAA,IACAC,aAAAA,IACAC,eAAAA,GAAAA,CAAAA;EAER,GAAA,CAACH,IAAMC,IAAaC,IAAaC,EAAAA,CAAAA;AACpC;AHhCE,IGkCMmD,KAAyB,SAAHC,IAAAA;AAAA,MAC/BtD,KAAWsD,GAAXtD;AAAW,aAIXoD,cAAAA,SACI,WAAA;AAAA,WACIpD,GAAYU,IAAI,SAAAL,IAAAA;AAAU,aAAAY,GAAAA,CAAAA,GACnBZ,IAAU,EACbkD,UAAU1B,GAAiBZ,GAAA,CAAA,GACpBZ,EAAAA,CAAAA,EAAAA,CAAAA;IACL,CAAA;EAAA,GAEV,CAACL,EAAAA,CAAAA;AACJ;AHhDE,IGkDMwD,IAAwB,SAAQnD,IAAAA;AAAkC,aAC3E+C,cAAAA,SAAQ,WAAA;AAAA,WAAMvB,GAAyBxB,EAAAA;EAAAA,GAAa,CAACA,EAAAA,CAAAA;AAAY;AHnD9D,IIMMoD,KAAiB,SAAH3D,IAAAA;AAUrB,MATFa,KAAKb,GAALa,OACAqB,KAAClC,GAADkC,GACAC,KAACnC,GAADmC,GACA7C,KAAIU,GAAJV,MAOMsE,IAAQC,GAAAA,GACdC,KAA0CC,GAAAA,GAAlC3E,IAAO0E,GAAP1E,SAAiB4E,IAAYF,GAApBG,QAEXC,KAAgBC,UAAU,EAC5BjC,GAAAA,IACAC,GAAAA,IACA8B,QAAQD,GACRI,WAAAA,CAAYhF,EAAAA,CAAAA;AAGhB,SAAoB,cAAA,OAATE,SACA+E,cAAAA,eAAc/E,IAAM,EAAE4C,GAAAA,IAAGC,GAAAA,IAAGtB,OAAAA,GAAAA,CAAAA,QAInCyD,oBAAAA,MAAAC,oBAAAA,UAAA,EAAAC,UACKZ,CAAAA,EAAM1D,YAAYkD,KAAKqB,eAAe,SACnCC,oBAAAA,KAACC,SAASvB,MAAI,EACVlB,GAAGgC,GAAchC,GACjBC,GAAG+B,GAAc/B,GACjByC,OAAKzD,GAAA,CAAA,GACEyC,EAAM1D,YAAYkD,MAAI,EACzByB,gBAAgB,SAChBC,aAAmD,IAAtClB,EAAM1D,YAAYkD,KAAKqB,cACpCM,QAAQnB,EAAM1D,YAAYkD,KAAK4B,aAAAA,CAAAA,GACjCR,UAEDlF,GAAAA,CAAAA,OAGToF,oBAAAA,KAACC,SAASvB,MAAI,EACVlB,GAAGgC,GAAchC,GACjBC,GAAG+B,GAAc/B,GACjByC,WAAOxD,YAAAA,SAAKwC,EAAM1D,YAAYkD,MAAM,CAAC,gBAAgB,cAAA,CAAA,GAAiBoB,UAErElF,GAAAA,CAAAA,CAAAA,EAAAA,CAAAA;AAIjB;AJxDO,IKIM2F,KAAiB,SAAHjF,IAAAA;AAMrB,MALFmD,KAAMnD,GAANmD,QAAM+B,KAAAlF,GACNmF,WAAAA,KAAAA,WAASD,MAAQA,IAKXtB,KAAQC,GAAAA,GAERuB,SAAO9B,cAAAA,SAAQ,WAAA;AACjB,QAAO+B,KAA8BlC,GAAM,CAAA;AAE3C,WAFqCA,GAAMmC,MAAA,CAAA,EAExBjF,OACf,SAACC,IAAGkD,IAAAA;AAAO,aAASlD,KAAG,OAAfkD,GAAA,CAAA,IAAqB,MAAlBA,GAAA,CAAA;IAAA,GAAyB,MAChC6B,GAAW,CAAA,IAAA,MAAMA,GAAW,CAAA,CAAA;EAExC,GAAG,CAAClC,EAAAA,CAAAA,GAEEoC,IAAeC,GAAgBJ,EAAAA;AAErC,MAAID,MAAavB,GAAM1D,YAAYuF,KAAKhB,gBAAgB,EACpD,QAAO;AAGX,MAAMG,KAAKzD,GAAA,CAAA,GAAQyC,GAAM1D,YAAYuF,IAAAA;AASrC,SARIN,OACAP,GAAMc,gBAAgB,UACtBd,GAAME,cACFlB,GAAM1D,YAAYuF,KAAKX,cAAoD,IAAtClB,GAAM1D,YAAYuF,KAAKhB,cAChEG,GAAMG,SAASnB,GAAM1D,YAAYuF,KAAKT,cACtCJ,GAAMe,UAAU/B,GAAM1D,YAAYuF,KAAKG,qBAGpClB,oBAAAA,KAACC,SAASS,MAAI,EAACS,MAAK,QAAOC,GAAGP,GAAcX,OAAOA,GAAAA,CAAAA;AAC9D;ALtCO,IMGMmB,IAA0B,SAAH/F,IAAAA;AAA+D,MAAzDkC,KAAClC,GAADkC,GAAGC,KAACnC,GAADmC,GAAGnB,KAAIhB,GAAJgB,MACtC4C,KAAQC,GAAAA,GACdC,KAA0CC,GAAAA,GAAlC3E,KAAO0E,GAAP1E,SAAiB4E,IAAYF,GAApBG,QAEXC,KAAgBC,UAAU,EAC5BjC,GAAAA,IACAC,GAAAA,IACA6D,QAAQhF,KAAO,GACfiD,QAAQD,GACRI,WAAAA,CAAYhF,GAAAA,CAAAA;AAGhB,aACIkF,oBAAAA,MAAAC,oBAAAA,UAAA,EAAAC,UACKZ,CAAAA,GAAM1D,YAAY+F,QAAQxB,eAAe,SACtCC,oBAAAA,KAACC,SAASuB,QAAM,EACZC,IAAIjC,GAAchC,GAClBkE,IAAIlC,GAAc/B,GAClBkE,GAAGnC,GAAc8B,QACjBpB,OAAKzD,GAAA,CAAA,GACEyC,GAAM1D,YAAY+F,SAAO,EAC5BJ,MAAM,QACNf,aACIlB,GAAM1D,YAAY+F,QAAQnB,cACe,IAAzClB,GAAM1D,YAAY+F,QAAQxB,cAC9BM,QAAQnB,GAAM1D,YAAY+F,QAAQjB,cAClCW,SAAS/B,GAAM1D,YAAY+F,QAAQL,eAAAA,CAAAA,EAAAA,CAAAA,OAI/ClB,oBAAAA,KAACC,SAASuB,QAAM,EACZC,IAAIjC,GAAchC,GAClBkE,IAAIlC,GAAc/B,GAClBkE,GAAGnC,GAAc8B,QACjBpB,OAAOhB,GAAM1D,YAAY+F,QAAAA,CAAAA,CAAAA,EAAAA,CAAAA;AAIzC;ANzCO,IOIMK,IAAuB,SAAHtG,IAAAA;AAQ3B,MAPFkC,KAAClC,GAADkC,GACAC,KAACnC,GAADmC,GAACoE,KAAAvG,GACDgB,MAAAA,KAAAA,WAAIuF,KAAGvH,GAAaC,UAAOsH,IAMrB3C,KAAQC,GAAAA,GACdC,KAA0CC,GAAAA,GAAlC3E,IAAO0E,GAAP1E,SAAiB4E,KAAYF,GAApBG,QAEXC,IAAgBC,UAAU,EAC5BjC,GAAAA,IACAC,GAAAA,IACA6D,QAAQhF,KAAO,GACfiD,QAAQD,IACRI,WAAAA,CAAYhF,EAAAA,CAAAA;AAGhB,aACIkF,oBAAAA,MAAAC,oBAAAA,UAAA,EAAAC,UACKZ,CAAAA,GAAM1D,YAAY+F,QAAQxB,eAAe,SACtCC,oBAAAA,KAACC,SAASuB,QAAM,EACZC,IAAIjC,EAAchC,GAClBkE,IAAIlC,EAAc/B,GAClBkE,GAAGnC,EAAc8B,QACjBpB,OAAKzD,GAAA,CAAA,GACEyC,GAAM1D,YAAY+F,SAAO,EAC5BJ,MAAM,QACNf,aAAsD,IAAzClB,GAAM1D,YAAY+F,QAAQxB,cACvCM,QAAQnB,GAAM1D,YAAY+F,QAAQjB,cAClCW,SAAS/B,GAAM1D,YAAY+F,QAAQL,eAAAA,CAAAA,EAAAA,CAAAA,OAI/ClB,oBAAAA,KAACC,SAASuB,QAAM,EACZC,IAAIjC,EAAchC,GAClBkE,IAAIlC,EAAc/B,GAClBkE,GAAGnC,EAAc8B,QACjBpB,OAAOhB,GAAM1D,YAAYsG,OAAAA,CAAAA,CAAAA,EAAAA,CAAAA;AAIzC;APhDO,IQGMC,IAAwB,SAAHzG,IAAAA;AAY5B,MAXFkC,KAAClC,GAADkC,GACAC,KAACnC,GAADmC,GACAlB,KAAKjB,GAALiB,OACAC,KAAMlB,GAANkB,QAAMwF,KAAA1G,GACN2G,cAAAA,KAAAA,WAAYD,KAAG,IAACA,IAQV9C,IAAQC,GAAAA,GACdC,KAA0CC,GAAAA,GAAlC3E,IAAO0E,GAAP1E,SAAiB4E,IAAYF,GAApBG,QAEXC,KAAgBC,UAAU,EAC5BjC,GAAGA,KAAIjB,KAAQ,GACfkB,GAAGA,KAAIjB,KAAS,GAChBD,OAAAA,IACAC,QAAAA,IACA+C,QAAQD,GACRI,WAAAA,CAAYhF,EAAAA,CAAAA;AAGhB,aACIkF,oBAAAA,MAAAC,oBAAAA,UAAA,EAAAC,UACKZ,CAAAA,EAAM1D,YAAY+F,QAAQxB,eAAe,SACtCC,oBAAAA,KAACC,SAASiC,MAAI,EACV1E,GAAGgC,GAAchC,GACjBC,GAAG+B,GAAc/B,GACjB0E,IAAIF,IACJG,IAAIH,IACJ1F,OAAOiD,GAAcjD,OACrBC,QAAQgD,GAAchD,QACtB0D,OAAKzD,GAAA,CAAA,GACEyC,EAAM1D,YAAY+F,SAAO,EAC5BJ,MAAM,QACNf,aACIlB,EAAM1D,YAAY+F,QAAQnB,cACe,IAAzClB,EAAM1D,YAAY+F,QAAQxB,cAC9BM,QAAQnB,EAAM1D,YAAY+F,QAAQjB,cAClCW,SAAS/B,EAAM1D,YAAY+F,QAAQL,eAAAA,CAAAA,EAAAA,CAAAA,OAI/ClB,oBAAAA,KAACC,SAASiC,MAAI,EACV1E,GAAGgC,GAAchC,GACjBC,GAAG+B,GAAc/B,GACjB0E,IAAIF,IACJG,IAAIH,IACJ1F,OAAOiD,GAAcjD,OACrBC,QAAQgD,GAAchD,QACtB0D,OAAOhB,EAAM1D,YAAY+F,QAAAA,CAAAA,CAAAA,EAAAA,CAAAA;AAIzC;AR5DO,ISSMc,IAAa,SAASxG,IAAAA;AAC/B,MAAQM,KAAsBN,GAAtBM,OAAOqB,KAAe3B,GAAf2B,GAAGC,KAAY5B,GAAZ4B,GAAG7C,KAASiB,GAATjB,MACfmE,KAAWC,EAAsBnD,EAAAA;AAEvC,MAAA,CAAKlB,GAAUC,EAAAA,EACX,OAAM,IAAIoD,MAAM,sCAAA;AAGpB,aACI4B,oBAAAA,MAAAC,oBAAAA,UAAA,EAAAC,UAAA,KACIE,oBAAAA,KAACO,IAAc,EAAC9B,QAAQM,GAASN,QAAQgC,WAAAA,KAAW,CAAA,GACnDzF,GAAmBa,EAAAA,SAChBmE,oBAAAA,KAACqB,GAAuB,EAAC7D,GAAGA,IAAGC,GAAGA,IAAGnB,MAAMT,GAAWS,KAAAA,CAAAA,GAEzDnB,GAAgBU,EAAAA,SACbmE,oBAAAA,KAAC4B,GAAoB,EAACpE,GAAGA,IAAGC,GAAGA,IAAGnB,MAAMT,GAAWS,KAAAA,CAAAA,GAEtDlB,GAAiBS,EAAAA,SACdmE,oBAAAA,KAAC+B,GAAqB,EAClBvE,GAAGA,IACHC,GAAGA,IACHlB,OAAOV,GAAWU,OAClBC,QAAQX,GAAWW,QACnByF,cAAcpG,GAAWoG,aAAAA,CAAAA,OAGjCjC,oBAAAA,KAACO,IAAc,EAAC9B,QAAQM,GAASN,OAAAA,CAAAA,OACjCuB,oBAAAA,KAACf,IAAc,EAAC9C,OAAOA,IAAOqB,GAAGuB,GAASL,KAAK,CAAA,GAAIjB,GAAGsB,GAASL,KAAK,CAAA,GAAI9D,MAAMA,GAAAA,CAAAA,CAAAA,EAAAA,CAAAA;AAG1F;ATvCO,IUID0H,IAAa,SAACC,IAA+B9D,IAAAA;AAC/CA,EAAAA,GAAO+D,QAAQ,SAAAlH,IAASmH,IAAAA;AAAU,QAAjBjF,KAAClC,GAAA,CAAA,GAAEmC,KAACnC,GAAA,CAAA;AACH,UAAVmH,KACAF,GAAIG,OAAOlF,IAAGC,EAAAA,IAEd8E,GAAII,OAAOnF,IAAGC,EAAAA;EAEtB,CAAA;AACJ;AVZO,IUcMmF,KAA4B,SACrCL,IAA6BzD,IAAAA;AAQ5B,MANGtD,KAAWsD,GAAXtD,aACA0D,KAAKJ,GAALI;AAMuB,QAAvB1D,GAAYqH,WAEhBN,GAAIO,KAAAA,GACJtH,GAAYgH,QAAQ,SAAA3G,IAAAA;AAChB,QAAA,CAAKd,GAAac,GAAWjB,IAAAA,EACzB,OAAM,IAAIoD,MAAM,2CAAA;AAGhBkB,IAAAA,GAAM1D,YAAYuF,KAAKhB,eAAe,MACtCwC,GAAIQ,UAAU,UACdR,GAAIS,cAAc9D,GAAM1D,YAAYuF,KAAKT,cACzCiC,GAAIU,YACA/D,GAAM1D,YAAYuF,KAAKX,cAAoD,IAAtClB,GAAM1D,YAAYuF,KAAKhB,cAChEwC,GAAIW,UAAAA,GACJZ,EAAWC,IAAK1G,GAAWkD,SAASN,MAAAA,GACpC8D,GAAIlC,OAAAA,GACJkC,GAAIQ,UAAU,SAGd/H,GAAmBa,EAAAA,KAAeqD,GAAM1D,YAAY+F,QAAQxB,eAAe,MAC3EwC,GAAIS,cAAc9D,GAAM1D,YAAY+F,QAAQjB,cAC5CiC,GAAIU,YACA/D,GAAM1D,YAAY+F,QAAQnB,cAAuD,IAAzClB,GAAM1D,YAAY+F,QAAQxB,cACtEwC,GAAIW,UAAAA,GACJX,GAAIY,IAAItH,GAAW2B,GAAG3B,GAAW4B,GAAG5B,GAAWS,OAAO,GAAG,GAAG,IAAIW,KAAKmG,EAAAA,GACrEb,GAAIlC,OAAAA,IAGJlF,GAAgBU,EAAAA,KAAeqD,GAAM1D,YAAYsG,OAAO/B,eAAe,MACvEwC,GAAIS,cAAc9D,GAAM1D,YAAYsG,OAAOxB,cAC3CiC,GAAIU,YAAoD,IAAxC/D,GAAM1D,YAAYsG,OAAO/B,cACzCwC,GAAIW,UAAAA,GACJX,GAAIY,IAAItH,GAAW2B,GAAG3B,GAAW4B,GAAG5B,GAAWS,OAAO,GAAG,GAAG,IAAIW,KAAKmG,EAAAA,GACrEb,GAAIlC,OAAAA,IAGJjF,GAAiBS,EAAAA,KAAeqD,GAAM1D,YAAY+F,QAAQxB,eAAe,MACzEwC,GAAIS,cAAc9D,GAAM1D,YAAY+F,QAAQjB,cAC5CiC,GAAIU,YACA/D,GAAM1D,YAAY+F,QAAQnB,cAAuD,IAAzClB,GAAM1D,YAAY+F,QAAQxB,cACtEwC,GAAIW,UAAAA,GACJX,GAAIL,KACArG,GAAW2B,IAAI3B,GAAWU,QAAQ,GAClCV,GAAW4B,IAAI5B,GAAWW,SAAS,GACnCX,GAAWU,OACXV,GAAWW,MAAAA,GAEf+F,GAAIlC,OAAAA,IAGRkC,GAAIS,cAAc9D,GAAM1D,YAAYuF,KAAKV,QACzCkC,GAAIU,YAAY/D,GAAM1D,YAAYuF,KAAKX,aACvCmC,GAAIW,UAAAA,GACJZ,EAAWC,IAAK1G,GAAWkD,SAASN,MAAAA,GACpC8D,GAAIlC,OAAAA,GAEArF,GAAmBa,EAAAA,MACnB0G,GAAIS,cAAc9D,GAAM1D,YAAY+F,QAAQlB,QAC5CkC,GAAIU,YAAY/D,GAAM1D,YAAY+F,QAAQnB,aAC1CmC,GAAIW,UAAAA,GACJX,GAAIY,IAAItH,GAAW2B,GAAG3B,GAAW4B,GAAG5B,GAAWS,OAAO,GAAG,GAAG,IAAIW,KAAKmG,EAAAA,GACrEb,GAAIlC,OAAAA,IAGJlF,GAAgBU,EAAAA,MAChB0G,GAAIc,YAAYnE,GAAM1D,YAAYsG,OAAOX,MACzCoB,GAAIW,UAAAA,GACJX,GAAIY,IAAItH,GAAW2B,GAAG3B,GAAW4B,GAAG5B,GAAWS,OAAO,GAAG,GAAG,IAAIW,KAAKmG,EAAAA,GACrEb,GAAIpB,KAAAA,IAGJ/F,GAAiBS,EAAAA,MACjB0G,GAAIS,cAAc9D,GAAM1D,YAAY+F,QAAQlB,QAC5CkC,GAAIU,YAAY/D,GAAM1D,YAAY+F,QAAQnB,aAC1CmC,GAAIW,UAAAA,GACJX,GAAIL,KACArG,GAAW2B,IAAI3B,GAAWU,QAAQ,GAClCV,GAAW4B,IAAI5B,GAAWW,SAAS,GACnCX,GAAWU,OACXV,GAAWW,MAAAA,GAEf+F,GAAIlC,OAAAA,IAGuB,cAAA,OAApBxE,GAAWjB,OAClBiB,GAAWjB,KAAK2H,IAAK,EACjBpG,OAAON,GAAWM,OAClBqB,GAAG3B,GAAWkD,SAASL,KAAK,CAAA,GAC5BjB,GAAG5B,GAAWkD,SAASL,KAAK,CAAA,GAC5BQ,OAAAA,GAAAA,CAAAA,KAGJqD,GAAIe,OAAUpE,GAAM1D,YAAYkD,KAAK6E,WAAAA,QAAcrE,GAAM1D,YAAYkD,KAAK8E,YAC1EjB,GAAIkB,YAAY,QAChBlB,GAAImB,eAAe,cAEnBnB,GAAIc,YAAYnE,GAAM1D,YAAYkD,KAAKyC,MACvCoB,GAAIS,cAAc9D,GAAM1D,YAAYkD,KAAK4B,cACzCiC,GAAIU,YAAkD,IAAtC/D,GAAM1D,YAAYkD,KAAKqB,cAEnCb,GAAM1D,YAAYkD,KAAKqB,eAAe,MACtCwC,GAAIoB,WAAW,SACfpB,GAAIqB,WACA/H,GAAWjB,MACXiB,GAAWkD,SAASL,KAAK,CAAA,GACzB7C,GAAWkD,SAASL,KAAK,CAAA,CAAA,GAE7B6D,GAAIoB,WAAW,UAEnBpB,GAAIsB,SAAShI,GAAWjB,MAAMiB,GAAWkD,SAASL,KAAK,CAAA,GAAI7C,GAAWkD,SAASL,KAAK,CAAA,CAAA;EAE5F,CAAA,GACA6D,GAAIuB,QAAAA;AACR;;;;;;;;;;;;;;;;;;;;ACrIA,ICDaC,KAaT,EACAC,QAAQ,CAAC,QAAQ,QAAQ,SAAS,WAAW,aAAA,GAE7CC,aAAAA,OACAC,eAAe,GACfC,eAAe,GACfC,eAAe,GACfC,eAAe,GACfC,eAAAA,OAEAC,SAAS,GACTC,eAAe,GACfC,iBAAiB,MACjBC,aAAa,GACbC,aAAa,EAAEC,MAAM,SAASC,WAAW,CAAC,CAAC,UAAU,GAAA,CAAA,EAAA,GAErDC,aAAAA,OACAC,aAAAA,OAEAC,cAAAA,MACAC,OAAO,kBACPC,gBAAgB,EAAEN,MAAM,SAASC,WAAW,CAAC,CAAC,UAAU,CAAA,CAAA,EAAA,GAExDM,QAAQ,EACJC,MAAM,cACNC,QAAQ,kBAAA,GAEZC,YAAY,WAEZC,SAAS,CAAA,GACTC,aAAa,CAAA,GAEbC,eAAAA,MACAC,aAAa,aACbC,aDjC0BC,cAAAA,MAbI,SAAHC,IAAAA;AAAkE,MAAhCC,KAAID,GAAJC;AAC7D,SAA4B,SAAxBA,GAAKC,iBAAgC,WAGrCC,oBAAAA,KAACC,GAAY,EACTC,IAAOJ,GAAKK,UAAAA,QAAaL,GAAKM,KAAKC,GACnCC,OAAOR,GAAKC,gBACZQ,YAAAA,MACAC,OAAOV,GAAKU,MAAAA,CAAAA;AAGxB,CAAA,GCqCIC,SAAAA,MACAC,cAAc,SAAA;ADjDlB,ICoDaC,IAAeC,GAAAA,CAAAA,GACrB7C,IAAkB,EACrB8C,SAAS,CAAE,GACXC,WAAW,MACXC,YAAY,MACZC,UAAU,CAAE,GACZC,cAAc,GACdC,eAAe,OAAA,CAAA;AD3DnB,IC8DaC,KAAkBP,GAAAA,CAAAA,GACxB7C,IAAkB,EACrB8C,SAAS,CAAE,GACXC,WAAW,MACXC,YAAY,MACZC,UAAU,CAAE,GACZI,YAAY,QACZC,YAA8B,eAAA,OAAXC,UAAyBA,OAAOC,oBAAwB,EAAA,CAAA;ADrE/E,IEMaC,IAAgB,SAAH3B,IAAAA;AAYpB,MAXK4B,KAAM5B,GAAb6B,OACQC,KAAO9B,GAAf+B,QACAC,KAAIhC,GAAJgC,MACAC,KAAOjC,GAAPiC,SASIJ,KAAQD,IACRG,KAASD,IAETI,KAAU,GACVC,IAAU;AAEd,MAdWnC,GAAX5B,aAciB;AACb,QAAMgE,IAAYC,KAAKC,IAAIV,KAASK,IAAS,CAAA,GACvCM,IAAaF,KAAKC,IAAIR,KAAUE,IAAM,CAAA,GACtCQ,IAAWH,KAAKI,IAAIL,GAAWG,CAAAA;AAKrCL,IAAAA,MAAWN,MAHXC,KAAQW,IAAWP,OAGU,GAC7BE,KAAWL,MAHXC,KAASS,IAAWR,OAGW;EACnC;AAEA,SAAO,EACHE,SAAAA,IACAC,SAAAA,GACAN,OAAAA,IACAE,QAAAA,GAAAA;AAER;AF3CA,IE6CaW,KAAe,SAAHC,IAAAA;AAgBnB,MAfFpC,KAAIoC,GAAJpC,MACOqB,KAAMe,GAAbd,OACQC,KAAOa,GAAfZ,QACA1D,KAAasE,GAAbtE,eACAC,KAAaqE,GAAbrE,eACAC,KAAaoE,GAAbpE,eACAC,KAAamE,GAAbnE,eACAJ,IAAWuE,GAAXvE,aASMwE,IAAa,oBAAIC,OACjBC,IAAqB,CAAA,GACrBC,IAAsB,CAAA,GAEtBC,IAA0E,CAAA;AAEhFzC,EAAAA,GAAK0C,QAAQ,SAAAC,IAAAA;AACTJ,MAASK,KAAKD,GAAM7C,EAAAA,GAEpB6C,GAAM3C,KAAK0C,QAAQ,SAAAG,IAAAA;AACfR,QAAWS,IAAID,GAAM5C,CAAAA;AAErB,UAAIC,KAAuB;AAAA,iBACvB2C,GAAME,KAA+B,SAAZF,GAAME,MAC/BP,EAAUI,KAAKC,GAAME,CAAAA,GACrB7C,KAAQ2C,GAAME,IAGlBN,EAAMG,KAAK,EACP9C,IAAO6C,GAAM7C,KAAM+C,MAAAA,GAAM5C,GACzBF,SAAS4C,GAAM7C,IACfI,OAAAA,IACAF,MAAM6C,GAAAA,CAAAA;IAEd,CAAA;EACJ,CAAA;AAEA,MAAMG,KAAUC,MAAMzE,KAAK6D,CAAAA,GAE3Ba,IAA4C9B,EAAc,EACtDE,OAAOD,IACPG,QAAQD,IACRG,SAASsB,GAAQG,QACjB1B,MAAMc,EAASY,QACftF,aAAAA,EAAAA,CAAAA,GALIyD,KAAK4B,EAAL5B,OAAOE,KAAM0B,EAAN1B,QAAQG,KAAOuB,EAAPvB,SAASC,IAAOsB,EAAPtB,SAQ1BwB,KAASC,GACXC,KAAAA,EACKC,OAAOP,EAAAA,EACPQ,MAAM,CAAC,GAAGlC,EAAAA,CAAAA,EACVmC,aAAa1F,EAAAA,EACb2F,aAAa5F,EAAAA,CAAAA,GAGhB6F,KAASN,GACXC,KAAAA,EACKC,OAAOhB,CAAAA,EACPiB,MAAM,CAAC,GAAGhC,EAAAA,CAAAA,EACViC,aAAaxF,EAAAA,EACbyF,aAAa1F,EAAAA,CAAAA,GAGhB6D,KAAYuB,GAAOQ,UAAAA,GACnB5B,KAAa2B,GAAOC,UAAAA,GAEpBC,KAGApB,EAAMqB,IAAI,SAAApE,IAAAA;AAAI,WAAAc,GAAAA,CAAAA,GACbd,IAAI,EACPO,GAAGmD,GAAO1D,GAAKM,KAAKC,CAAAA,IAAM4B,KAAY,GACtCkB,GAAGY,GAAOjE,GAAKK,OAAAA,IAAYiC,KAAa,GACxCV,OAAOO,IACPL,QAAQQ,GAAAA,CAAAA;EAAU,CAAA;AAGtB,SAAO,EACHV,OAAAA,IACAE,QAAAA,IACAG,SAAAA,IACAC,SAAAA,GACAwB,QAAAA,IACAO,QAAAA,IACAI,UAAUjC,KAAKI,IAAG8B,MAARlC,MAAYU,CAAAA,GACtByB,UAAUnC,KAAKC,IAAGiC,MAARlC,MAAYU,CAAAA,GACtBC,OAAOoB,GAAAA;AAEf;AF5IA,IE8IaK,KAAmB,SAC5BC,IACAjC,IACAH,IAAAA;AAEA,MAAA,CAAKoC,GAAM,QAAO,WAAA;AAAA,WAAM;EAAC;AAEzB,MAAMC,KAAQC,OAAAA,EACTd,OAAOY,GAAKG,SAASH,GAAKG,SAAS,CAACpC,IAAKH,EAAAA,CAAAA,EACzCyB,MAAMW,GAAKI,KAAAA;AAEhB,SAAO,SAACrE,IAAAA;AACJ,WAAc,SAAVA,KAAuB,IACpBkE,GAAMlE,EAAAA;EAAAA;AAErB;AF7JA,IE+JasE,IAA4B,SACrC9E,IAAAA;AAAyB,SACvB,EACFO,GAAGP,GAAKO,GACR8C,GAAGrD,GAAKqD,EAAAA;AACX;AFpKD,IEsKa0B,IAA8B,SACvC/E,IAAAA;AAAyB,SACvB,EACFyE,MAAMrC,KAAKC,IAAIrC,GAAK4B,OAAO5B,GAAK8B,MAAAA,GAChCF,OAAO5B,GAAK4B,OACZE,QAAQ9B,GAAK8B,OAAAA;AAChB;AF5KD,IGgBakD,IAAkB,SAAHjF,IAAAA;AAAA,MACxBO,KAAIP,GAAJO,MACAsB,KAAK7B,GAAL6B,OACAE,KAAM/B,GAAN+B,QACA1D,KAAa2B,GAAb3B,eACAC,KAAa0B,GAAb1B,eACAC,KAAayB,GAAbzB,eACAC,IAAawB,GAAbxB,eACAJ,IAAW4B,GAAX5B;AAAW,aASX8G,cAAAA,SACI,WAAA;AAAA,WACIxC,GAAgC,EAC5BnC,MAAAA,IACAsB,OAAAA,IACAE,QAAAA,IACA1D,eAAAA,IACAC,eAAAA,IACAC,eAAAA,IACAC,eAAAA,GACAJ,aAAAA,EAAAA,CAAAA;EACF,GACN,CACImC,IACAsB,IACAE,IACA1D,IACAC,IACAC,IACAC,GACAJ,CAAAA,CAAAA;AAEP;AHvDL,IGyDM+G,IAAsB,EACxBlF,MAAM,SACFA,IAIAmF,IAAAA;AAA4B,SAC3BnF,GAAKI,OAAO+E,GAAQ/E;AAAE,GAC3BgF,KAAK,SACDpF,IAIAmF,IAAAA;AAA4B,SAC3BnF,GAAKK,YAAY8E,GAAQ9E;AAAO,GACrCgF,QAAQ,SACJrF,IAIAmF,IAAAA;AAA4B,SAC3BnF,GAAKM,KAAKC,MAAM4E,GAAQ7E,KAAKC;AAAC,GACnC+E,WAAW,SACPtF,IAIAmF,IAAAA;AAA4B,SAC3BnF,GAAKK,YAAY8E,GAAQ9E,WAAWL,GAAKM,KAAKC,MAAM4E,GAAQ7E,KAAKC;AAAC,EAAA;AHrF3E,IG+FMgF,IAAgB,SAAH7C,IAAAA;AAmCb,MAzCF+B,IACAjC,IACAH,IAKAU,KAAKL,GAALK,OACAsB,KAAQ3B,GAAR2B,UACAE,IAAQ7B,GAAR6B,UACA/F,IAAakE,GAAblE,eACAa,KAAMqD,GAANrD,QACAG,IAAUkD,GAAVlD,YACAf,KAAOiE,GAAPjE,SACAC,KAAagE,GAAbhE,eACAC,KAAe+D,GAAf/D,iBACAE,IAAW6D,GAAX7D,aACAM,KAAKuD,GAALvD,OACAC,KAAcsD,GAAdtD,gBACAoG,KAAW9C,GAAX8C,aACAC,KAAS/C,GAAT+C,WAsBMC,SAtCNT,cAAAA,SAAQ,WAAA;AAAA,WAAMT,GAAiBC,IAAMjC,IAAKH,EAAAA;EAAI,GAAE,CAJhDoC,KA0C6BjG,GAzC7BgE,KAyC4C6B,IAxC5ChC,KAwCsDkC,CAAAA,CAAAA,GAEhDoB,SAAaV,cAAAA,SAAQ,WAAA;AACvB,WAAsB,cAAA,OAAX5F,KAA8B,OAElCuG,GAAwBvG,IAAQ,EACnCmD,KAAK6B,IACLhC,KAAKkC,EAAAA,CAAAA;EAEZ,GAAE,CAAClF,IAAQgF,IAAUE,CAAAA,CAAAA,GAEhBsB,SAAWC,cAAAA,aACb,SAAC9F,IAAAA;AACG,QAAmB,SAAfA,GAAKQ,OAAgB;AACrB,UAAsB,cAAA,OAAXnB,GAAuB,QAAOA,GAAOW,EAAAA;AAChD,UAAmB,SAAf2F,GAAqB,QAAOA,GAAW3F,GAAKQ,KAAAA;IACpD;AAEA,WAAOhB;EACV,GACD,CAACH,IAAQsG,IAAYnG,CAAAA,CAAAA,GAEnBuG,KAAQC,GAAAA,GACRC,KAAiBC,GAAkBrH,GAAakH,EAAAA,GAChDI,KAAoBD,GAAkB9G,IAAgB2G,EAAAA,GAEtDK,KAAcC,GAAkBb,EAAAA,GAChCc,KAAWC,GAAoBpH,EAAAA;AA0CrC,SAAO,EACH4D,WAzCgBkC,cAAAA,SAChB,WAAA;AAAA,WACIlC,GAAMqB,IAAI,SAAApE,IAAAA;AACN,UAAIwG,KAAkB/H;AAClBgH,MAAAA,GAAUhC,SAAS,MACnB+C,KAAkBf,GAAUgB,SAASzG,GAAKI,EAAAA,IAAM1B,KAAgBC;AAGpE,UAAM+H,KAAiBhB,GAAQ1F,GAAKQ,KAAAA,GAE9BmG,KAAY7F,GAAA,CAAA,GACXd,IAAI,EACP4B,OAAO5B,GAAK4B,QAAQ8E,IACpB5E,QAAQ9B,GAAK8B,SAAS4E,IACtBzG,gBAA+B,SAAfD,GAAKQ,QAAiB4F,GAAYpG,GAAKQ,KAAAA,IAAS,MAChE/B,SAAS+H,GAAAA,CAAAA;AAQb,aALAG,GAAaxH,QAAQmH,GAASK,EAAAA,GAC9BA,GAAajG,QAAQmF,GAASc,EAAAA,GAC9BA,GAAa9H,cAAcoH,GAAeU,EAAAA,GAC1CA,GAAavH,iBAAiB+G,GAAkBQ,EAAAA,GAEzCA;IACX,CAAA;EACJ,GAAA,CACI5D,IACA2C,IACAG,IACAI,IACAE,IACAC,IACAE,IACAb,IACAhH,IACAC,IACAC,EAAAA,CAAAA,GAMJgH,YAAAA,GAAAA;AAER;AH5MA,IG8MaiB,KAAa,SAAHC,IAAAA;AA+CjB,MA3CFvG,KAAIuG,GAAJvG,MACAkF,KAAWqB,GAAXrB,aACO7D,KAAMkF,GAAbjF,OACQC,KAAOgF,GAAf/E,QAAMgF,KAAAD,GACNxI,eAAAA,IAAAA,WAAayI,KAAG7I,GAAmBI,gBAAayI,IAAAC,IAAAF,GAChDzI,eAAAA,IAAAA,WAAa2I,IAAG9I,GAAmBG,gBAAa2I,GAAAC,IAAAH,GAChDtI,eAAAA,IAAAA,WAAayI,IAAG/I,GAAmBM,gBAAayI,GAAAC,KAAAJ,GAChDvI,eAAAA,IAAAA,WAAa2I,KAAGhJ,GAAmBK,gBAAa2I,IAAAC,KAAAL,GAChD1I,aAAAA,KAAAA,WAAW+I,KAAGjJ,GAAmBE,cAAW+I,IAAAC,KAAAN,GAC5CrI,eAAAA,IAAAA,WAAa2I,KAAGlJ,GAAmBO,gBAAa2I,IAAAC,KAAAP,GAChDxH,QAAAA,KAAAA,WAAM+H,KAAGnJ,GAAmBoB,SAAM+H,IAAAC,KAAAR,GAClCrH,YAAAA,KAAAA,WAAU6H,KAAGpJ,GAAmBuB,aAAU6H,IAAAC,KAAAT,GAC1CpI,SAAAA,KAAAA,WAAO6I,KAAGrJ,GAAmBQ,UAAO6I,IAAAC,KAAAV,GACpCnI,eAAAA,KAAAA,WAAa6I,KAAGtJ,GAAmBS,gBAAa6I,IAAAC,KAAAX,GAChDlI,iBAAAA,KAAAA,WAAe6I,KAAGvJ,GAAmBU,kBAAe6I,IAAAC,KAAAZ,GACpDhI,aAAAA,KAAAA,WAAW4I,KAAGxJ,GAAmBY,cAAW4I,IAAAC,KAAAb,GAC5C1H,OAAAA,KAAAA,WAAKuI,KAAGzJ,GAAmBkB,QAAKuI,IAAAC,KAAAd,GAChCzH,gBAAAA,KAAAA,WAAcuI,KAAG1J,GAAmBmB,iBAAcuI,IAAAC,KAAAf,GAClDjH,aAAAA,KAAAA,WAAWgI,KAAG3J,GAAmB2B,cAAWgI,IA0B5CC,SAAoCC,cAAAA,UAAqC,IAAA,GAAlEC,KAAUF,GAAA,CAAA,GAAEG,IAAaH,GAAA,CAAA,GAEhCI,KACIjD,EAAmC,EAC/B1E,MAAAA,IACAsB,OAAOD,IACPG,QAAQD,IACRxD,eAAAA,GACAD,eAAAA,GACAG,eAAAA,GACAD,eAAAA,GACAH,aAAAA,GAAAA,CAAAA,GATAyD,KAAKqG,GAALrG,OAAOE,KAAMmG,GAANnG,QAAQG,KAAOgG,GAAPhG,SAASC,KAAO+F,GAAP/F,SAASa,KAAKkF,GAALlF,OAAOW,KAAMuE,GAANvE,QAAQO,KAAMgE,GAANhE,QAAQI,KAAQ4D,GAAR5D,UAAUE,KAAQ0D,GAAR1D,UAYpEkB,UAAYR,cAAAA,SAAQ,WAAA;AACtB,QAAA,CAAK8C,GAAY,QAAO,CAAA;AAExB,QAAMG,KAAgBhD,EAAoBtF,EAAAA;AAE1C,WAAOmD,GAAMoF,OAAO,SAAAnI,IAAAA;AAAI,aAAIkI,GAAclI,IAAM+H,EAAAA;IAAW,CAAA,EAAE3D,IAAI,SAAApE,IAAAA;AAAI,aAAIA,GAAKI;IAAAA,CAAAA;EACjF,GAAE,CAAC2C,IAAOgF,IAAYnI,EAAAA,CAAAA,GAEvBwI,MAA6C7C,EAAqB,EAC9DxC,OAAAA,IACAsB,UAAAA,IACAE,UAAAA,IACA/F,eAAAA,GACAa,QAAAA,IACAG,YAAAA,IACAf,SAAAA,IACAC,eAAAA,IACAC,iBAAAA,IACAE,aAAAA,IACAM,OAAAA,IACAC,gBAAAA,IACAoG,aAAAA,IACAC,WAAAA,IAAAA,CAAAA;AAGJ,SAAO,EACH7D,OAAAA,IACAE,QAAAA,IACAG,SAAAA,IACAC,SAAAA,IACAa,OAtBwBqF,IAApBrF,OAuBJW,QAAAA,IACAO,QAAAA,IACA0B,YAzBoCyC,IAAVzC,YA0B1BoC,YAAAA,IACAC,eAAAA,EAAAA;AAER;AHjTA,IGmTaK,KAAqB,SAC9BtF,IACArD,IAAAA;AAAqD,SAErD4I,GAAoC,EAChChI,MAAMyC,IACNrD,aAAAA,IACA6I,aAAazD,GACb0D,eAAezD,EAAAA,CAAAA;AACjB;AH5TN,IImEa0D,SAAkB3I,cAAAA,MAlEI,SAAHC,IAAAA;AAUC,MAT7BC,KAAID,GAAJC,MACApB,KAAWmB,GAAXnB,aACAuC,KAAYpB,GAAZoB,cACAuH,KAAa3I,GAAb2I,eACAC,KAAY5I,GAAZ4I,cACAC,KAAW7I,GAAX6I,aACAC,IAAY9I,GAAZ8I,cACAC,IAAO/I,GAAP+I,SACA5J,IAAYa,GAAZb,cAEM6G,IAAQC,GAAAA,GAER+C,SAAW9D,cAAAA,SACb,WAAA;AAAA,WAAO,EACH0D,cAAcA,KAAeA,GAAa3I,EAAAA,IAAAA,QAC1C4I,aAAaA,KAAcA,GAAY5I,EAAAA,IAAAA,QACvC6I,cAAcA,IAAeA,EAAa7I,EAAAA,IAAAA,QAC1C8I,SAASA,IAAUA,EAAQ9I,EAAAA,IAAAA,OAAQgJ;EACtC,GACD,CAAChJ,IAAM2I,IAAcC,IAAaC,GAAcC,CAAAA,CAAAA;AAGpD,aACIG,oBAAAA,MAACC,SAASC,GAACrI,GAAA,EACP,eAAqBd,UAAAA,GAAKI,IAC1BgJ,OAAO,EAAEC,QAAQ,UAAA,GACjB5K,SAASiK,GAAcjK,QAAAA,GACnBsK,IAAQ,EACZO,WAAWC,GACP,CAACb,GAAcnI,GAAGmI,GAAcrF,GAAGqF,GAAchE,KAAAA,GACjD,SAACnE,IAAG8C,IAAGqB,IAAAA;AAAK,WAAA,eAAkBnE,KAAC,OAAK8C,KAAC,aAAWqB,KAAK;EAAA,CAAA,GACvD8E,UAEFtJ,KAAAA,oBAAAA,KAACgJ,SAASO,MAAI,EACVH,WAAWC,GACP,CAACb,GAAc9G,OAAO8G,GAAc5G,MAAAA,GACpC,SAACF,IAAOE,IAAAA;AAAM,WAAkBF,eAAAA,OAAAA,KAAAA,OAAAA,OAAiBE,KAAa;EAAA,CAAA,GAGlE4H,MAAMhB,GAAchI,OACpBkB,OAAO8G,GAAc9G,OACrBE,QAAQ4G,GAAc5G,QACtB6H,QAAQjB,GAAc7J,aACtB+K,aAAahL,IACbiL,IAAI1I,IACJ2I,IAAI3I,GAAAA,GAPCnB,GAAKI,EAAAA,GASblB,SACGgB,oBAAAA,KAACgJ,SAASa,MAAI,EACVC,YAAW,UACXC,kBAAiB,WACjBP,MAAMhB,GAActJ,gBACpBgK,OAAKtI,GAAA,CAAA,GACEiF,EAAMmE,OAAOH,MAAI,EACpBL,MAAAA,QACAS,YAAY,OAAA,CAAA,GACdX,UAEDxJ,GAAKb,MAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA;AAK1B,CAAA;AJjEA,IK0DaiL,SAAoBtK,cAAAA,MAzDI,SAAHC,IAAAA;AASD,MAR7BC,KAAID,GAAJC,MACApB,KAAWmB,GAAXnB,aACA8J,KAAa3I,GAAb2I,eACAC,KAAY5I,GAAZ4I,cACAC,KAAW7I,GAAX6I,aACAC,KAAY9I,GAAZ8I,cACAC,IAAO/I,GAAP+I,SACA5J,IAAYa,GAAZb,cAEM6G,IAAQC,GAAAA,GAER+C,QAAW9D,cAAAA,SACb,WAAA;AAAA,WAAO,EACH0D,cAAcA,KAAeA,GAAa3I,EAAAA,IAAAA,QAC1C4I,aAAaA,KAAcA,GAAY5I,EAAAA,IAAAA,QACvC6I,cAAcA,KAAeA,GAAa7I,EAAAA,IAAAA,QAC1C8I,SAASA,IAAUA,EAAQ9I,EAAAA,IAAAA,OAAQgJ;EACtC,GACD,CAAChJ,IAAM2I,IAAcC,IAAaC,IAAcC,CAAAA,CAAAA;AAGpD,aACIG,oBAAAA,MAACC,SAASC,GAACrI,GAAA,EACP,eAAqBd,UAAAA,GAAKI,IAC1BgJ,OAAO,EAAEC,QAAQ,UAAA,GACjB5K,SAASiK,GAAcjK,QAAAA,GACnBsK,GAAQ,EACZO,WAAWC,GAAG,CAACb,GAAcnI,GAAGmI,GAAcrF,CAAAA,GAAI,SAAC9C,IAAG8C,IAAAA;AAAC,WAAkB9C,eAAAA,KAAAA,OAAM8C,KAAC;EAAA,CAAA,GAAKmG,UAErFtJ,KAAAA,oBAAAA,KAACgJ,SAASmB,QAAM,EACZC,GAAGf,GACC,CAACb,GAAc9G,OAAO8G,GAAc5G,MAAAA,GACpC,SAACF,IAAOE,IAAAA;AAAM,WAAKM,KAAKI,IAAIZ,IAAOE,EAAAA,IAAU;EAAC,CAAA,GAElD4H,MAAMhB,GAAchI,OACpB6J,aAAa7B,GAAcjK,SAC3BmL,aAAahL,IACb+K,QAAQjB,GAAc7J,YAAAA,CAAAA,GAEzBK,SACGgB,oBAAAA,KAACgJ,SAASa,MAAI,EACVE,kBAAiB,WACjBD,YAAW,UACXN,MAAMhB,GAActJ,gBACpBgK,OAAKtI,GAAA,CAAA,GACEiF,EAAMmE,OAAOH,MAAI,EACpBL,MAAAA,OAAMV,CAAAA,GACRQ,UAEDxJ,GAAKb,MAAAA,CAAAA,CAAAA,EAAAA,CAAAA,CAAAA;AAK1B,CAAA;ALxDA,IMyBMqL,KAAkB,SAA6BxK,IAAAA;AAAyB,SAAM,EAChFO,GAAGP,GAAKO,GACR8C,GAAGrD,GAAKqD,GACRzB,OAAO5B,GAAK4B,OACZE,QAAQ9B,GAAK8B,QACbpB,OAAOV,GAAKU,OACZjC,SAAS,GACTI,aAAamB,GAAKnB,aAClBO,gBAAgBY,GAAKZ,gBACrBsF,OAAO,EAAA;AACV;ANnCD,IMqCM+F,MAAoB,SAA6BzK,IAAAA;AAAyB,SAAM,EAClFO,GAAGP,GAAKO,GACR8C,GAAGrD,GAAKqD,GACRzB,OAAO5B,GAAK4B,OACZE,QAAQ9B,GAAK8B,QACbpB,OAAOV,GAAKU,OACZjC,SAASuB,GAAKvB,SACdI,aAAamB,GAAKnB,aAClBO,gBAAgBY,GAAKZ,gBACrBsF,OAAO,EAAA;AACV;AN/CD,IMiDMgG,KAAiB,SAA6B1K,IAAAA;AAAyB,SAAM,EAC/EO,GAAGP,GAAKO,GACR8C,GAAGrD,GAAKqD,GACRzB,OAAO5B,GAAK4B,OACZE,QAAQ9B,GAAK8B,QACbpB,OAAOV,GAAKU,OACZjC,SAAS,GACTI,aAAamB,GAAKnB,aAClBO,gBAAgBY,GAAKZ,gBACrBsF,OAAO,EAAA;AACV;AN3DD,IM6DaiG,KAAe,SAAH5K,IAAAA;AAamB,MAqDpC6K,IAjEJ7H,KAAKhD,GAALgD,OACA3B,KAAarB,GAAbqB,eACAD,KAAYpB,GAAZoB,cACAvC,KAAWmB,GAAXnB,aACAe,IAAaI,GAAbJ,eACAqI,IAAajI,GAAbiI,eACAW,IAAY5I,GAAZ4I,cACAC,IAAW7I,GAAX6I,aACAC,KAAY9I,GAAZ8I,cACAC,IAAO/I,GAAP+I,SACAjJ,KAAOE,GAAPF,SACAX,KAAYa,GAAZb,cAEA2L,KAA0CC,GAAAA,GAAlCnK,IAAOkK,GAAPlK,SAAiBoK,KAAYF,GAApBG,QAEXC,KAAaC,cAAsDnI,IAAO,EAC5EoI,MAAM,SAACnL,IAAAA;AAAyB,WAAKA,GAAKI;EAAE,GAC5CgL,SAASX,KACT3L,MAAM0L,IACNa,OAAOZ,KACPa,QAAQb,KACRc,OAAOb,IACPM,QAAQD,IACRS,WAAAA,CAAY7K,EAAAA,CAAAA,GAGhB8K,KAA8CC,EAAAA,GAAtCC,KAAoBF,GAApBE,sBAAsBC,KAAWH,GAAXG,aAExBC,SAAmB5G,cAAAA,SAAQ,WAAA;AAC7B,QAAKtF,EAEL,QAAO,SAACK,IAAAA;AAAyB,aAAK,SAAC8L,IAAAA;AACnCH,QAAAA,OAAqBI,cAAAA,eAAclM,IAAS,EAAEG,MAAAA,GAAAA,CAAAA,GAAS8L,EAAAA,GACvD9D,EAAchI,EAAAA,GAAAA,QACd2I,KAAAA,EAAe3I,IAAM8L,EAAAA;MAAAA;IACxB;EACL,GAAG,CAACnM,GAAegM,IAAsB9L,IAASmI,GAAeW,CAAAA,CAAAA,GAE3DqD,SAAkB/G,cAAAA,SAAQ,WAAA;AAC5B,QAAKtF,EAEL,QAAO,SAACK,IAAAA;AAAyB,aAAK,SAAC8L,IAAAA;AACnCH,QAAAA,OAAqBI,cAAAA,eAAclM,IAAS,EAAEG,MAAAA,GAAAA,CAAAA,GAAS8L,EAAAA,GAAAA,QACvDlD,KAAAA,EAAc5I,IAAM8L,EAAAA;MAAAA;IACvB;EACJ,GAAE,CAACnM,GAAegM,IAAsB9L,IAAS+I,CAAAA,CAAAA,GAE5CqD,SAAmBhH,cAAAA,SAAQ,WAAA;AAC7B,QAAKtF,EAEL,QAAO,SAACK,IAAAA;AAAyB,aAAK,SAAC8L,IAAAA;AACnCF,QAAAA,GAAAA,GACA5D,EAAc,IAAA,GAAA,QACda,MAAAA,GAAe7I,IAAM8L,EAAAA;MAAAA;IACxB;EACJ,GAAE,CAACnM,GAAeiM,IAAa5D,GAAea,EAAAA,CAAAA,GAEzCqD,SAAcjH,cAAAA,SAAQ,WAAA;AACxB,QAAKtF,EAEL,QAAO,SAACK,IAAAA;AAAyB,aAAK,SAAC8L,IAAAA;AAAAA,gBACnChD,KAAAA,EAAU9I,IAAM8L,EAAAA;MAAAA;IACnB;EACL,GAAG,CAACnM,GAAemJ,CAAAA,CAAAA;AAWnB,SAPI8B,KADkB,WAAlBxJ,KACOqH,KACkB,aAAlBrH,KACAgJ,KAEAhJ,QAIPlB,oBAAAA,KAAAiM,oBAAAA,UAAA,EAAA3C,UACKyB,GAAW,SAACvC,IAAe1I,IAAAA;AAAI,eAC5B+L,cAAAA,eAAcnB,IAAM,EAChB5K,MAAAA,IACAmB,cAAAA,IACAvC,aAAAA,IACA8J,eAAAA,IACAxJ,cAAAA,IACAyJ,cAAckD,IACdjD,aAAaoD,IACbnD,cAAcoD,IACdnD,SAASoD,GAAAA,CAAAA;EAAAA,CAAAA,EAAAA,CAAAA;AAK7B;ANzJA,IOKaE,KAAyB,SAAHrM,IAAAA;AAGO,MAFtCgD,KAAKhD,GAALgD,OACArD,KAAWK,GAAXL,aAEM2M,KAAmBhE,GAA0BtF,IAAOrD,EAAAA;AAE1D,aACIQ,oBAAAA,KAAAiM,oBAAAA,UAAA,EAAA3C,UACK6C,GAAiBjI,IAAI,SAACkI,IAAYC,IAAAA;AAAC,eAChCrM,oBAAAA,KAACsM,GAAU1L,GAAawL,CAAAA,GAAAA,EAAAA,GAAPC,EAAAA;EAAAA,CAAAA,EAAAA,CAAAA;AAIjC;APlBA,IOkBA,KAAA,CAAA,iBAAA,WAAA,gBAAA,SAAA,eAAA;APlBA,IQkBME,KAAe,SAAH1M,IAAAA;AA8C0B,MA7CxCO,KAAIP,GAAJO,MAAIoM,KAAA3M,GACJ7B,QAAAA,KAAAA,WAAMwO,KAAG7L,EAAgB3C,SAAMwO,IAC/BlH,KAAWzF,GAAXyF,aACA5D,IAAK7B,GAAL6B,OACAE,IAAM/B,GAAN+B,QACQ6K,IAAa5M,GAArB6M,QAAMC,IAAA9M,GACN5B,aAAAA,IAAAA,WAAW0O,IAAGhM,EAAgB1C,cAAW0O,GAAAC,KAAA/M,GACzC3B,eAAAA,KAAAA,WAAa0O,KAAGjM,EAAgBzC,gBAAa0O,IAAAC,KAAAhN,GAC7C1B,eAAAA,KAAAA,WAAa0O,KAAGlM,EAAgBxC,gBAAa0O,IAAAC,KAAAjN,GAC7CzB,eAAAA,KAAAA,WAAa0O,KAAGnM,EAAgBvC,gBAAa0O,IAAAC,KAAAlN,GAC7CxB,eAAAA,KAAAA,WAAa0O,KAAGpM,EAAgBtC,gBAAa0O,IAAAC,KAAAnN,GAC7CvB,eAAAA,KAAAA,WAAa0O,KAAGrM,EAAgBrC,gBAAa0O,IAAAC,KAAApN,GAC7CqB,eAAAA,KAAAA,WAAa+L,KAAGtM,EAAgBO,gBAAa+L,IAAAC,KAAArN,GAG7CtB,SAAAA,KAAAA,WAAO2O,KAAGvM,EAAgBpC,UAAO2O,IAAAC,KAAAtN,GACjCrB,eAAAA,KAAAA,WAAa2O,KAAGxM,EAAgBnC,gBAAa2O,IAAAC,KAAAvN,GAC7CpB,iBAAAA,KAAAA,WAAe2O,KAAGzM,EAAgBlC,kBAAe2O,IAAAC,KAAAxN,GACjDoB,cAAAA,KAAAA,WAAYoM,KAAG1M,EAAgBM,eAAYoM,IAAAC,IAAAzN,GAC3CnB,aAAAA,KAAAA,WAAW4O,IAAG3M,EAAgBjC,cAAW4O,GAAAC,KAAA1N,GACzClB,aAAAA,KAAAA,WAAW4O,KAAG5M,EAAgBhC,cAAW4O,IAAAC,KAAA3N,GACzCf,aAAAA,KAAAA,WAAW0O,KAAG7M,EAAgB7B,cAAW0O,IAAAC,KAAA5N,GACzCd,aAAAA,KAAAA,WAAW0O,KAAG9M,EAAgB5B,cAAW0O,IAAAC,KAAA7N,GACzCgB,SAAAA,KAAAA,WAAO6M,KAAG/M,EAAgBE,UAAO6M,IAAAC,KAAA9N,GACjCiB,WAAAA,KAAAA,WAAS6M,KAAGhN,EAAgBG,YAAS6M,IAAAC,KAAA/N,GACrCkB,YAAAA,MAAAA,WAAU6M,KAAGjN,EAAgBI,aAAU6M,IAAAC,MAAAhO,GACvCmB,UAAAA,MAAAA,WAAQ6M,MAAGlN,EAAgBK,WAAQ6M,KAAAC,MAAAjO,GACnCb,cAAAA,MAAAA,WAAY8O,MAAGnN,EAAgB3B,eAAY8O,KAAAC,MAAAlO,GAC3CZ,OAAAA,MAAAA,WAAK8O,MAAGpN,EAAgB1B,QAAK8O,KAAAC,MAAAnO,GAC7BX,gBAAAA,MAAAA,WAAc8O,MAAGrN,EAAgBzB,iBAAc8O,KAAAC,MAAApO,GAC/CV,QAAAA,MAAAA,WAAM8O,MAAGtN,EAAgBxB,SAAM8O,KAAAC,MAAArO,GAC/BP,YAAAA,MAAAA,WAAU4O,MAAGvN,EAAgBrB,aAAU4O,KAAAC,MAAAtO,GACvCN,SAAAA,MAAAA,WAAO4O,MAAGxN,EAAgBpB,UAAO4O,KAAAC,MAAAvO,GACjCL,aAAAA,KAAAA,WAAW4O,MAAGzN,EAAgBnB,cAAW4O,KAAAC,KAAAxO,GACzCJ,eAAAA,KAAAA,WAAa4O,KAAG1N,EAAgBlB,gBAAa4O,IAC7C5F,KAAY5I,GAAZ4I,cACAC,KAAW7I,GAAX6I,aACAC,KAAY9I,GAAZ8I,cACAC,KAAO/I,GAAP+I,SAAO0F,KAAAzO,GACPH,aAAAA,KAAAA,WAAW4O,KAAG3N,EAAgBjB,cAAW4O,IAAAC,KAAA1O,GACzCF,SAAAA,KAAAA,WAAO4O,KAAG5N,EAAgBhB,UAAO4O,IACjCC,KAAI3O,GAAJ2O,MACAC,KAAS5O,GAAT4O,WACAC,KAAc7O,GAAd6O,gBACAC,KAAe9O,GAAf8O,iBAEAC,KAMIC,GAAcnN,GAAOE,GAAQ6K,CAAAA,GALrBqC,KAAOF,GAAflC,QACYqC,KAAWH,GAAvBI,YACaC,KAAYL,GAAzBM,aACAC,KAAUP,GAAVO,YACAC,KAAWR,GAAXQ,aAGJC,MAWI3I,GAA8B,EAC9BtG,MAAAA,IACAkF,aAAAA,IACA5D,OAAOqN,IACPnN,QAAQqN,IACRhR,aAAAA,GACAC,eAAAA,IACAC,eAAAA,IACAC,eAAAA,IACAC,eAAAA,IACAC,eAAAA,IACAa,QAAAA,KACAG,YAAAA,KACAf,SAAAA,IACAC,eAAAA,IACAC,iBAAAA,IACAE,aAAAA,IACAM,OAAAA,KACAC,gBAAAA,KACAQ,aAAAA,GAAAA,CAAAA,GA7BOsP,KAAUK,IAAjB3N,OACQwN,KAAWG,IAAnBzN,QACAG,KAAOsN,IAAPtN,SACAC,KAAOqN,IAAPrN,SACAwB,KAAM6L,IAAN7L,QACAO,KAAMsL,IAANtL,QACAlB,KAAKwM,IAALxM,OACA4C,KAAU4J,IAAV5J,YACAoC,KAAUwH,IAAVxH,YACAC,KAAauH,IAAbvH,eAuBE4E,SAAS3H,cAAAA,SACX,WAAA;AAAA,WAAAnE,GAAAA,CAAAA,GACOkO,IAAO,EACVQ,KAAKR,GAAQQ,MAAMtN,IACnBuN,MAAMT,GAAQS,OAAOxN,GAAAA,CAAAA;EACvB,GACF,CAAC+M,IAAS/M,IAASC,EAAAA,CAAAA,GAGjBwN,KAAwC,EAC1CC,MAAM,MACNC,MAAM,MACN7M,OAAO,MACPtD,SAAS,MACTC,aAAa,KAAA;AAGbxB,EAAAA,GAAOuI,SAAS,MAAA,MAChBiJ,GAAUC,WACNzP,oBAAAA,KAAC2P,IAAI,EAEDjO,OAAOsN,IACPpN,QAAQsN,IACR1L,QAAQ1E,KAAc0E,KAAS,MAC/BO,QAAQhF,KAAcgF,KAAS,KAAA,GAJ3B,MAAA,IASZ/F,GAAOuI,SAAS,MAAA,MAChBiJ,GAAUE,WACN1P,oBAAAA,KAAC4P,GAAI,EAEDpM,QAAQA,IACRO,QAAQA,IACRrC,OAAOsN,IACPpN,QAAQsN,IACRI,KAAKzO,IACLgP,OAAO/O,IACPgP,QAAQ/O,KACRwO,MAAMvO,IAAAA,GARF,MAAA,IAaZhD,GAAOuI,SAAS,OAAA,MAChBiJ,GAAU3M,YACN7C,oBAAAA,KAAC+P,cAAAA,UAAQ,EAAAzG,cACLtJ,oBAAAA,KAACyK,IAAY,EACT5H,OAAOA,IACP3B,eAAeA,IACfD,cAAcA,IACdvC,aAAaA,IACbe,eAAeA,IACfqI,eAAeA,IACfW,cAAcA,IACdC,aAAaA,IACbC,cAAcA,IACdC,SAASA,IACTjJ,SAASA,IACTX,cAAcA,IAAAA,CAAAA,EAAAA,GAbR,OAAA,IAmBlBhB,GAAOuI,SAAS,SAAA,KAA6B,SAAfd,OAC9B+J,GAAUjQ,cACNS,oBAAAA,KAAC+P,cAAAA,UAAQ,EAAAzG,UACJ/J,IAAQ2E,IAAI,SAAC8L,IAAQC,IAAAA;AAAK,eACvBC,cAAAA,eAACC,GAAiCvP,GAAAA,CAAAA,GAC1BoP,IAAM,EACVI,KAAKH,IACLI,gBAAgBrB,IAChBsB,iBAAiBpB,IACjB1K,OAAOiB,GAAAA,CAAAA,CAAAA;EAAAA,CAAAA,EAAAA,GAPL,SAAA,IAclBzH,GAAOuI,SAAS,aAAA,KAAkB/G,GAAY+D,SAAS,MACvDiM,GAAUhQ,kBACNQ,oBAAAA,KAACkM,IAAsB,EAEnBrJ,OAAOA,IACPrD,aAAaA,GAAAA,GAFT,aAAA;AAOhB,MAAM+Q,KAA4C,EAC9C1N,OAAAA,IACAgF,YAAAA,IACAC,eAAAA,GAAAA;AAGJ,aACI9H,oBAAAA,KAACwQ,IAAU,EACP9O,OAAOyN,IACPvN,QAAQwN,IACR1C,QAAQ+D,OAAOC,OAAO,CAAA,GAAIhE,IAAQ,EAC9B4C,KAAK5C,GAAO4C,KACZC,MAAM7C,GAAO6C,KAAAA,CAAAA,GAEjBf,MAAMA,IACNC,WAAWA,IACXC,gBAAgBA,IAChBC,iBAAiBA,IAAgBrF,UAEhCtL,GAAOkG,IAAI,SAACyM,IAAOtE,IAAAA;AAAM,QAAAuE;AACtB,WAAqB,cAAA,OAAVD,SACA3Q,oBAAAA,KAAC+P,cAAAA,UAAQ,EAAAzG,cAAUuC,cAAAA,eAAc8E,IAAOJ,EAAAA,EAAAA,GAAzBlE,EAAAA,IAGD,SAAzBuE,KAAOpB,QAAAA,KAAAA,SAAAA,GAAYmB,EAAAA,KAAMC,KAAI;EAAA,CAAA,EAAA,CAAA;AAI7C;ARlOA,IQoOaC,KAAU,SAAHrO,IAAAA;AAAA,MAAAsO,KAAAtO,GAIhB/C,eAAAA,KAAAA,WAAaqR,KAAGnQ,EAAgBlB,gBAAaqR,IAAAC,KAAAvO,GAC7C/B,SAAAA,KAAAA,WAAOsQ,KAAGpQ,EAAgBF,UAAOsQ,IAAAC,KAAAxO,GACjC9B,cAAAA,KAAAA,WAAYsQ,KAAGrQ,EAAgBD,eAAYsQ,IAC3CnL,KAAKrD,GAALqD,OACAoL,IAAazO,GAAbyO,eACGC,IAAUC,EAAA3O,IAAA4O,EAAAA;AAAA,aAEbpR,oBAAAA,KAACqR,IAAS,EAEF5Q,SAAAA,IACAhB,eAAAA,IACAiB,cAAAA,IACAuQ,eAAAA,GACApL,OAAAA,IAAKyD,cAGTtJ,oBAAAA,KAACuM,IAAY3L,GAAA,EAAoBnB,eAAeA,GAAAA,GAAmByR,CAAAA,CAAAA,EAAAA,CAAAA;AAC3D;ARzPhB,ISAaI,KAAoB,SAI7BC,IAAAA;AAAmE,aAEnEvR,oBAAAA,KAACwR,IAAiB,EAAAlI,UACb,SAAAzJ,IAAAA;AAAA,QAAG6B,KAAK7B,GAAL6B,OAAOE,KAAM/B,GAAN+B;AAAM,eACb5B,oBAAAA,KAAC6Q,IAAOjQ,GAAA,EAAoBc,OAAOA,IAAOE,QAAQA,GAAAA,GAAY2P,EAAAA,CAAAA;EAAS,EAAA,CAAA;AAE3D;ATVxB,IUFaE,KAAa,SACtBC,IAA6B7R,IAAAA;AAO5B,MAAA8R,KAAA9R,GALGC,MAAQO,KAACsR,GAADtR,GAAG8C,KAACwO,GAADxO,GAAGzB,KAAKiQ,GAALjQ,OAAOE,KAAM+P,GAAN/P,QAAQpB,KAAKmR,GAALnR,OAAO7B,IAAWgT,GAAXhT,aAAaJ,IAAOoT,GAAPpT,SAASW,IAAcyS,GAAdzS,gBAAgBD,IAAK0S,GAAL1S,OAC1EP,IAAWmB,GAAXnB,aACAM,KAAYa,GAAZb,cACA6G,IAAKhG,GAALgG;AAGJ6L,EAAAA,GAAIE,KAAAA,GACJF,GAAIG,cAActT,GAElBmT,GAAII,YAAYtR,IACZ9B,IAAc,MACdgT,GAAIK,cAAcpT,GAClB+S,GAAIM,YAAYtT,IAGpBgT,GAAIO,SAAS5R,KAAIqB,KAAQ,GAAGyB,KAAIvB,KAAS,GAAGF,IAAOE,EAAAA,GAC/ClD,IAAc,KACdgT,GAAIQ,WAAW7R,KAAIqB,KAAQ,GAAGyB,KAAIvB,KAAS,GAAGF,IAAOE,EAAAA,GAGrD5C,OACA0S,GAAII,YAAY5S,GAChBwS,GAAIS,QAAUtM,EAAMmE,OAAOH,KAAKuI,aAAgBvM,EAAMmE,OAAOH,KAAKuI,aAAU,MAAM,MAC9EvM,EAAMmE,OAAOH,KAAKwI,WAAQ,QACxBxM,EAAMmE,OAAOH,KAAKyI,YACxBZ,GAAIa,YAAY,UAChBb,GAAIc,eAAe,UACnBd,GAAIe,SAASxT,GAAOoB,IAAG8C,EAAAA,IAG3BuO,GAAIgB,QAAAA;AACR;AVhCA,IUkCaC,KAAe,SACxBjB,IAA6BlP,IAAAA;AAO5B,MAAAoQ,KAAApQ,GALG1C,MAAQO,KAACuS,GAADvS,GAAG8C,KAACyP,GAADzP,GAAGzB,KAAKkR,GAALlR,OAAOE,KAAMgR,GAANhR,QAAQpB,KAAKoS,GAALpS,OAAO7B,IAAWiU,GAAXjU,aAAaJ,IAAOqU,GAAPrU,SAASW,IAAc0T,GAAd1T,gBAAgBD,IAAK2T,GAAL3T,OAC1EP,IAAW8D,GAAX9D,aACAM,KAAYwD,GAAZxD,cACA6G,IAAKrD,GAALqD;AAGJ6L,EAAAA,GAAIE,KAAAA,GACJF,GAAIG,cAActT;AAElB,MAAMsU,KAAS3Q,KAAKI,IAAIZ,IAAOE,EAAAA,IAAU;AAEzC8P,EAAAA,GAAII,YAAYtR,IACZ9B,IAAc,MACdgT,GAAIK,cAAcpT,GAClB+S,GAAIM,YAAYtT,IAGpBgT,GAAIoB,UAAAA,GACJpB,GAAIqB,IAAI1S,IAAG8C,IAAG0P,IAAQ,GAAG,IAAI3Q,KAAK8Q,EAAAA,GAElCtB,GAAIlI,KAAAA,GACA9K,IAAc,KACdgT,GAAIjI,OAAAA,GAGJzK,OACA0S,GAAII,YAAY5S,GAChBwS,GAAIS,QAAUtM,EAAMmE,OAAOH,KAAKuI,aAAgBvM,EAAMmE,OAAOH,KAAKuI,aAAU,MAAM,MAC9EvM,EAAMmE,OAAOH,KAAKwI,WAAQ,QACxBxM,EAAMmE,OAAOH,KAAKyI,YACxBZ,GAAIa,YAAY,UAChBb,GAAIc,eAAe,UACnBd,GAAIe,SAASxT,GAAOoB,IAAG8C,EAAAA,IAG3BuO,GAAIgB,QAAAA;AACR;AVzEA,IUyEA,KAAA,CAAA,SAAA,iBAAA,WAAA,gBAAA,eAAA;AVzEA,IWoBMO,KAAqB,SAAHpT,IAAAA;AAyC0B,MA0D1CuB,IAlGJhB,KAAIP,GAAJO,MAAIoM,IAAA3M,GACJ7B,QAAAA,IAAAA,WAAMwO,IAAGrL,GAAmBnD,SAAMwO,GAClClH,IAAWzF,GAAXyF,aACA5D,IAAK7B,GAAL6B,OACAE,IAAM/B,GAAN+B,QACQ6K,KAAa5M,GAArB6M,QAAME,IAAA/M,GACN3B,eAAAA,KAAAA,WAAa0O,IAAGzL,GAAmBjD,gBAAa0O,GAAAC,KAAAhN,GAChD1B,eAAAA,KAAAA,WAAa0O,KAAG1L,GAAmBhD,gBAAa0O,IAAAC,KAAAjN,GAChDzB,eAAAA,KAAAA,WAAa0O,KAAG3L,GAAmB/C,gBAAa0O,IAAAC,KAAAlN,GAChDxB,eAAAA,KAAAA,WAAa0O,KAAG5L,GAAmB9C,gBAAa0O,IAAAJ,KAAA9M,GAChD5B,aAAAA,KAAAA,WAAW0O,KAAGxL,GAAmBlD,cAAW0O,IAAAK,KAAAnN,GAC5CvB,eAAAA,KAAAA,WAAa0O,KAAG7L,GAAmB7C,gBAAa0O,IAAAkG,KAAArT,GAChDuB,YAAY+R,KAAAA,WAAWD,KAAG/R,GAAmBC,aAAU8R,IAAAhG,IAAArN,GACvDtB,SAAAA,KAAAA,WAAO2O,IAAG/L,GAAmB5C,UAAO2O,GAAAC,KAAAtN,GACpCrB,eAAAA,KAAAA,WAAa2O,KAAGhM,GAAmB3C,gBAAa2O,IAAAC,KAAAvN,GAChDpB,iBAAAA,KAAAA,WAAe2O,KAAGjM,GAAmB1C,kBAAe2O,IAAAE,KAAAzN,GACpDnB,aAAAA,KAAAA,WAAW4O,KAAGnM,GAAmBzC,cAAW4O,IAAAC,KAAA1N,GAC5ClB,aAAAA,KAAAA,WAAW4O,KAAGpM,GAAmBxC,cAAW4O,IAAAC,KAAA3N,GAC5Cf,aAAAA,KAAAA,WAAW0O,KAAGrM,GAAmBrC,cAAW0O,IAAAC,KAAA5N,GAC5Cd,aAAAA,MAAAA,WAAW0O,KAAGtM,GAAmBpC,cAAW0O,IAAAC,MAAA7N,GAC5CgB,SAAAA,MAAAA,WAAO6M,MAAGvM,GAAmBN,UAAO6M,KAAAC,MAAA9N,GACpCiB,WAAAA,MAAAA,WAAS6M,MAAGxM,GAAmBL,YAAS6M,KAAAC,MAAA/N,GACxCkB,YAAAA,MAAAA,WAAU6M,MAAGzM,GAAmBJ,aAAU6M,KAAAC,MAAAhO,GAC1CmB,UAAAA,MAAAA,WAAQ6M,MAAG1M,GAAmBH,WAAQ6M,KAAAC,MAAAjO,GACtCb,cAAAA,MAAAA,WAAY8O,MAAG3M,GAAmBnC,eAAY8O,KAAAC,MAAAlO,GAC9CZ,OAAAA,MAAAA,WAAK8O,MAAG5M,GAAmBlC,QAAK8O,KAAAC,MAAAnO,GAChCX,gBAAAA,MAAAA,WAAc8O,MAAG7M,GAAmBjC,iBAAc8O,KAAAC,KAAApO,GAClDV,QAAAA,KAAAA,WAAM8O,KAAG9M,GAAmBhC,SAAM8O,IAAAC,KAAArO,GAClCP,YAAAA,KAAAA,WAAU4O,KAAG/M,GAAmB7B,aAAU4O,IAAAC,KAAAtO,GAC1CN,SAAAA,KAAAA,WAAO4O,KAAGhN,GAAmB5B,UAAO4O,IAAAC,KAAAvO,GACpCL,aAAAA,KAAAA,WAAW4O,KAAGjN,GAAmB3B,cAAW4O,IAAAC,KAAAxO,GAC5CJ,eAAAA,KAAAA,WAAa4O,KAAGlN,GAAmB1B,gBAAa4O,IAChDzF,KAAO/I,GAAP+I,SAAO0F,KAAAzO,GACPH,aAAAA,KAAAA,WAAW4O,KAAGnN,GAAmBzB,cAAW4O,IAAAC,KAAA1O,GAC5CF,SAAAA,KAAAA,WAAO4O,KAAGpN,GAAmBxB,UAAO4O,IACpCC,KAAI3O,GAAJ2O,MACAC,KAAS5O,GAAT4O,WACAC,KAAc7O,GAAd6O,gBACAC,KAAe9O,GAAf8O,iBAAeyE,KAAAvT,GACfwB,YAAAA,KAAAA,WAAU+R,KAAGjS,GAAmBE,aAAU+R,IAEpCC,UAAWC,cAAAA,QAAiC,IAAA,GAElD1E,KAMIC,GAAcnN,GAAOE,GAAQ6K,EAAAA,GALrBqC,KAAOF,GAAflC,QACYqC,KAAWH,GAAvBI,YACaC,KAAYL,GAAzBM,aACAC,KAAUP,GAAVO,YACAC,KAAWR,GAAXQ,aAGJC,KAWI3I,GAA8B,EAC9BtG,MAAAA,IACAkF,aAAAA,GACA5D,OAAOqN,IACPnN,QAAQqN,IACR/Q,eAAAA,IACAC,eAAAA,IACAC,eAAAA,IACAC,eAAAA,IACAJ,aAAAA,IACAK,eAAAA,IACAa,QAAAA,IACAG,YAAAA,IACAf,SAAAA,IACAC,eAAAA,IACAC,iBAAAA,IACAE,aAAAA,IACAM,OAAAA,KACAC,gBAAAA,KACAQ,aAAAA,GAAAA,CAAAA,GA7BOsP,KAAUK,GAAjB3N,OACQwN,KAAWG,GAAnBzN,QACAG,KAAOsN,GAAPtN,SACAC,KAAOqN,GAAPrN,SACAwB,KAAM6L,GAAN7L,QACAO,KAAMsL,GAANtL,QACAlB,KAAKwM,GAALxM,OACA4C,KAAU4J,GAAV5J,YACAoC,KAAUwH,GAAVxH,YACAC,KAAauH,GAAbvH,eAuBE4E,SAAS3H,cAAAA,SACX,WAAA;AAAA,WAAAnE,GAAAA,CAAAA,GACOkO,IAAO,EACVQ,KAAKR,GAAQQ,MAAMtN,IACnBuN,MAAMT,GAAQS,OAAOxN,GAAAA,CAAAA;EACvB,GACF,CAAC+M,IAAS/M,IAASC,EAAAA,CAAAA,GAGjBmK,KAAmBhE,GAAmBtF,IAAOrD,EAAAA,GAC7C+T,KAAsBC,GAAuB,EAC/ChU,aAAa2M,GAAAA,CAAAA;AAKb/K,EAAAA,KADuB,cAAA,OAAhB+R,KACMA,KACU,aAAhBA,KACMR,KAEAlB;AAGjB,MAAM5L,KAAQC,GAAAA,GAERyK,SAA4CxL,cAAAA,SAC9C,WAAA;AAAA,WAAO,EACHlC,OAAAA,IACAgF,YAAAA,IACAC,eAAAA,GAAAA;EACF,GACF,CAACjF,IAAOgF,IAAYC,EAAAA,CAAAA;AAGxB2L,oBAAAA,WAAU,WAAA;AACN,QAAyB,SAArBJ,IAASpO,SAAb;AAEA,UAAMyM,KAAM2B,IAASpO,QAAQyO,WAAW,IAAA;AACnChC,MAAAA,OAEL2B,IAASpO,QAAQvD,QAAQyN,KAAa9N,IACtCgS,IAASpO,QAAQrD,SAASwN,KAAc/N,IAExCqQ,GAAIlN,MAAMnD,IAAYA,EAAAA,GAEtBqQ,GAAII,YAAYjM,GAAM8N,YACtBjC,GAAIO,SAAS,GAAG,GAAG9C,IAAYC,EAAAA,GAC/BsC,GAAIkC,UAAUlH,GAAO6C,MAAM7C,GAAO4C,GAAAA,GAElCtR,EAAO8E,QAAQ,SAAA6N,IAAAA;AACG,mBAAVA,MACAe,GAAIM,YAAYnM,GAAM4J,KAAKoE,KAAKnK,aAChCgI,GAAIK,cAAclM,GAAM4J,KAAKoE,KAAKpK,QAE9B3K,MACAgV,EAAwBpC,IAAK,EACzBhQ,OAAOsN,IACPpN,QAAQsN,IACR1K,OAAOhB,IACPuQ,MAAM,IAAA,CAAA,GAGVhV,OACA+U,EAAwBpC,IAAK,EACzBhQ,OAAOsN,IACPpN,QAAQsN,IACR1K,OAAOT,IACPgQ,MAAM,IAAA,CAAA,KAGG,WAAVpD,KACPqD,EAAmBtC,IAAK,EACpBlO,QAAAA,IACAO,QAAAA,IACArC,OAAOsN,IACPpN,QAAQsN,IACRI,KAAKzO,KACLgP,OAAO/O,KACPgP,QAAQ/O,KACRwO,MAAMvO,KACN6E,OAAAA,GAAAA,CAAAA,IAEa,YAAV8K,MACPe,GAAIa,YAAY,UAChBb,GAAIc,eAAe,UAEnB3P,GAAMC,QAAQ,SAAAhD,IAAAA;AACVsB,UAAAA,GAAWsQ,IAAK,EAAE5R,MAAAA,IAAMpB,aAAAA,IAAaM,cAAAA,KAAc6G,OAAAA,GAAAA,CAAAA;QACvD,CAAA,KACiB,cAAV8K,MAAsC,SAAflL,KAC9BlG,GAAQuD,QAAQ,SAAAkN,IAAAA;AACZiE,YAAoCvC,IAAG9Q,GAAAA,CAAAA,GAChCoP,IAAM,EACTK,gBAAgBrB,IAChBsB,iBAAiBpB,IACjB1K,OAAOiB,IACPI,OAAAA,GAAAA,CAAAA,CAAAA;QAER,CAAA,IACiB,kBAAV8K,KACPuD,GAA0BxC,IAAK,EAC3BlS,aAAa+T,IACb1N,OAAAA,GAAAA,CAAAA,IAEoB,cAAA,OAAV8K,MACdA,GAAMe,IAAKnB,EAAAA;MAEnB,CAAA;IAxE+B;EAyElC,GAAE,CACC8C,KACAhS,IACA8N,IACAC,IACAJ,IACAE,IACAxC,IACA1O,GACAuS,IACA1N,IACAzB,IACAtC,IACAC,KACA8B,KACAC,KACAC,KACAC,KACAwC,IACAO,IACA8B,IACAnH,IACAM,KACAyG,IACAlG,IACAgU,EAAAA,CAAAA;AAGJ,MAAAhI,KAA8CC,EAAAA,GAAtCC,KAAoBF,GAApBE,sBAAsBC,KAAWH,GAAXG,aAExByI,SAAmBvO,cAAAA,aACrB,SAACgG,IAAAA;AACG,QAAyB,SAArByH,IAASpO,SAAb;AAEA,UAAAmP,KAAeC,GAAkBhB,IAASpO,SAAS2G,EAAAA,GAA5CvL,KAAC+T,GAAA,CAAA,GAAEjR,KAACiR,GAAA,CAAA,GAELtU,KAAO+C,GAAMyR,KAAK,SAAAC,IAAAA;AAAC,eACrBC,GACID,GAAElU,IAAIqM,GAAO6C,OAAOgF,GAAE7S,QAAQ,GAC9B6S,GAAEpR,IAAIuJ,GAAO4C,MAAMiF,GAAE3S,SAAS,GAC9B2S,GAAE7S,OACF6S,GAAE3S,QACFvB,IACA8C,EAAAA;MACH,CAAA;AAAA,iBAEDrD,MACAgI,GAAchI,EAAAA,GACd2L,OAAqBI,cAAAA,eAAclM,IAAS,EAAEG,MAAAA,GAAAA,CAAAA,GAAS8L,EAAAA,MAEvD9D,GAAc,IAAA,GACd4D,GAAAA;IAnB2B;EAqBnC,GACA,CACI2H,KACAxQ,IACA6J,IAGA5E,IACA2D,IACAC,IACA/L,EAAAA,CAAAA,GAIFoM,SAAmBnG,cAAAA,aAAY,WAAA;AACjCkC,OAAc,IAAA,GACd4D,GAAAA;EACJ,GAAG,CAAC5D,IAAe4D,EAAAA,CAAAA,GAEbM,SAAcpG,cAAAA,aAChB,SAACgG,IAAAA;AACsB,aAAf/D,OAAAA,QAEJe,MAAAA,GAAUf,IAAY+D,EAAAA;EAC1B,GACA,CAAC/D,IAAYe,EAAAA,CAAAA;AAGjB,aACI5I,oBAAAA,KAAA,UAAA,EACIyU,KAAKpB,KACL3R,OAAOyN,KAAa9N,IACpBO,QAAQwN,KAAc/N,IACtB6H,OAAO,EACHxH,OAAOyN,IACPvN,QAAQwN,GAAAA,GAEZ3G,cAAchJ,KAAgB0U,KAAAA,QAC9BzL,aAAajJ,KAAgB0U,KAAAA,QAC7BxL,cAAclJ,KAAgBsM,KAAAA,QAC9BnD,SAASnJ,KAAgBuM,KAAAA,QACzBwC,MAAMA,IACN,cAAYC,IACZ,mBAAiBC,IACjB,oBAAkBC,GAAAA,CAAAA;AAG9B;AXzTA,IW2Ta+F,KAAgB,SAAHlS,IAAAA;AAAA,MAItBqD,KAAKrD,GAALqD,OAAKiL,KAAAtO,GACL/C,eAAAA,KAAAA,WAAaqR,KAAG3P,GAAmB1B,gBAAaqR,IAAAC,KAAAvO,GAChD/B,SAAAA,KAAAA,WAAOsQ,KAAG5P,GAAmBV,UAAOsQ,IAAAC,KAAAxO,GACpC9B,cAAAA,KAAAA,WAAYsQ,KAAG7P,GAAmBT,eAAYsQ,IAC9CC,IAAazO,GAAbyO,eACGC,IAAUC,EAAA3O,IAAA4O,EAAAA;AAAA,aAEbpR,oBAAAA,KAACqR,IAAS,EAAO5R,eAAAA,IAAegB,SAAAA,IAASC,cAAAA,IAAcmF,OAAAA,IAAOoL,eAAAA,GAAa3H,cACvEtJ,oBAAAA,KAACiT,IAAkBrS,GAAA,EAAoBnB,eAAeA,GAAAA,GAAmByR,CAAAA,CAAAA,EAAAA,CAAAA;AACjE;AXxUhB,IYAayD,KAA0B,SAInCpD,IAAAA;AAAsE,aAEtEvR,oBAAAA,KAACwR,IAAiB,EAAAlI,UACb,SAAAzJ,IAAAA;AAAA,QAAG6B,KAAK7B,GAAL6B,OAAOE,KAAM/B,GAAN+B;AAAM,eACb5B,oBAAAA,KAAC0U,IAAa9T,GAAA,EAAoBc,OAAOA,IAAOE,QAAQA,GAAAA,GAAY2P,EAAAA,CAAAA;EAAS,EAAA,CAAA;AAEjE;",
  "names": ["collection", "x", "p", "i", "x", "i", "t", "j", "g", "i", "n", "i", "x", "p", "i", "n", "x", "p", "x", "p", "x", "locale", "format", "i", "n", "formatPrefix", "e", "k", "value", "precisionCutOffs", "date", "setMilliseconds", "setSeconds", "setMinutes", "setHours", "setDate", "setMonth", "precisionCutOffsByType", "millisecond", "second", "slice", "minute", "hour", "day", "month", "year", "castBandScale", "scale", "typedScale", "type", "centerScale", "scale", "bandwidth", "offset", "round", "Math", "d", "_scale", "timeByType", "millisecond", "timeMillisecond", "utcMillisecond", "second", "timeSecond", "utcSecond", "minute", "timeMinute", "utcMinute", "hour", "timeHour", "utcHour", "day", "timeInterval", "date", "setHours", "step", "setDate", "getDate", "start", "end", "getTime", "floor", "setUTCHours", "setUTCDate", "getUTCDate", "week", "timeWeek", "utcWeek", "sunday", "timeSunday", "utcSunday", "monday", "timeMonday", "utcMonday", "tuesday", "timeTuesday", "utcTuesday", "wednesday", "timeWednesday", "utcWednesday", "thursday", "timeThursday", "utcThursday", "friday", "timeFriday", "utcFriday", "saturday", "timeSaturday", "utcSaturday", "month", "timeMonth", "utcMonth", "year", "timeYear", "utcYear", "timeTypes", "Object", "keys", "timeIntervalRegexp", "RegExp", "join", "getScaleTicks", "spec", "Array", "isArray", "matches", "match", "amount", "type", "timeType", "useUTC", "_timeType$every$range", "_timeType$every", "_scale$domain", "domain", "originalStop", "stop", "Date", "every", "Number", "range", "ticks", "interval", "Error", "value", "isFinite", "computeCartesianTicks", "_ref", "translate", "axis", "scale", "ticksPosition", "tickValues", "tickSize", "tickPadding", "tickRotation", "truncateTickAt", "_ref$engine", "engine", "values", "getScaleTicks", "textProps", "textPropsByEngine", "position", "centerScale", "line", "lineX", "lineY", "text", "textX", "textY", "isRTL", "document", "dir", "textAlign", "align", "center", "textBaseline", "baseline", "d", "_position", "x", "y", "top", "bottom", "_position2", "left", "right", "ticks", "map", "value", "processedValue", "valueLength", "String", "length", "slice", "concat", "_extends", "key", "Date", "valueOf", "getFormatter", "format", "type", "formatter", "timeFormat", "d3Format", "computeGridLines", "_ref2", "width", "height", "_values", "Array", "isArray", "lines", "_position3", "_position4", "x1", "x2", "y1", "y2", "_position5", "_position6", "memoizedAxisTick", "memo", "_format", "_value", "onClick", "textAnchor", "animatedProps", "theme", "useTheme", "lineStyle", "textStyle", "props", "useMemo", "style", "opacity", "cursor", "event", "_jsxs", "animated", "g", "transform", "children", "_jsx", "outlineWidth", "dominantBaseline", "textTransform", "strokeWidth", "stroke", "outlineColor", "strokeLinejoin", "sanitizeSvgTextStyle", "NonMemoizedAxis", "_ref$x", "_ref$y", "_ref$tickSize", "_ref$tickPadding", "_ref$tickRotation", "_ref$renderTick", "renderTick", "AxisTick", "legend", "_ref$legendPosition", "legendPosition", "_ref$legendOffset", "legendOffset", "ariaHidden", "legendTextStyle", "formatValue", "_computeCartesianTick", "legendNode", "legendX", "legendY", "legendRotation", "_Fragment", "_useMotionConfig", "useMotionConfig", "animate", "springConfig", "config", "useSpring", "lineX2", "lineY2", "immediate", "getAnimatedProps", "useCallback", "tick", "getFromAnimatedProps", "transition", "useTransition", "keys", "initial", "from", "enter", "update", "leave", "transitionProps", "_state", "tickIndex", "createElement", "rotate", "domain", "Axis", "positions", "Axes", "xScale", "yScale", "axes", "isXAxis", "GridLine", "grid", "GridLines", "_createElement", "Grid", "xValues", "yValues", "xLines", "yLines", "renderAxisToCanvas", "ctx", "_theme$axis$domain$li", "save", "font", "fontWeight", "fontSize", "fontFamily", "lineWidth", "Number", "lineCap", "strokeStyle", "beginPath", "moveTo", "lineTo", "forEach", "_theme$axis$ticks$lin", "degreesToRadians", "lineJoin", "strokeText", "fill", "fillStyle", "fillText", "restore", "renderAxesToCanvas", "renderGridLinesToCanvas", "_ref3", "defaultProps", "dotSize", "noteWidth", "noteTextOffset", "animate", "isSvgNote", "note", "noteType", "isValidElement", "isCanvasNote", "isCircleAnnotation", "annotationSpec", "type", "isDotAnnotation", "isRectAnnotation", "bindAnnotations", "_ref", "data", "annotations", "getPosition", "getDimensions", "reduce", "acc", "annotation", "offset", "concat", "filter", "match", "map", "datum", "position", "dimensions", "size", "width", "height", "_extends", "omit", "getLinkAngle", "sourceX", "sourceY", "targetX", "targetY", "angle", "Math", "atan2", "absoluteAngleDegrees", "radiansToDegrees", "computeAnnotation", "computedNoteX", "computedNoteY", "x", "y", "noteX", "noteY", "_annotation$noteWidth", "_annotation$noteTextO", "isNumber", "abs", "Error", "computedX", "computedY", "positionFromAngle", "degreesToRadians", "eighth", "round", "textX", "noteLineX", "points", "text", "useAnnotations", "useMemo", "useComputedAnnotations", "_ref2", "computed", "useComputedAnnotation", "AnnotationNote", "theme", "useTheme", "_useMotionConfig", "useMotionConfig", "springConfig", "config", "animatedProps", "useSpring", "immediate", "createElement", "_jsxs", "_Fragment", "children", "outlineWidth", "_jsx", "animated", "style", "strokeLinejoin", "strokeWidth", "stroke", "outlineColor", "AnnotationLink", "_ref$isOutline", "isOutline", "path", "firstPoint", "slice", "animatedPath", "useAnimatedPath", "link", "strokeLinecap", "opacity", "outlineOpacity", "fill", "d", "CircleAnnotationOutline", "radius", "outline", "circle", "cx", "cy", "r", "DotAnnotationOutline", "_ref$size", "symbol", "RectAnnotationOutline", "_ref$borderRadius", "borderRadius", "rect", "rx", "ry", "Annotation", "drawPoints", "ctx", "forEach", "index", "moveTo", "lineTo", "renderAnnotationsToCanvas", "length", "save", "lineCap", "strokeStyle", "lineWidth", "beginPath", "arc", "PI", "fillStyle", "font", "fontSize", "fontFamily", "textAlign", "textBaseline", "lineJoin", "strokeText", "fillText", "restore", "commonDefaultProps", "layers", "forceSquare", "xInnerPadding", "xOuterPadding", "yInnerPadding", "yOuterPadding", "sizeVariation", "opacity", "activeOpacity", "inactiveOpacity", "borderWidth", "borderColor", "from", "modifiers", "enableGridX", "enableGridY", "enableLabels", "label", "labelTextColor", "colors", "type", "scheme", "emptyColor", "legends", "annotations", "isInteractive", "hoverTarget", "tooltip", "memo", "_ref", "cell", "formattedValue", "_jsx", "BasicTooltip", "id", "serieId", "data", "x", "value", "enableChip", "color", "animate", "motionConfig", "svgDefaultProps", "_extends", "axisTop", "axisRight", "axisBottom", "axisLeft", "borderRadius", "cellComponent", "canvasDefaultProps", "renderCell", "pixelRatio", "window", "devicePixelRatio", "computeLayout", "_width", "width", "_height", "height", "rows", "columns", "offsetX", "offsetY", "cellWidth", "Math", "max", "cellHeight", "cellSize", "min", "computeCells", "_ref2", "xValuesSet", "Set", "serieIds", "allValues", "cells", "forEach", "serie", "push", "datum", "add", "y", "xValues", "Array", "_computeLayout", "length", "xScale", "castBandScale", "scaleBand", "domain", "range", "paddingOuter", "paddingInner", "yScale", "bandwidth", "cellsWithPosition", "map", "minValue", "apply", "maxValue", "computeSizeScale", "size", "scale", "scaleLinear", "values", "sizes", "getCellAnnotationPosition", "getCellAnnotationDimensions", "useComputeCells", "useMemo", "isHoverTargetByType", "current", "row", "column", "rowColumn", "useCellsStyle", "valueFormat", "activeIds", "getSize", "colorScale", "getContinuousColorScale", "getColor", "useCallback", "theme", "useTheme", "getBorderColor", "useInheritedColor", "getLabelTextColor", "formatValue", "useValueFormatter", "getLabel", "usePropertyAccessor", "computedOpacity", "includes", "sizeMultiplier", "computedCell", "useHeatMap", "_ref3", "_ref3$xOuterPadding", "_ref3$xInnerPadding", "_ref3$yOuterPadding", "_ref3$yInnerPadding", "_ref3$forceSquare", "_ref3$sizeVariation", "_ref3$colors", "_ref3$emptyColor", "_ref3$opacity", "_ref3$activeOpacity", "_ref3$inactiveOpacity", "_ref3$borderColor", "_ref3$label", "_ref3$labelTextColor", "_ref3$hoverTarget", "_useState", "useState", "activeCell", "setActiveCell", "_useComputeCells", "isHoverTarget", "filter", "_useCellsStyle", "useCellAnnotations", "useAnnotations", "getPosition", "getDimensions", "HeatMapCellRect", "animatedProps", "onMouseEnter", "onMouseMove", "onMouseLeave", "onClick", "handlers", "undefined", "_jsxs", "animated", "g", "style", "cursor", "transform", "to", "children", "rect", "fill", "stroke", "strokeWidth", "rx", "ry", "text", "textAnchor", "dominantBaseline", "labels", "userSelect", "HeatMapCellCircle", "circle", "r", "fillOpacity", "enterTransition", "regularTransition", "exitTransition", "HeatMapCells", "Cell", "_useMotionConfig", "useMotionConfig", "springConfig", "config", "transition", "useTransition", "keys", "initial", "enter", "update", "leave", "immediate", "_useTooltip", "useTooltip", "showTooltipFromEvent", "hideTooltip", "handleMouseEnter", "event", "createElement", "handleMouseMove", "handleMouseLeave", "handleClick", "_Fragment", "HeatMapCellAnnotations", "boundAnnotations", "annotation", "i", "Annotation", "InnerHeatMap", "_ref$layers", "partialMargin", "margin", "_ref$forceSquare", "_ref$xInnerPadding", "_ref$xOuterPadding", "_ref$yInnerPadding", "_ref$yOuterPadding", "_ref$sizeVariation", "_ref$cellComponent", "_ref$opacity", "_ref$activeOpacity", "_ref$inactiveOpacity", "_ref$borderRadius", "_ref$borderWidth", "_ref$borderColor", "_ref$enableGridX", "_ref$enableGridY", "_ref$axisTop", "_ref$axisRight", "_ref$axisBottom", "_ref$axisLeft", "_ref$enableLabels", "_ref$label", "_ref$labelTextColor", "_ref$colors", "_ref$emptyColor", "_ref$legends", "_ref$annotations", "_ref$isInteractive", "_ref$hoverTarget", "_ref$tooltip", "role", "ariaLabel", "ariaLabelledBy", "ariaDescribedBy", "_useDimensions", "useDimensions", "_margin", "_innerWidth", "innerWidth", "_innerHeight", "innerHeight", "outerWidth", "outerHeight", "_useHeatMap", "top", "left", "layerById", "grid", "axes", "Grid", "Axes", "right", "bottom", "Fragment", "legend", "index", "_createElement", "AnchoredContinuousColorsLegendSvg", "key", "containerWidth", "containerHeight", "customLayerProps", "SvgWrapper", "Object", "assign", "layer", "_layerById$layer", "HeatMap", "_ref2$isInteractive", "_ref2$animate", "_ref2$motionConfig", "renderWrapper", "otherProps", "_objectWithoutPropertiesLoose", "_excluded", "Container", "ResponsiveHeatMap", "props", "ResponsiveWrapper", "renderRect", "ctx", "_ref$cell", "save", "globalAlpha", "fillStyle", "strokeStyle", "lineWidth", "fillRect", "strokeRect", "font", "fontWeight", "fontSize", "fontFamily", "textAlign", "textBaseline", "fillText", "restore", "renderCircle", "_ref2$cell", "radius", "beginPath", "arc", "PI", "InnerHeatMapCanvas", "_ref$renderCell", "_renderCell", "_ref$pixelRatio", "canvasEl", "useRef", "computedAnnotations", "useComputedAnnotations", "useEffect", "getContext", "background", "translate", "line", "renderGridLinesToCanvas", "axis", "renderAxesToCanvas", "renderContinuousColorLegendToCanvas", "renderAnnotationsToCanvas", "handleMouseHover", "_getRelativeCursor", "getRelativeCursor", "find", "c", "isCursorInRect", "ref", "HeatMapCanvas", "ResponsiveHeatMapCanvas"]
}
