import {
  require_prop_types
} from "./chunk-FUOYWSSY.js";
import {
  require_react
} from "./chunk-OU5AQDZK.js";
import {
  __commonJS
} from "./chunk-EWTE5DHJ.js";

// node_modules/@ckeditor/ckeditor5-react/dist/index.js
var require_dist = __commonJS({
  "node_modules/@ckeditor/ckeditor5-react/dist/index.js"(exports, module) {
    !function(t, e) {
      "object" == typeof exports && "object" == typeof module ? module.exports = e(require_react(), require_prop_types()) : "function" == typeof define && define.amd ? define(["react", "prop-types"], e) : "object" == typeof exports ? exports.CKEditor = e(require_react(), require_prop_types()) : t.CKEditor = e(t.react, t["prop-types"]);
    }(self, (t, e) => (() => {
      "use strict";
      var o = { 949: (t2) => {
        t2.exports = e;
      }, 155: (e2) => {
        e2.exports = t;
      } }, r = {};
      function n(t2) {
        var e2 = r[t2];
        if (void 0 !== e2) return e2.exports;
        var a2 = r[t2] = { exports: {} };
        return o[t2](a2, a2.exports, n), a2.exports;
      }
      n.n = (t2) => {
        var e2 = t2 && t2.__esModule ? () => t2.default : () => t2;
        return n.d(e2, { a: e2 }), e2;
      }, n.d = (t2, e2) => {
        for (var o2 in e2) n.o(e2, o2) && !n.o(t2, o2) && Object.defineProperty(t2, o2, { enumerable: true, get: e2[o2] });
      }, n.o = (t2, e2) => Object.prototype.hasOwnProperty.call(t2, e2), n.r = (t2) => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t2, "__esModule", { value: true });
      };
      var a = {};
      return (() => {
        n.r(a), n.d(a, { CKEditor: () => l, CKEditorContext: () => c, useMultiRootEditor: () => R });
        var t2 = n(155), e2 = n.n(t2), o2 = n(949), r2 = n.n(o2);
        const i = new Array(256).fill("").map((t3, e3) => ("0" + e3.toString(16)).slice(-2));
        const s = e2().createContext("contextWatchdog");
        class c extends e2().Component {
          constructor(t3, e3) {
            super(t3, e3), this.contextWatchdog = null, this.props.isLayoutReady && this._initializeContextWatchdog(this.props.config);
          }
          shouldComponentUpdate(t3) {
            return this._shouldComponentUpdate(t3);
          }
          async _shouldComponentUpdate(t3) {
            return t3.id !== this.props.id && (this.contextWatchdog && await this.contextWatchdog.destroy(), await this._initializeContextWatchdog(t3.config)), t3.isLayoutReady && !this.contextWatchdog ? (await this._initializeContextWatchdog(t3.config), true) : this.props.children !== t3.children;
          }
          render() {
            return e2().createElement(s.Provider, { value: this.contextWatchdog }, this.props.children);
          }
          componentWillUnmount() {
            this._destroyContext();
          }
          async _initializeContextWatchdog(t3) {
            this.contextWatchdog = new this.props.contextWatchdog(this.props.context, this.props.watchdogConfig), this.contextWatchdog.on("error", (t4, e3) => {
              this.props.onError(e3.error, { phase: "runtime", willContextRestart: e3.causesRestart });
            }), this.contextWatchdog.on("stateChange", () => {
              "ready" === this.contextWatchdog.state && this.props.onReady && this.props.onReady(this.contextWatchdog.context);
            }), await this.contextWatchdog.create(t3).catch((t4) => {
              this.props.onError(t4, { phase: "initialization", willContextRestart: false });
            });
          }
          async _destroyContext() {
            this.contextWatchdog && (await this.contextWatchdog.destroy(), this.contextWatchdog = null);
          }
        }
        c.defaultProps = { isLayoutReady: true, onError: (t3, e3) => console.error(t3, e3) }, c.propTypes = { id: r2().string, isLayoutReady: r2().bool, context: r2().func, watchdogConfig: r2().object, config: r2().object, onReady: r2().func, onError: r2().func };
        class u {
          constructor(t3, e3) {
            this._releaseLock = null, this._value = null, this._afterMountCallbacks = [], this._state = { destroyedBeforeInitialization: false, mountingInProgress: null }, this.release = /* @__PURE__ */ function(t4) {
              let e4 = null;
              return (...o3) => (e4 || (e4 = { current: t4(...o3) }), e4.current);
            }(() => {
              const { _releaseLock: t4, _state: e4, _element: o3, _lifecycle: r3 } = this;
              e4.mountingInProgress ? e4.mountingInProgress.then(() => r3.unmount({ element: o3, mountResult: this.value })).catch((t5) => {
                console.error("Semaphore unmounting error:", t5);
              }).then(t4.resolve).then(() => {
                this._value = null;
              }) : (e4.destroyedBeforeInitialization = true, t4.resolve());
            }), this._element = t3, this._lifecycle = e3, this._lock();
          }
          get value() {
            return this._value;
          }
          unsafeSetValue(t3) {
            this._value = t3, this._afterMountCallbacks.forEach((e3) => e3(t3)), this._afterMountCallbacks = [];
          }
          runAfterMount(t3) {
            const { _value: e3, _afterMountCallbacks: o3 } = this;
            e3 ? t3(e3) : o3.push(t3);
          }
          _lock() {
            const { _semaphores: t3 } = u, { _state: e3, _element: o3, _lifecycle: r3 } = this, n2 = t3.get(o3) || Promise.resolve(null), a2 = function() {
              const t4 = { resolve: null, promise: null };
              return t4.promise = new Promise((e4) => {
                t4.resolve = e4;
              }), t4;
            }();
            this._releaseLock = a2;
            const i2 = n2.then(() => e3.destroyedBeforeInitialization ? Promise.resolve(void 0) : (e3.mountingInProgress = r3.mount().then((t4) => (t4 && this.unsafeSetValue(t4), t4)), e3.mountingInProgress)).then(async (t4) => {
              t4 && r3.afterMount && await r3.afterMount({ element: o3, mountResult: t4 });
            }).then(() => a2.promise).catch((t4) => {
              console.error("Semaphore mounting error:", t4);
            }).then(() => {
              t3.get(o3) === i2 && t3.delete(o3);
            });
            t3.set(o3, i2);
          }
        }
        u._semaphores = /* @__PURE__ */ new Map();
        const d = "Lock from React integration (@ckeditor/ckeditor5-react)";
        class l extends e2().Component {
          constructor(t3) {
            super(t3), this.domContainer = e2().createRef(), this.editorSemaphore = null, this._checkVersion();
          }
          _checkVersion() {
            const { CKEDITOR_VERSION: t3 } = window;
            if (!t3) return console.warn('Cannot find the "CKEDITOR_VERSION" in the "window" scope.');
            const [e3] = t3.split(".").map(Number);
            e3 >= 42 || t3.startsWith("0.0.0") || console.warn("The <CKEditor> component requires using CKEditor 5 in version 42+ or nightly build.");
          }
          get _semaphoreValue() {
            const { editorSemaphore: t3 } = this;
            return t3 ? t3.value : null;
          }
          get watchdog() {
            const { _semaphoreValue: t3 } = this;
            return t3 ? t3.watchdog : null;
          }
          get editor() {
            const { _semaphoreValue: t3 } = this;
            return t3 ? t3.instance : null;
          }
          shouldComponentUpdate(t3) {
            const { props: e3, editorSemaphore: o3 } = this;
            return t3.id !== e3.id || (t3.disableWatchdog !== e3.disableWatchdog || (o3 && (o3.runAfterMount(({ instance: o4 }) => {
              this._shouldUpdateEditorData(e3, t3, o4) && o4.data.set(t3.data);
            }), "disabled" in t3 && o3.runAfterMount(({ instance: e4 }) => {
              t3.disabled ? e4.enableReadOnlyMode(d) : e4.disableReadOnlyMode(d);
            })), false));
          }
          componentDidMount() {
            this._initLifeCycleSemaphore();
          }
          componentDidUpdate() {
            this._initLifeCycleSemaphore();
          }
          componentWillUnmount() {
            this._unlockLifeCycleSemaphore();
          }
          _unlockLifeCycleSemaphore() {
            this.editorSemaphore && (this.editorSemaphore.release(), this.editorSemaphore = null);
          }
          _initLifeCycleSemaphore() {
            this._unlockLifeCycleSemaphore(), this.editorSemaphore = new u(this.domContainer.current, { mount: async () => this._initializeEditor(), afterMount: ({ mountResult: t3 }) => {
              const { onReady: e3 } = this.props;
              e3 && null !== this.domContainer.current && e3(t3.instance);
            }, unmount: async ({ element: t3, mountResult: e3 }) => {
              const { onAfterDestroy: o3 } = this.props;
              try {
                await this._destroyEditor(e3), t3.innerHTML = "";
              } finally {
                o3 && o3(e3.instance);
              }
            } });
          }
          render() {
            return e2().createElement("div", { ref: this.domContainer });
          }
          async _initializeEditor() {
            if (this.props.disableWatchdog) {
              return { instance: await this._createEditor(this.domContainer.current, this._getConfig()), watchdog: null };
            }
            const t3 = (() => this.context instanceof this.props.editor.ContextWatchdog ? new h(this.context) : new this.props.editor.EditorWatchdog(this.props.editor, this.props.watchdogConfig))(), e3 = { current: 0 };
            return t3.setCreator(async (o3, r3) => {
              const { editorSemaphore: n2 } = this, { onAfterDestroy: a2 } = this.props;
              e3.current > 0 && a2 && n2 && n2.value && n2.value.instance && a2(n2.value.instance);
              const i2 = await this._createEditor(o3, r3);
              return e3.current > 0 && (n2.unsafeSetValue({ instance: i2, watchdog: t3 }), setTimeout(() => {
                this.props.onReady && this.props.onReady(t3.editor);
              })), e3.current++, i2;
            }), t3.on("error", (t4, { error: e4, causesRestart: o3 }) => {
              (this.props.onError || console.error)(e4, { phase: "runtime", willEditorRestart: o3 });
            }), await t3.create(this.domContainer.current, this._getConfig()).catch((t4) => {
              (this.props.onError || console.error)(t4, { phase: "initialization", willEditorRestart: false });
            }), { watchdog: t3, instance: t3.editor };
          }
          _createEditor(t3, e3) {
            return this.props.editor.create(t3, e3).then((t4) => {
              "disabled" in this.props && this.props.disabled && t4.enableReadOnlyMode(d);
              const e4 = t4.model.document, o3 = t4.editing.view.document;
              return e4.on("change:data", (e5) => {
                this.props.onChange && this.props.onChange(e5, t4);
              }), o3.on("focus", (e5) => {
                this.props.onFocus && this.props.onFocus(e5, t4);
              }), o3.on("blur", (e5) => {
                this.props.onBlur && this.props.onBlur(e5, t4);
              }), t4;
            });
          }
          async _destroyEditor(t3) {
            const { watchdog: e3, instance: o3 } = t3;
            return new Promise((t4, r3) => {
              setTimeout(async () => {
                try {
                  if (e3) return await e3.destroy(), t4();
                  if (o3) return await o3.destroy(), t4();
                  t4();
                } catch (t5) {
                  console.error(t5), r3(t5);
                }
              });
            });
          }
          _shouldUpdateEditorData(t3, e3, o3) {
            return t3.data !== e3.data && o3.data.get() !== e3.data;
          }
          _getConfig() {
            const t3 = this.props.config || {};
            return this.props.data && t3.initialData && console.warn("Editor data should be provided either using `config.initialData` or `content` property. The config value takes precedence over `content` property and will be used when both are specified."), { ...t3, initialData: t3.initialData || this.props.data || "" };
          }
        }
        l.contextType = s, l.propTypes = { editor: r2().func.isRequired, data: r2().string, config: r2().object, disableWatchdog: r2().bool, watchdogConfig: r2().object, onChange: r2().func, onReady: r2().func, onFocus: r2().func, onBlur: r2().func, onError: r2().func, disabled: r2().bool, id: r2().any };
        class h {
          constructor(t3) {
            this._contextWatchdog = t3, this._id = function() {
              const t4 = 4294967296 * Math.random() >>> 0, e3 = 4294967296 * Math.random() >>> 0, o3 = 4294967296 * Math.random() >>> 0, r3 = 4294967296 * Math.random() >>> 0;
              return "e" + i[255 & t4] + i[t4 >> 8 & 255] + i[t4 >> 16 & 255] + i[t4 >> 24 & 255] + i[255 & e3] + i[e3 >> 8 & 255] + i[e3 >> 16 & 255] + i[e3 >> 24 & 255] + i[255 & o3] + i[o3 >> 8 & 255] + i[o3 >> 16 & 255] + i[o3 >> 24 & 255] + i[255 & r3] + i[r3 >> 8 & 255] + i[r3 >> 16 & 255] + i[r3 >> 24 & 255];
            }();
          }
          setCreator(t3) {
            this._creator = t3;
          }
          create(t3, e3) {
            return this._contextWatchdog.add({ sourceElementOrData: t3, config: e3, creator: this._creator, id: this._id, type: "editor" });
          }
          on(t3, e3) {
            this._contextWatchdog.on("itemError", (t4, { itemId: o3, error: r3 }) => {
              o3 === this._id && e3(null, { error: r3, causesRestart: void 0 });
            });
          }
          destroy() {
            return "ready" === this._contextWatchdog.state ? this._contextWatchdog.remove(this._id) : Promise.resolve();
          }
          get editor() {
            return this._contextWatchdog.getItem(this._id);
          }
        }
        function p(...t3) {
          return (e3) => {
            t3.forEach((t4) => {
              "function" == typeof t4 ? t4(e3) : null != t4 && (t4.current = e3);
            });
          };
        }
        function f(t3, e3) {
          for (const t4 of Object.getOwnPropertyNames(e3)) delete e3[t4];
          for (const [o3, r3] of Object.entries(t3)) r3 !== e3 && "prototype" !== o3 && "__proto__" !== o3 && (e3[o3] = r3);
          return e3;
        }
        const m = (e3) => {
          const o3 = (0, t2.useRef)();
          return o3.current = e3, (0, t2.useCallback)((...t3) => o3.current(...t3), []);
        };
        function g(t3, e3) {
          return e3.length = 0, e3.push(...t3), e3;
        }
        const y = (e3, o3, r3) => {
          ((e4, o4) => {
            const r4 = (0, t2.useRef)(null);
            ((t3, e5) => {
              if (t3 === e5) return true;
              if (!t3 || !e5) return false;
              for (let o5 = 0; o5 < t3.length; ++o5) if (t3[o5] !== e5[o5]) return false;
              return true;
            })(r4.current, o4) || (r4.current = [...o4], e4());
          })(() => {
            e3 && e3.runAfterMount(o3);
          }, [e3, ...r3]);
        }, b = "Lock from React integration (@ckeditor/ckeditor5-react)", w = (0, t2.memo)((0, t2.forwardRef)(({ id: o3, semaphore: r3, rootName: n2 }, a2) => {
          const i2 = (0, t2.useRef)(null);
          return (0, t2.useEffect)(() => {
            let t3, e3;
            return r3.runAfterMount(({ instance: o4 }) => {
              i2.current && (e3 = o4, t3 = o4.ui.view.createEditable(n2, i2.current), o4.ui.addEditable(t3), o4.editing.view.forceRender());
            }), () => {
              t3 && i2.current && e3 && "destroyed" !== e3.state && e3.ui.removeEditable(t3);
            };
          }, [r3.revision]), e2().createElement("div", { key: r3.revision, id: o3, ref: p(a2, i2) });
        }));
        w.displayName = "EditorEditable";
        const _ = (0, t2.forwardRef)(({ editor: o3 }, r3) => {
          const n2 = (0, t2.useRef)(null);
          return (0, t2.useEffect)(() => {
            const t3 = n2.current;
            if (!o3 || !t3) return;
            const e3 = o3.ui.view.toolbar.element;
            return t3 && t3.appendChild(e3), () => {
              t3 && t3.removeChild(e3);
            };
          }, [o3 && o3.id]), e2().createElement("div", { ref: p(n2, r3) });
        });
        _.displayName = "EditorToolbarWrapper";
        const R = (o3) => {
          const r3 = (0, t2.useRef)(o3.semaphoreElement || null), n2 = (() => {
            const e3 = (0, t2.useRef)(null), [o4, r4] = (0, t2.useState)(() => Date.now()), n3 = () => {
              r4(Date.now());
            }, a3 = (t3 = true) => {
              e3.current && (e3.current.release(), e3.current = null), t3 && r4(Date.now());
            }, i3 = (t3) => {
              e3.current && e3.current.runAfterMount(t3);
            };
            return { get current() {
              return e3.current;
            }, revision: o4, createAttributeRef: (t3) => ({ get current() {
              return e3.current && e3.current.value ? e3.current.value[t3] : null;
            } }), unsafeSetValue: (t3) => {
              var o5;
              null === (o5 = e3.current) || void 0 === o5 || o5.unsafeSetValue(t3), n3();
            }, release: a3, replace: (t3) => {
              a3(false), e3.current = t3(), n3(), i3(n3);
            }, runAfterMount: i3 };
          })(), a2 = { watchdog: n2.createAttributeRef("watchdog"), instance: n2.createAttributeRef("instance") }, i2 = (0, t2.useContext)(s), [c2, d2] = (0, t2.useState)(() => Object.keys(o3.data)), [l2, p2] = (0, t2.useState)({ ...o3.data }), [R2, C] = (0, t2.useState)({ ...o3.rootsAttributes }), v = (0, t2.useRef)(true);
          (0, t2.useEffect)(() => {
            const t3 = r3.current;
            if (t3 && false !== o3.isLayoutReady) return n2.replace(() => new u(t3, { mount: O, afterMount: ({ mountResult: t4 }) => {
              const { onReady: e3 } = o3;
              e3 && null !== r3.current && e3(t4.instance);
            }, unmount: async ({ element: t4, mountResult: e3 }) => {
              const { onAfterDestroy: r4 } = o3;
              try {
                await M(e3), t4.innerHTML = "";
              } finally {
                r4 && r4(e3.instance);
              }
            } })), () => {
              n2.release(false);
            };
          }, [o3.id, o3.isLayoutReady]);
          const E = () => {
            const t3 = o3.config || {};
            return o3.data && t3.initialData && console.warn("Editor data should be provided either using `config.initialData` or `data` property. The config value takes precedence over `data` property and will be used when both are specified."), { ...t3, rootsAttributes: R2 };
          }, x = m((t3, e3) => {
            const r4 = t3.model.document;
            if (!o3.disableTwoWayDataBinding) {
              const e4 = {}, o4 = {};
              r4.differ.getChanges().forEach((o5) => {
                let r5;
                if (r5 = "insert" == o5.type || "remove" == o5.type ? o5.position.root : o5.range.root, !r5.isAttached()) return;
                const { rootName: n3 } = r5;
                e4[n3] = t3.getData({ rootName: n3 });
              }), r4.differ.getChangedRoots().forEach((r5) => {
                if (r5.state) return void (void 0 !== e4[r5.name] && delete e4[r5.name]);
                const n3 = r5.name;
                o4[n3] = t3.getRootAttributes(n3);
              }), Object.keys(e4).length && p2((t4) => ({ ...t4, ...e4 })), Object.keys(o4).length && C((t4) => ({ ...t4, ...o4 }));
            }
            o3.onChange && o3.onChange(e3, t3);
          }), W = m((t3, e3, r4) => {
            const n3 = r4.rootName;
            o3.disableTwoWayDataBinding || (p2((e4) => ({ ...e4, [n3]: t3.getData({ rootName: n3 }) })), C((e4) => ({ ...e4, [n3]: t3.getRootAttributes(n3) }))), d2((t4) => {
              return e4 = [...t4, r4.rootName], Array.from(new Set(e4));
              var e4;
            });
          }), k = m((t3, e3, r4) => {
            const n3 = r4.rootName;
            o3.disableTwoWayDataBinding || (p2((t4) => {
              const { [n3]: e4, ...o4 } = t4;
              return { ...o4 };
            }), C((t4) => {
              const { [n3]: e4, ...o4 } = t4;
              return { ...o4 };
            })), d2((t4) => t4.filter((t5) => t5 !== n3));
          }), S = m((t3, e3) => (f({ ...o3.rootsAttributes }, R2), f({ ...o3.data }, l2), g(Object.keys(o3.data), c2), o3.editor.create(t3, e3).then((t4) => {
            const e4 = t4.getFullData();
            f({ ...e4 }, l2), f({ ...t4.getRootsAttributes() }, R2), g(Object.keys(e4), c2), o3.disabled && t4.enableReadOnlyMode(b);
            const r4 = t4.model.document, n3 = t4.editing.view.document;
            return r4.on("change:data", (e5) => x(t4, e5)), t4.on("addRoot", (e5, o4) => W(t4, e5, o4)), t4.on("detachRoot", (e5, o4) => k(t4, e5, o4)), n3.on("focus", (e5) => {
              o3.onFocus && o3.onFocus(e5, t4);
            }), n3.on("blur", (e5) => {
              o3.onBlur && o3.onBlur(e5, t4);
            }), t4;
          }))), M = (t3) => {
            const { watchdog: e3, instance: o4 } = t3;
            return new Promise((t4, r4) => {
              setTimeout(async () => {
                try {
                  if (e3) return await e3.destroy(), t4();
                  if (o4) return await o4.destroy(), t4();
                  t4();
                } catch (t5) {
                  console.error(t5), r4(t5);
                }
              });
            });
          }, O = async () => {
            if (o3.disableWatchdog) {
              return { instance: await S(o3.data, E()), watchdog: null };
            }
            const t3 = i2 instanceof o3.editor.ContextWatchdog ? new h(i2) : new o3.editor.EditorWatchdog(o3.editor, o3.watchdogConfig), e3 = { current: 0 };
            return t3.setCreator(async (r4, i3) => {
              const { onAfterDestroy: s2 } = o3;
              e3.current > 0 && s2 && a2.instance.current && s2(a2.instance.current);
              const c3 = await S(r4, i3);
              return e3.current > 0 && (n2.unsafeSetValue({ instance: c3, watchdog: t3 }), setTimeout(() => {
                o3.onReady && o3.onReady(t3.editor);
              })), e3.current++, c3;
            }), t3.on("error", (t4, { error: e4, causesRestart: r4 }) => {
              (o3.onError || console.error)(e4, { phase: "runtime", willEditorRestart: r4 });
            }), await t3.create(l2, E()).catch((t4) => {
              throw (o3.onError || console.error)(t4, { phase: "initialization", willEditorRestart: false }), t4;
            }), { watchdog: t3, instance: t3.editor };
          }, A = (0, t2.useCallback)((t3) => {
            n2.runAfterMount(() => {
              v.current = true, p2(t3);
            });
          }, [p2]), D = (0, t2.useCallback)((t3) => {
            n2.runAfterMount(() => {
              v.current = true, C(t3);
            });
          }, [C]), j = e2().createElement(_, { ref: r3, editor: a2.instance.current });
          y(n2.current, ({ instance: t3 }) => {
            o3.disabled ? t3.enableReadOnlyMode(b) : t3.disableReadOnlyMode(b);
          }, [o3.disabled]), y(n2.current, ({ instance: t3 }) => {
            if (v.current) {
              v.current = false;
              const e3 = Object.keys(l2), o4 = Object.keys(R2);
              if (!e3.every((t4) => o4.includes(t4))) throw console.error("`data` and `attributes` objects must have the same keys (roots)."), new Error("`data` and `attributes` objects must have the same keys (roots).");
              const r4 = t3.getFullData(), n3 = t3.getRootsAttributes(), { addedKeys: a3, removedKeys: i3 } = ((t4, e4) => {
                const o5 = Object.keys(t4), r5 = Object.keys(e4);
                return { addedKeys: r5.filter((t5) => !o5.includes(t5)), removedKeys: o5.filter((t5) => !r5.includes(t5)) };
              })(r4, l2 || {}), s2 = e3.some((t4) => void 0 !== r4[t4] && JSON.stringify(r4[t4]) !== JSON.stringify(l2[t4])), c3 = o4.filter((t4) => JSON.stringify(n3[t4]) !== JSON.stringify(R2[t4])), u2 = (e4) => {
                e4.forEach((e5) => {
                  t3.addRoot(e5, { data: l2[e5] || "", attributes: (null == R2 ? void 0 : R2[e5]) || {}, isUndoable: true });
                });
              }, d3 = (e4) => {
                e4.forEach((e5) => {
                  t3.detachRoot(e5, true);
                });
              }, h2 = () => {
                t3.data.set(l2, { suppressErrorInCollaboration: true });
              }, p3 = (e4, o5) => {
                o5.forEach((o6) => {
                  Object.keys(R2[o6]).forEach((e5) => {
                    t3.registerRootAttribute(e5);
                  }), e4.clearAttributes(t3.model.document.getRoot(o6)), e4.setAttributes(R2[o6], t3.model.document.getRoot(o6));
                });
              };
              setTimeout(() => {
                t3.model.change((t4) => {
                  u2(a3), d3(i3), s2 && h2(), c3.length && p3(t4, c3);
                });
              });
            }
          }, [l2, R2]);
          const T = c2.map((t3) => e2().createElement(w, { key: t3, id: t3, rootName: t3, semaphore: n2 }));
          return { editor: a2.instance.current, editableElements: T, toolbarElement: j, data: l2, setData: A, attributes: R2, setAttributes: D };
        };
      })(), a;
    })());
  }
});
export default require_dist();
/*! Bundled license information:

@ckeditor/ckeditor5-react/dist/index.js:
  (*!
   * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
   * For licensing, see LICENSE.md.
   *)
*/
//# sourceMappingURL=@ckeditor_ckeditor5-react.js.map
