import {
  $createParagraphNode,
  $getRoot,
  $getSelection,
  createEditor
} from "./chunk-VY7TNQR5.js";
import {
  LexicalComposerContext,
  createLexicalComposerContext
} from "./chunk-RDVN6PXU.js";
import {
  require_jsx_runtime
} from "./chunk-OT5EQO2H.js";
import {
  require_react
} from "./chunk-OU5AQDZK.js";
import {
  __toESM
} from "./chunk-EWTE5DHJ.js";

// node_modules/@lexical/react/LexicalComposer.dev.mjs
var import_react = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var CAN_USE_DOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
var useLayoutEffectImpl = CAN_USE_DOM ? import_react.useLayoutEffect : import_react.useEffect;
var HISTORY_MERGE_OPTIONS = {
  tag: "history-merge"
};
function LexicalComposer({
  initialConfig,
  children
}) {
  const composerContext = (0, import_react.useMemo)(
    () => {
      const {
        theme,
        namespace,
        editor__DEPRECATED: initialEditor,
        nodes,
        onError,
        editorState: initialEditorState,
        html
      } = initialConfig;
      const context = createLexicalComposerContext(null, theme);
      let editor = initialEditor || null;
      if (editor === null) {
        const newEditor = createEditor({
          editable: initialConfig.editable,
          html,
          namespace,
          nodes,
          onError: (error) => onError(error, newEditor),
          theme
        });
        initializeEditor(newEditor, initialEditorState);
        editor = newEditor;
      }
      return [editor, context];
    },
    // We only do this for init
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  useLayoutEffectImpl(() => {
    const isEditable = initialConfig.editable;
    const [editor] = composerContext;
    editor.setEditable(isEditable !== void 0 ? isEditable : true);
  }, []);
  return (0, import_jsx_runtime.jsx)(LexicalComposerContext.Provider, {
    value: composerContext,
    children
  });
}
function initializeEditor(editor, initialEditorState) {
  if (initialEditorState === null) {
    return;
  } else if (initialEditorState === void 0) {
    editor.update(() => {
      const root = $getRoot();
      if (root.isEmpty()) {
        const paragraph = $createParagraphNode();
        root.append(paragraph);
        const activeElement = CAN_USE_DOM ? document.activeElement : null;
        if ($getSelection() !== null || activeElement !== null && activeElement === editor.getRootElement()) {
          paragraph.select();
        }
      }
    }, HISTORY_MERGE_OPTIONS);
  } else if (initialEditorState !== null) {
    switch (typeof initialEditorState) {
      case "string": {
        const parsedEditorState = editor.parseEditorState(initialEditorState);
        editor.setEditorState(parsedEditorState, HISTORY_MERGE_OPTIONS);
        break;
      }
      case "object": {
        editor.setEditorState(initialEditorState, HISTORY_MERGE_OPTIONS);
        break;
      }
      case "function": {
        editor.update(() => {
          const root = $getRoot();
          if (root.isEmpty()) {
            initialEditorState(editor);
          }
        }, HISTORY_MERGE_OPTIONS);
        break;
      }
    }
  }
}
export {
  LexicalComposer
};
//# sourceMappingURL=@lexical_react_LexicalComposer.js.map
