import {
  $getAdjacentNode,
  $getCharacterOffsets,
  $isDecoratorNode,
  $isElementNode,
  $isParagraphNode,
  $isRootNode,
  $isTextNode
} from "./chunk-VY7TNQR5.js";

// node_modules/@lexical/selection/LexicalSelection.dev.mjs
function $updateElementNodeProperties(target, source) {
  target.__first = source.__first;
  target.__last = source.__last;
  target.__size = source.__size;
  target.__format = source.__format;
  target.__indent = source.__indent;
  target.__dir = source.__dir;
  return target;
}
function $updateTextNodeProperties(target, source) {
  target.__format = source.__format;
  target.__style = source.__style;
  target.__mode = source.__mode;
  target.__detail = source.__detail;
  return target;
}
function $updateParagraphNodeProperties(target, source) {
  target.__textFormat = source.__textFormat;
  return target;
}
function $cloneWithProperties(node) {
  const constructor = node.constructor;
  const clone = constructor.clone(node);
  clone.__parent = node.__parent;
  clone.__next = node.__next;
  clone.__prev = node.__prev;
  if ($isElementNode(node) && $isElementNode(clone)) {
    return $updateElementNodeProperties(clone, node);
  }
  if ($isTextNode(node) && $isTextNode(clone)) {
    return $updateTextNodeProperties(clone, node);
  }
  if ($isParagraphNode(node) && $isParagraphNode(clone)) {
    return $updateParagraphNodeProperties(clone, node);
  }
  return clone;
}
function $sliceSelectedTextNodeContent(selection, textNode) {
  const anchorAndFocus = selection.getStartEndPoints();
  if (textNode.isSelected(selection) && !textNode.isSegmented() && !textNode.isToken() && anchorAndFocus !== null) {
    const [anchor, focus] = anchorAndFocus;
    const isBackward = selection.isBackward();
    const anchorNode = anchor.getNode();
    const focusNode = focus.getNode();
    const isAnchor = textNode.is(anchorNode);
    const isFocus = textNode.is(focusNode);
    if (isAnchor || isFocus) {
      const [anchorOffset, focusOffset] = $getCharacterOffsets(selection);
      const isSame = anchorNode.is(focusNode);
      const isFirst = textNode.is(isBackward ? focusNode : anchorNode);
      const isLast = textNode.is(isBackward ? anchorNode : focusNode);
      let startOffset = 0;
      let endOffset = void 0;
      if (isSame) {
        startOffset = anchorOffset > focusOffset ? focusOffset : anchorOffset;
        endOffset = anchorOffset > focusOffset ? anchorOffset : focusOffset;
      } else if (isFirst) {
        const offset = isBackward ? focusOffset : anchorOffset;
        startOffset = offset;
        endOffset = void 0;
      } else if (isLast) {
        const offset = isBackward ? anchorOffset : focusOffset;
        startOffset = 0;
        endOffset = offset;
      }
      textNode.__text = textNode.__text.slice(startOffset, endOffset);
      return textNode;
    }
  }
  return textNode;
}
function $shouldOverrideDefaultCharacterSelection(selection, isBackward) {
  const possibleNode = $getAdjacentNode(selection.focus, isBackward);
  return $isDecoratorNode(possibleNode) && !possibleNode.isIsolated() || $isElementNode(possibleNode) && !possibleNode.isInline() && !possibleNode.canBeEmpty();
}
function $moveCaretSelection(selection, isHoldingShift, isBackward, granularity) {
  selection.modify(isHoldingShift ? "extend" : "move", isBackward, granularity);
}
function $isParentElementRTL(selection) {
  const anchorNode = selection.anchor.getNode();
  const parent = $isRootNode(anchorNode) ? anchorNode : anchorNode.getParentOrThrow();
  return parent.getDirection() === "rtl";
}
function $moveCharacter(selection, isHoldingShift, isBackward) {
  const isRTL = $isParentElementRTL(selection);
  $moveCaretSelection(selection, isHoldingShift, isBackward ? !isRTL : isRTL, "character");
}

// node_modules/@lexical/utils/LexicalUtils.dev.mjs
var CAN_USE_DOM$1 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
var documentMode = CAN_USE_DOM$1 && "documentMode" in document ? document.documentMode : null;
var IS_APPLE$1 = CAN_USE_DOM$1 && /Mac|iPod|iPhone|iPad/.test(navigator.platform);
var IS_FIREFOX$1 = CAN_USE_DOM$1 && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
var CAN_USE_BEFORE_INPUT$1 = CAN_USE_DOM$1 && "InputEvent" in window && !documentMode ? "getTargetRanges" in new window.InputEvent("input") : false;
var IS_SAFARI$1 = CAN_USE_DOM$1 && /Version\/[\d.]+.*Safari/.test(navigator.userAgent);
var IS_IOS$1 = CAN_USE_DOM$1 && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
var IS_ANDROID$1 = CAN_USE_DOM$1 && /Android/.test(navigator.userAgent);
var IS_CHROME$1 = CAN_USE_DOM$1 && /^(?=.*Chrome).*/i.test(navigator.userAgent);
var IS_APPLE_WEBKIT$1 = CAN_USE_DOM$1 && /AppleWebKit\/[\d.]+/.test(navigator.userAgent) && !IS_CHROME$1;
function mergeRegister(...func) {
  return () => {
    for (let i = func.length - 1; i >= 0; i--) {
      func[i]();
    }
    func.length = 0;
  };
}
function objectKlassEquals(object, objectClass) {
  return object !== null ? Object.getPrototypeOf(object).constructor.name === objectClass.name : false;
}

export {
  $cloneWithProperties,
  $sliceSelectedTextNodeContent,
  $shouldOverrideDefaultCharacterSelection,
  $moveCharacter,
  mergeRegister,
  objectKlassEquals
};
//# sourceMappingURL=chunk-2UN4MYWI.js.map
