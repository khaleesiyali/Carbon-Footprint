{
  "version": 3,
  "sources": ["../../@ckeditor/ckeditor5-react/dist/webpack:/CKEditor/webpack/universalModuleDefinition", "../../@ckeditor/ckeditor5-react/dist/webpack:/CKEditor/external umd \"prop-types\"", "../../@ckeditor/ckeditor5-react/dist/webpack:/CKEditor/external umd \"react\"", "../../@ckeditor/ckeditor5-react/dist/webpack:/CKEditor/webpack/bootstrap", "../../@ckeditor/ckeditor5-react/dist/webpack:/CKEditor/webpack/runtime/compat get default export", "../../@ckeditor/ckeditor5-react/dist/webpack:/CKEditor/webpack/runtime/define property getters", "../../@ckeditor/ckeditor5-react/dist/webpack:/CKEditor/webpack/runtime/hasOwnProperty shorthand", "../../@ckeditor/ckeditor5-react/dist/webpack:/CKEditor/webpack/runtime/make namespace object", "../../@ckeditor/ckeditor5-react/dist/webpack:/CKEditor/src/utils/uid.ts", "../../@ckeditor/ckeditor5-react/dist/webpack:/CKEditor/src/ckeditorcontext.tsx", "../../@ckeditor/ckeditor5-react/dist/webpack:/CKEditor/src/lifecycle/LifeCycleElementSemaphore.ts", "../../@ckeditor/ckeditor5-react/dist/webpack:/CKEditor/src/utils/once.ts", "../../@ckeditor/ckeditor5-react/dist/webpack:/CKEditor/src/utils/defer.ts", "../../@ckeditor/ckeditor5-react/dist/webpack:/CKEditor/src/ckeditor.tsx", "../../@ckeditor/ckeditor5-react/dist/webpack:/CKEditor/src/utils/mergeRefs.ts", "../../@ckeditor/ckeditor5-react/dist/webpack:/CKEditor/src/utils/overwriteObject.ts", "../../@ckeditor/ckeditor5-react/dist/webpack:/CKEditor/src/hooks/useRefSafeCallback.ts", "../../@ckeditor/ckeditor5-react/dist/webpack:/CKEditor/src/utils/overwriteArray.ts", "../../@ckeditor/ckeditor5-react/dist/webpack:/CKEditor/src/utils/shallowCompareArrays.ts", "../../@ckeditor/ckeditor5-react/dist/webpack:/CKEditor/src/hooks/useInstantEditorEffect.ts", "../../@ckeditor/ckeditor5-react/dist/webpack:/CKEditor/src/hooks/useInstantEffect.ts", "../../@ckeditor/ckeditor5-react/dist/webpack:/CKEditor/src/useMultiRootEditor.tsx", "../../@ckeditor/ckeditor5-react/dist/webpack:/CKEditor/src/lifecycle/useLifeCycleSemaphoreSyncRef.tsx", "../../@ckeditor/ckeditor5-react/dist/webpack:/CKEditor/src/utils/uniq.ts"],
  "sourcesContent": ["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"react\"), require(\"prop-types\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"react\", \"prop-types\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"CKEditor\"] = factory(require(\"react\"), require(\"prop-types\"));\n\telse\n\t\troot[\"CKEditor\"] = factory(root[\"react\"], root[\"prop-types\"]);\n})(self, (__WEBPACK_EXTERNAL_MODULE__155__, __WEBPACK_EXTERNAL_MODULE__949__) => {\nreturn ", "module.exports = __WEBPACK_EXTERNAL_MODULE__949__;", "module.exports = __WEBPACK_EXTERNAL_MODULE__155__;", "// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n", "// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};", "// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};", "__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))", "// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * A hash table of hex numbers to avoid using toString() in uid() which is costly.\n * [ '00', '01', '02', ..., 'fe', 'ff' ]\n */\nconst HEX_NUMBERS = new Array( 256 ).fill( '' )\n\t.map( ( _, index ) => ( '0' + ( index ).toString( 16 ) ).slice( -2 ) );\n\n/**\n * Returns a unique id. The id starts with an \"e\" character and a randomly generated string of\n * 32 alphanumeric characters.\n *\n * **Note**: The characters the unique id is built from correspond to the hex number notation\n * (from \"0\" to \"9\", from \"a\" to \"f\"). In other words, each id corresponds to an \"e\" followed\n * by 16 8-bit numbers next to each other.\n *\n * @returns An unique id string.\n */\nexport function uid(): string {\n\t// Let's create some positive random 32bit integers first.\n\t//\n\t// 1. Math.random() is a float between 0 and 1.\n\t// 2. 0x100000000 is 2^32 = 4294967296.\n\t// 3. >>> 0 enforces integer (in JS all numbers are floating point).\n\t//\n\t// For instance:\n\t//\t\tMath.random() * 0x100000000 = 3366450031.853859\n\t// but\n\t//\t\tMath.random() * 0x100000000 >>> 0 = 3366450031.\n\tconst r1 = Math.random() * 0x100000000 >>> 0;\n\tconst r2 = Math.random() * 0x100000000 >>> 0;\n\tconst r3 = Math.random() * 0x100000000 >>> 0;\n\tconst r4 = Math.random() * 0x100000000 >>> 0;\n\n\t// Make sure that id does not start with number.\n\treturn 'e' +\n\t\tHEX_NUMBERS[ r1 >> 0 & 0xFF ] +\n\t\tHEX_NUMBERS[ r1 >> 8 & 0xFF ] +\n\t\tHEX_NUMBERS[ r1 >> 16 & 0xFF ] +\n\t\tHEX_NUMBERS[ r1 >> 24 & 0xFF ] +\n\t\tHEX_NUMBERS[ r2 >> 0 & 0xFF ] +\n\t\tHEX_NUMBERS[ r2 >> 8 & 0xFF ] +\n\t\tHEX_NUMBERS[ r2 >> 16 & 0xFF ] +\n\t\tHEX_NUMBERS[ r2 >> 24 & 0xFF ] +\n\t\tHEX_NUMBERS[ r3 >> 0 & 0xFF ] +\n\t\tHEX_NUMBERS[ r3 >> 8 & 0xFF ] +\n\t\tHEX_NUMBERS[ r3 >> 16 & 0xFF ] +\n\t\tHEX_NUMBERS[ r3 >> 24 & 0xFF ] +\n\t\tHEX_NUMBERS[ r4 >> 0 & 0xFF ] +\n\t\tHEX_NUMBERS[ r4 >> 8 & 0xFF ] +\n\t\tHEX_NUMBERS[ r4 >> 16 & 0xFF ] +\n\t\tHEX_NUMBERS[ r4 >> 24 & 0xFF ];\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\nimport React, { type ReactNode } from 'react';\nimport PropTypes, { type InferProps, type Validator } from 'prop-types';\n\nimport type {\n\tContextWatchdog,\n\tWatchdogConfig,\n\tContext,\n\tContextConfig\n} from 'ckeditor5';\n\nexport const ContextWatchdogContext = React.createContext<ContextWatchdog | 'contextWatchdog' | null>( 'contextWatchdog' );\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport default class CKEditorContext<TContext extends Context = Context> extends React.Component<Props<TContext>, {}> {\n\tpublic contextWatchdog: ContextWatchdog<TContext> | null = null;\n\n\tconstructor( props: Props<TContext>, context: any ) {\n\t\tsuper( props, context );\n\n\t\tif ( this.props.isLayoutReady ) {\n\t\t\tthis._initializeContextWatchdog( this.props.config );\n\t\t}\n\t}\n\n\tpublic override shouldComponentUpdate( nextProps: Readonly<Props<TContext> & { children?: ReactNode | undefined }> ): boolean {\n\t\treturn this._shouldComponentUpdate( nextProps ) as unknown as boolean;\n\t}\n\n\t/**\n\t * Wrapper for the async handler. Note that this is an implementation bug, see https://github.com/ckeditor/ckeditor5-react/issues/312.\n\t */\n\tprivate async _shouldComponentUpdate( nextProps: Readonly<Props<TContext> & { children?: ReactNode | undefined }> ): Promise<boolean> {\n\t\t// If the configuration changes then the ContextWatchdog needs to be destroyed and recreated\n\t\t// On top of the new configuration.\n\t\tif ( nextProps.id !== this.props.id ) {\n\t\t\t/* istanbul ignore else */\n\t\t\tif ( this.contextWatchdog ) {\n\t\t\t\tawait this.contextWatchdog.destroy();\n\t\t\t}\n\n\t\t\tawait this._initializeContextWatchdog( nextProps.config );\n\t\t}\n\n\t\tif ( nextProps.isLayoutReady && !this.contextWatchdog ) {\n\t\t\tawait this._initializeContextWatchdog( nextProps.config );\n\n\t\t\treturn true;\n\t\t}\n\n\t\t// Rerender the component only when children has changed.\n\t\treturn this.props.children !== nextProps.children;\n\t}\n\n\tpublic override render(): ReactNode {\n\t\treturn (\n\t\t\t<ContextWatchdogContext.Provider value={ this.contextWatchdog }>\n\t\t\t\t{ this.props.children }\n\t\t\t</ContextWatchdogContext.Provider>\n\t\t);\n\t}\n\n\tpublic override componentWillUnmount(): void {\n\t\tthis._destroyContext();\n\t}\n\n\tprivate async _initializeContextWatchdog( config?: ContextConfig ): Promise<void> {\n\t\t// eslint-disable-next-line new-cap\n\t\tthis.contextWatchdog = new this.props.contextWatchdog( this.props.context!, this.props.watchdogConfig );\n\n\t\tthis.contextWatchdog.on( 'error', ( _, errorEvent ) => {\n\t\t\tthis.props.onError( errorEvent.error, {\n\t\t\t\tphase: 'runtime',\n\t\t\t\twillContextRestart: errorEvent.causesRestart\n\t\t\t} );\n\t\t} );\n\n\t\tthis.contextWatchdog.on( 'stateChange', () => {\n\t\t\tif ( this.contextWatchdog!.state === 'ready' && this.props.onReady ) {\n\t\t\t\tthis.props.onReady( this.contextWatchdog!.context! );\n\t\t\t}\n\t\t} );\n\n\t\tawait this.contextWatchdog.create( config )\n\t\t\t.catch( error => {\n\t\t\t\tthis.props.onError( error, {\n\t\t\t\t\tphase: 'initialization',\n\t\t\t\t\twillContextRestart: false\n\t\t\t\t} );\n\t\t\t} );\n\t}\n\n\tprivate async _destroyContext(): Promise<void> {\n\t\tif ( this.contextWatchdog ) {\n\t\t\tawait this.contextWatchdog.destroy();\n\t\t\tthis.contextWatchdog = null;\n\t\t}\n\t}\n\n\tpublic static defaultProps: Partial<Props<Context>> = {\n\t\tisLayoutReady: true,\n\t\tonError: ( error, details ) => console.error( error, details )\n\t};\n\n\tpublic static propTypes = {\n\t\tid: PropTypes.string,\n\t\tisLayoutReady: PropTypes.bool,\n\t\tcontext: PropTypes.func as unknown as Validator<{ create( ...args: any ): Promise<any> } | undefined>,\n\t\twatchdogConfig: PropTypes.object,\n\t\tconfig: PropTypes.object,\n\t\tonReady: PropTypes.func,\n\t\tonError: PropTypes.func\n\t};\n}\n\ninterface Props<TContext extends Context> extends InferProps<typeof CKEditorContext.propTypes> {\n\tcontext?: { create( ...args: any ): Promise<TContext> };\n\tcontextWatchdog: typeof ContextWatchdog<TContext>;\n\twatchdogConfig?: WatchdogConfig;\n\tconfig?: ContextConfig;\n\tonReady?: ( context: Context ) => void; // TODO this should accept TContext (after ContextWatchdog release).\n\tonError: ( error: Error, details: ErrorDetails ) => void;\n\tchildren?: ReactNode;\n}\n\ninterface ErrorDetails {\n\tphase: 'initialization' | 'runtime';\n\twillContextRestart: boolean;\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\nimport { createDefer, type Defer } from '../utils/defer';\nimport { once } from '../utils/once';\n\n/**\n * This class is utilized to pause the initialization of an editor when another instance is already present on a specified element.\n * It is engineered to address the following issues:\n *\n *\t* Rapid changes in component properties often lead to the re-initialization of the editor, which can trigger\n *\t  the `editor-source-element-already-used` exception. This occurs because the editor is still in the process of initializing\n *\t  when the component decides to destroy it. This semaphore waits for the editor to fully initialize before destroying it, thereby\n *\t  allowing a new instance of the editor to be attached to the specified element.\n *\n *\t* Rapid mounting and unmounting in strict mode frequently results in the `editor-source-element-already-used` exception\n *\t  being thrown by the editor. This is due to React reusing the underlying DOM element during the mounting and unmounting of components\n *\t  (especially if the same component is being mounted and unmounted). Consequently, a race condition arises. The first render begins to\n *\t  attach the editor (in async mode), and shortly thereafter, it is destroyed and a new instance of the component is initialized.\n *\t  This semaphore, by utilizing a static semaphores promises map, retains information about whether the element is used by a previous\n *\t  instance of the editor and resumes execution when it is freed.\n *\n *\t* The process involves starting up many editors that are no longer needed and are immediately removed in the following rerenders.\n *\t  This can cause the editor’s initialization performance to slow down. The initialization of the editor is skipped when numerous\n *\t  rerenders occur within a short time-frame while using this semaphore. An example of this could be a situation with 4 rerenders\n *\t  occurring within a 10ms period. This semaphore will likely batch these calls, and instead of initializing 4 editors, only 2 will be\n *\t  initialized (the first and the last one).\n */\nexport class LifeCycleElementSemaphore<R> {\n\t/**\n\t * This is a map of elements associated with promises. It informs the semaphore that the underlying HTML element, used as a key,\n\t * is currently in use by another editor. Each element is assigned a promise, which allows for the easy chaining of new\n\t * editor instances on an element that is already in use by another instance. The process works as follows:\n\t *\n\t * \t1. If an element is being used by an editor, then the initialization of a new editor\n\t * \t   instance is chained using the `.then()` method of the Promise.\n\t *\n\t * \t2. If the editor associated with the underlying element is destroyed, then `Promise.resolve()` is called\n\t * \t   and the previously assigned `.then()` editor callback is executed.\n\t *\n\t *  @see {@link #lock} for more detailed information on the implementation.\n\t */\n\tprivate static readonly _semaphores = new Map<HTMLElement, Promise<void>>();\n\n\t/**\n\t * This should define async methods for initializing and destroying the editor.\n\t * Essentially, it's an async version of basic React lifecycle methods like `componentDidMount`, `componentWillUnmount`.\n\t *\n\t * \t* Result of {@link LifeCycleAsyncOperators#mount} method is passed to {@link LifeCycleAsyncOperators#unmount} as an argument.\n\t */\n\tprivate readonly _lifecycle: LifeCycleAsyncOperators<R>;\n\n\t/**\n\t * This is the element instance that the editor uses for mounting. This element should contain the `ckeditorInstance` member\n\t * once the editor has been successfully mounted to it. The semaphore ensures that a new instance of the editor, which will\n\t * be assigned to this element by the {@link #_lifecycle:mount} method, will always be initialized after the successful\n\t * destruction of the underlying `ckeditorInstance` that was previously mounted on this element.\n\t */\n\tprivate readonly _element: HTMLElement;\n\n\t/**\n\t * This is the lock mechanism utilized by the {@link #lock} and {@link #release} methods.\n\t *\n\t * \t* If the editor is not yet mounted and is awaiting mounting (for instance, when another editor is\n\t * \t  occupying the element), then it is null.\n\t *\n\t * \t* When the editor is mounted on the element, this variable holds an unresolved promise that will be\n\t * \t  resolved after the editor is destroyed.\n\t *\n\t * \t* Once the editor is destroyed (and it was previously mounted), the promise is resolved.\n\t */\n\tprivate _releaseLock: Defer<void> | null = null;\n\n\t/**\n\t * This is the result of the {@link #_lifecycle:mount} function. This value should be reset to `null`\n\t * once the semaphore is released. It is utilized to store certain data that must be removed following\n\t * the destruction of the editor. This data may include the editor's instance, the assigned watchdog,\n\t * or handles for additional window listeners.\n\t */\n\tprivate _value: R | null = null;\n\n\t/**\n\t * This is a list of callbacks that are triggered if the semaphore {@link #_lifecycle:mount} method executes successfully.\n\t * It is utilized in scenarios where we need to assign certain properties to an editor that is currently in the process of mounting.\n\t * An instance of such usage could be two-way binding. We aim to prevent the loss of all `setData` calls if the editor has not\n\t * yet been mounted, therefore these calls will be executed immediately following the completion of the mounting process.\n\t */\n\tprivate _afterMountCallbacks: Array<LifeCycleAfterMountCallback<R>> = [];\n\n\t/**\n\t * This represents the actual mounting state of the semaphore. It is primarily used by the {@link #release} method to\n\t * determine whether the initialization of the editor should be skipped or, if the editor is already initialized, the editor\n\t * should be destroyed.\n\t *\n\t * \t* If `destroyedBeforeInitialization` is true, then the {@link #release} method was invoked before the editor began to mount.\n\t * \t  This often occurs in strict mode when we assign a promise to the {@link LifeCycleEditorElementSemaphore#_semaphores} map\n\t * \t  and the assigned `mount` callback has not yet been called. In this scenario, it is safe to skip the initialization of the editor\n\t * \t  and simply release the semaphore.\n\t *\n\t *\t* If `mountingInProgress` is a Promise, then the {@link #release} method was invoked after the initialization of the editor and\n\t \t  the editor must be destroyed before the semaphore is released.\n\t*/\n\tprivate _state: LifeCycleState<R> = {\n\t\tdestroyedBeforeInitialization: false,\n\t\tmountingInProgress: null\n\t};\n\n\tconstructor( element: HTMLElement, lifecycle: LifeCycleAsyncOperators<R> ) {\n\t\tthis._element = element;\n\t\tthis._lifecycle = lifecycle;\n\t\tthis._lock();\n\t}\n\n\t/**\n\t * Getter for {@link #_value}.\n\t */\n\tpublic get value(): R | null {\n\t\treturn this._value;\n\t}\n\n\t/**\n\t * Occasionally, the Watchdog restarts the editor instance, resulting in a new instance being assigned to the semaphore.\n\t * In terms of race conditions, it's generally safer to simply override the semaphore value rather than recreating it\n\t * with a different one.\n\t */\n\tpublic unsafeSetValue( value: R ): void {\n\t\tthis._value = value;\n\n\t\tthis._afterMountCallbacks.forEach( callback => callback( value ) );\n\t\tthis._afterMountCallbacks = [];\n\t}\n\n\t/**\n\t * This registers a callback that will be triggered after the editor has been successfully mounted.\n\t *\n\t * \t* If the editor is already mounted, the callback will be executed immediately.\n\t *\t* If the editor is in the process of mounting, the callback will be executed upon successful mounting.\n\t* \t* If the editor is never mounted, the passed callback will not be executed.\n\t* \t* If an exception is thrown within the callback, it will be re-thrown in the semaphore.\n\t*/\n\tpublic runAfterMount( callback: LifeCycleAfterMountCallback<R> ): void {\n\t\tconst { _value, _afterMountCallbacks } = this;\n\n\t\tif ( _value ) {\n\t\t\tcallback( _value );\n\t\t} else {\n\t\t\t_afterMountCallbacks.push( callback );\n\t\t}\n\t}\n\n\t/**\n\t * This method is used to inform other components that the {@link #_element} will be used by the editor,\n\t * which is initialized by the {@link #_lifecycle} methods.\n\t *\n\t * \t* If an editor is already present on the provided element, the initialization of the current one\n\t * \t  will be postponed until the previous one is destroyed.\n\t *\n\t * \t* If the element is empty and does not have an editor attached to it, the currently locked editor will\n\t * \t  be mounted immediately.\n\t *\n\t * After the successful initialization of the editor and the assignment of the {@link #_value} member,\n\t * the `onReady` lifecycle method is called.\n\t *\n\t * *Important note:*\n\t *\n\t * It’s really important to keep this method *sync*. If we make this method *async*, it won’t work well because\n\t * it will cause problems when we’re trying to set up the {@link LifeCycleEditorElementSemaphore#_semaphores} map entries.\n\t */\n\tprivate _lock(): void {\n\t\tconst { _semaphores } = LifeCycleElementSemaphore;\n\t\tconst { _state, _element, _lifecycle } = this;\n\n\t\t// This promise signifies that the previous editor is still attached to the current element.\n\t\t// Upon successful resolution, it will indicate that it is safe to assume that the element has\n\t\t// no assigned editor instance and can be reinitialized.\n\t\tconst prevElementSemaphore = _semaphores.get( _element ) || Promise.resolve( null );\n\n\t\t// This is a lock that will be resolved after the `release` method is called. Due to this lock,\n\t\t// the promise will never be resolved until the editor is destroyed.\n\t\tconst releaseLock = createDefer();\n\t\tthis._releaseLock = releaseLock;\n\n\t\t// This is the initialization of the editor that occurs after the previous editor has been detached from the specified element.\n\t\t//\n\t\t// If the `release` method was called before the initialization of the current editor instance, then it will be skipped.\n\t\t// This situation occurs quite frequently when we have three or more rerenders in a row, and it doesn't make sense to initialize\n\t\t// the second editor because it will be overridden anyway by the third one.\n\t\tconst newElementSemaphore = prevElementSemaphore\n\t\t\t.then( () => {\n\t\t\t\tif ( _state.destroyedBeforeInitialization ) {\n\t\t\t\t\treturn Promise.resolve( undefined );\n\t\t\t\t}\n\n\t\t\t\t// This variable will be used later in the `release` method to determine\n\t\t\t\t// whether the editor is being destroyed prior to initialization.\n\t\t\t\t_state.mountingInProgress = _lifecycle.mount().then( mountResult => {\n\t\t\t\t\tif ( mountResult ) {\n\t\t\t\t\t\tthis.unsafeSetValue( mountResult );\n\t\t\t\t\t}\n\n\t\t\t\t\treturn mountResult;\n\t\t\t\t} );\n\n\t\t\t\treturn _state.mountingInProgress;\n\t\t\t} )\n\t\t\t.then( async mountResult => {\n\t\t\t\t// Everything is fine, all ready callback might be fired here.\n\t\t\t\tif ( mountResult && _lifecycle.afterMount ) {\n\t\t\t\t\tawait _lifecycle.afterMount( {\n\t\t\t\t\t\telement: _element,\n\t\t\t\t\t\tmountResult\n\t\t\t\t\t} );\n\t\t\t\t}\n\t\t\t} )\n\n\t\t\t// It will be released after destroying of editor by the {@link #_release method}.\n\t\t\t.then( () => releaseLock.promise )\n\n\t\t\t// Prevent hanging of semaphore during mount, just assume that everything is fine\n\t\t\t.catch( error => {\n\t\t\t\tconsole.error( 'Semaphore mounting error:', error );\n\t\t\t} )\n\n\t\t\t// Remove semaphore from map if released.\n\t\t\t.then( () => {\n\t\t\t\tif ( _semaphores.get( _element ) === newElementSemaphore ) {\n\t\t\t\t\t_semaphores.delete( _element );\n\t\t\t\t}\n\t\t\t} );\n\n\t\t_semaphores.set( _element, newElementSemaphore );\n\t}\n\n\t/**\n\t * Inverse of {@link #_lock} method that tries to destroy attached editor.\n\t *\n\t * \t* If editor is being already attached to element (or is in attaching process) then after fully initialization of editor\n\t * \t  destroy is performed and semaphore is released. The {@link #_lifecycle} unmount method is called.\n\t *\n\t * \t* If editor is being destroyed before initialization then it does nothing but sets `destroyedBeforeInitialization` flag that\n\t * \t  will be later checked by {@link #_lock} method in initialization. The {@link #_lifecycle} unmount method is not called.\n\t *\n\t * *Important note:*\n\t *\n\t * It’s really important to keep this method *sync*. If we make this method *async*, it won’t work well because\n\t * it will cause problems when we’re trying to set up the {@link LifeCycleEditorElementSemaphore#_semaphores} map entries.\n\t */\n\tpublic readonly release = once( () => {\n\t\tconst { _releaseLock, _state, _element, _lifecycle } = this;\n\n\t\tif ( _state.mountingInProgress ) {\n\t\t\t_state.mountingInProgress\n\t\t\t\t.then( () => _lifecycle.unmount( {\n\t\t\t\t\telement: _element,\n\n\t\t\t\t\t// Mount result might be overridden by watchdog during restart so use instance variable.\n\t\t\t\t\tmountResult: this.value!\n\t\t\t\t} ) )\n\n\t\t\t\t// Prevent hanging of semaphore during unmount, just assume that everything is fine\n\t\t\t\t.catch( error => {\n\t\t\t\t\tconsole.error( 'Semaphore unmounting error:', error );\n\t\t\t\t} )\n\n\t\t\t\t.then( _releaseLock!.resolve )\n\t\t\t\t.then( () => {\n\t\t\t\t\tthis._value = null;\n\t\t\t\t} );\n\t\t} else {\n\t\t\t_state.destroyedBeforeInitialization = true;\n\t\t\t_releaseLock!.resolve();\n\t\t}\n\t} );\n}\n\nexport type LifeCycleAfterMountCallback<R> = ( mountResult: R ) => void;\n\ntype LifeCycleState<R> = {\n\tdestroyedBeforeInitialization: boolean;\n\tmountingInProgress: Promise<R> | null;\n};\n\ntype LifeCyclePostMountAttrs<R> = {\n\telement: HTMLElement;\n\tmountResult: R;\n};\n\ntype LifeCycleAsyncOperators<R> = {\n\tmount: () => Promise<R>;\n\tafterMount?: ( result: LifeCyclePostMountAttrs<R> ) => Promise<void> | void;\n\tunmount: ( result: LifeCyclePostMountAttrs<R> ) => Promise<void>;\n};\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * Ensures that passed function will be executed only once.\n */\nexport function once<A extends Array<any>, R = void>( fn: ( ...args: A ) => R ): ( ...args: A ) => R {\n\tlet lastResult: { current: R } | null = null;\n\n\treturn ( ...args: A ): R => {\n\t\tif ( !lastResult ) {\n\t\t\tlastResult = {\n\t\t\t\tcurrent: fn( ...args )\n\t\t\t};\n\t\t}\n\n\t\treturn lastResult.current;\n\t};\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\nexport type Defer<E> = {\n\tpromise: Promise<E>;\n\tresolve: ( value: E ) => void;\n};\n\n/**\n * This function generates a promise that can be resolved by invoking the returned `resolve` method.\n * It proves to be beneficial in the creation of various types of locks and semaphores.\n */\nexport function createDefer<E = void>(): Defer<E> {\n\tconst deferred: Defer<E> = {\n\t\tresolve: null as any,\n\t\tpromise: null as any\n\t};\n\n\tdeferred.promise = new Promise<E>( resolve => {\n\t\tdeferred.resolve = resolve;\n\t} );\n\n\treturn deferred;\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/* globals window */\n\nimport React from 'react';\nimport PropTypes, { type InferProps, type Validator } from 'prop-types';\nimport type {\n\tEventInfo,\n\tEditor,\n\tEditorConfig,\n\tDocumentChangeEvent,\n\tEditorWatchdog,\n\tContextWatchdog,\n\tWatchdogConfig,\n\tEditorCreatorFunction\n} from 'ckeditor5';\n\nimport { uid } from './utils/uid';\nimport { ContextWatchdogContext } from './ckeditorcontext';\nimport { LifeCycleElementSemaphore } from './lifecycle/LifeCycleElementSemaphore';\nimport type { EditorSemaphoreMountResult } from './lifecycle/LifeCycleEditorSemaphore';\n\nconst REACT_INTEGRATION_READ_ONLY_LOCK_ID = 'Lock from React integration (@ckeditor/ckeditor5-react)';\n\n// eslint-disable-next-line @typescript-eslint/ban-types\nexport default class CKEditor<TEditor extends Editor> extends React.Component<Props<TEditor>> {\n\t/**\n\t * After mounting the editor, the variable will contain a reference to the created editor.\n\t * @see: https://ckeditor.com/docs/ckeditor5/latest/api/module_core_editor_editor-Editor.html\n\t */\n\tprivate domContainer = React.createRef<HTMLDivElement>();\n\n\t/**\n\t * Unlocks element in editor semaphore after destroy editor instance.\n\t */\n\tprivate editorSemaphore: LifeCycleElementSemaphore<EditorSemaphoreMountResult<TEditor>> | null = null;\n\n\tconstructor( props: Props<TEditor> ) {\n\t\tsuper( props );\n\n\t\tthis._checkVersion();\n\t}\n\n\t/**\n\t * Checks if the CKEditor version used in the application is compatible with the component.\n\t */\n\tprivate _checkVersion(): void {\n\t\tconst { CKEDITOR_VERSION } = window;\n\n\t\tif ( !CKEDITOR_VERSION ) {\n\t\t\treturn console.warn( 'Cannot find the \"CKEDITOR_VERSION\" in the \"window\" scope.' );\n\t\t}\n\n\t\tconst [ major ] = CKEDITOR_VERSION.split( '.' ).map( Number );\n\n\t\tif ( major >= 42 || CKEDITOR_VERSION.startsWith( '0.0.0' ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconsole.warn( 'The <CKEditor> component requires using CKEditor 5 in version 42+ or nightly build.' );\n\t}\n\n\tprivate get _semaphoreValue(): EditorSemaphoreMountResult<TEditor> | null {\n\t\tconst { editorSemaphore } = this;\n\n\t\treturn editorSemaphore ? editorSemaphore.value : null;\n\t}\n\n\t/**\n\t * An watchdog instance.\n\t */\n\tpublic get watchdog(): EditorWatchdog<TEditor> | EditorWatchdogAdapter<TEditor> | null {\n\t\tconst { _semaphoreValue } = this;\n\n\t\treturn _semaphoreValue ? _semaphoreValue.watchdog : null;\n\t}\n\n\t/**\n\t * An editor instance.\n\t */\n\tpublic get editor(): Editor | null {\n\t\tconst { _semaphoreValue } = this;\n\n\t\treturn _semaphoreValue ? _semaphoreValue.instance : null;\n\t}\n\n\t/**\n\t * The CKEditor component should not be updated by React itself.\n\t * However, if the component identifier changes, the whole structure should be created once again.\n\t */\n\tpublic override shouldComponentUpdate( nextProps: Readonly<Props<TEditor>> ): boolean {\n\t\tconst { props, editorSemaphore } = this;\n\n\t\t// Only when the component identifier changes the whole structure should be re-created once again.\n\t\tif ( nextProps.id !== props.id ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( nextProps.disableWatchdog !== props.disableWatchdog ) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( editorSemaphore ) {\n\t\t\teditorSemaphore.runAfterMount( ( { instance } ) => {\n\t\t\t\tif ( this._shouldUpdateEditorData( props, nextProps, instance ) ) {\n\t\t\t\t\tinstance.data.set( nextProps.data! );\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\tif ( 'disabled' in nextProps ) {\n\t\t\t\teditorSemaphore.runAfterMount( ( { instance } ) => {\n\t\t\t\t\tif ( nextProps.disabled ) {\n\t\t\t\t\t\tinstance.enableReadOnlyMode( REACT_INTEGRATION_READ_ONLY_LOCK_ID );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tinstance.disableReadOnlyMode( REACT_INTEGRATION_READ_ONLY_LOCK_ID );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Initialize the editor when the component is mounted.\n\t */\n\tpublic override componentDidMount(): void {\n\t\tthis._initLifeCycleSemaphore();\n\t}\n\n\t/**\n\t * Re-render the entire component once again. The old editor will be destroyed and the new one will be created.\n\t */\n\tpublic override componentDidUpdate(): void {\n\t\tthis._initLifeCycleSemaphore();\n\t}\n\n\t/**\n\t * Destroy the editor before unmounting the component.\n\t */\n\tpublic override componentWillUnmount(): void {\n\t\tthis._unlockLifeCycleSemaphore();\n\t}\n\n\t/**\n\t * Async destroy attached editor and unlock element semaphore.\n\t */\n\tprivate _unlockLifeCycleSemaphore() {\n\t\tif ( this.editorSemaphore ) {\n\t\t\tthis.editorSemaphore.release();\n\t\t\tthis.editorSemaphore = null;\n\t\t}\n\t}\n\n\t/**\n\t * Unlocks previous editor semaphore and creates new one..\n\t */\n\tprivate _initLifeCycleSemaphore() {\n\t\tthis._unlockLifeCycleSemaphore();\n\t\tthis.editorSemaphore = new LifeCycleElementSemaphore( this.domContainer.current!, {\n\t\t\tmount: async () => this._initializeEditor(),\n\t\t\tafterMount: ( { mountResult } ) => {\n\t\t\t\tconst { onReady } = this.props;\n\n\t\t\t\tif ( onReady && this.domContainer.current !== null ) {\n\t\t\t\t\tonReady( mountResult.instance );\n\t\t\t\t}\n\t\t\t},\n\t\t\tunmount: async ( { element, mountResult } ) => {\n\t\t\t\tconst { onAfterDestroy } = this.props;\n\n\t\t\t\ttry {\n\t\t\t\t\tawait this._destroyEditor( mountResult );\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Make sure that nothing left in actual editor element. There can be custom integrations that\n\t\t\t\t\t * appends something to container. Let's reset element every update cycle before mounting another\n\t\t\t\t\t * editor instance.\n\t\t\t\t\t */\n\t\t\t\t\telement.innerHTML = '';\n\t\t\t\t} finally {\n\t\t\t\t\t/**\n\t\t\t\t\t * Broadcast information about destroying current instance. It is useful for removing duplicated\n\t\t\t\t\t * toolbars in decoupled editor mode.\n\t\t\t\t\t */\n\t\t\t\t\tif ( onAfterDestroy ) {\n\t\t\t\t\t\tonAfterDestroy( mountResult.instance );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} );\n\t}\n\n\t/**\n\t * Render a <div> element which will be replaced by CKEditor.\n\t */\n\tpublic override render(): React.ReactNode {\n\t\treturn (\n\t\t\t<div ref={ this.domContainer }></div>\n\t\t);\n\t}\n\n\t/**\n\t * Initializes the editor by creating a proper watchdog and initializing it with the editor's configuration.\n\t */\n\tprivate async _initializeEditor(): Promise<EditorSemaphoreMountResult<TEditor>> {\n\t\tif ( this.props.disableWatchdog ) {\n\t\t\tconst instance = await this._createEditor( this.domContainer.current!, this._getConfig() );\n\n\t\t\treturn {\n\t\t\t\tinstance: instance as TEditor,\n\t\t\t\twatchdog: null\n\t\t\t};\n\t\t}\n\n\t\tconst watchdog = ( () => {\n\t\t\tif ( this.context instanceof this.props.editor.ContextWatchdog ) {\n\t\t\t\treturn new EditorWatchdogAdapter( this.context );\n\t\t\t}\n\n\t\t\treturn new this.props.editor.EditorWatchdog( this.props.editor, this.props.watchdogConfig );\n\t\t} )() as EditorWatchdogAdapter<TEditor>;\n\n\t\tconst totalRestartsRef = {\n\t\t\tcurrent: 0\n\t\t};\n\n\t\twatchdog.setCreator( async ( el, config ) => {\n\t\t\tconst { editorSemaphore } = this;\n\t\t\tconst { onAfterDestroy } = this.props;\n\n\t\t\tif ( totalRestartsRef.current > 0 &&\n\t\t\t\t\tonAfterDestroy &&\n\t\t\t\t\teditorSemaphore &&\n\t\t\t\t\teditorSemaphore.value &&\n\t\t\t\t\teditorSemaphore.value.instance ) {\n\t\t\t\tonAfterDestroy( editorSemaphore.value.instance );\n\t\t\t}\n\n\t\t\tconst instance = await this._createEditor( el as any, config );\n\n\t\t\tif ( totalRestartsRef.current > 0 ) {\n\t\t\t\teditorSemaphore!.unsafeSetValue( {\n\t\t\t\t\tinstance,\n\t\t\t\t\twatchdog\n\t\t\t\t} );\n\n\t\t\t\tsetTimeout( () => {\n\t\t\t\t\tif ( this.props.onReady ) {\n\t\t\t\t\t\tthis.props.onReady( watchdog!.editor as TEditor );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\ttotalRestartsRef.current++;\n\t\t\treturn instance;\n\t\t} );\n\n\t\twatchdog.on( 'error', ( _, { error, causesRestart } ) => {\n\t\t\tconst onError = this.props.onError || console.error;\n\t\t\tonError( error, { phase: 'runtime', willEditorRestart: causesRestart } );\n\t\t} );\n\n\t\tawait watchdog\n\t\t\t.create( this.domContainer.current!, this._getConfig() )\n\t\t\t.catch( error => {\n\t\t\t\tconst onError = this.props.onError || console.error;\n\t\t\t\tonError( error, { phase: 'initialization', willEditorRestart: false } );\n\t\t\t} );\n\n\t\treturn {\n\t\t\twatchdog,\n\t\t\tinstance: watchdog!.editor\n\t\t};\n\t}\n\n\t/**\n\t * Creates an editor from the element and configuration.\n\t *\n\t * @param element The source element.\n\t * @param config CKEditor 5 editor configuration.\n\t */\n\tprivate _createEditor( element: HTMLElement | string | Record<string, string>, config: EditorConfig ): Promise<TEditor> {\n\t\treturn this.props.editor.create( element as HTMLElement, config )\n\t\t\t.then( editor => {\n\t\t\t\tif ( 'disabled' in this.props ) {\n\t\t\t\t\t// Switch to the read-only mode if the `[disabled]` attribute is specified.\n\t\t\t\t\t/* istanbul ignore else */\n\t\t\t\t\tif ( this.props.disabled ) {\n\t\t\t\t\t\teditor.enableReadOnlyMode( REACT_INTEGRATION_READ_ONLY_LOCK_ID );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tconst modelDocument = editor.model.document;\n\t\t\t\tconst viewDocument = editor.editing.view.document;\n\n\t\t\t\tmodelDocument.on<DocumentChangeEvent>( 'change:data', event => {\n\t\t\t\t\t/* istanbul ignore else */\n\t\t\t\t\tif ( this.props.onChange ) {\n\t\t\t\t\t\tthis.props.onChange( event, editor );\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tviewDocument.on( 'focus', event => {\n\t\t\t\t\t/* istanbul ignore else */\n\t\t\t\t\tif ( this.props.onFocus ) {\n\t\t\t\t\t\tthis.props.onFocus( event, editor );\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tviewDocument.on( 'blur', event => {\n\t\t\t\t\t/* istanbul ignore else */\n\t\t\t\t\tif ( this.props.onBlur ) {\n\t\t\t\t\t\tthis.props.onBlur( event, editor );\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\treturn editor;\n\t\t\t} );\n\t}\n\n\t/**\n\t * Destroys the editor by destroying the watchdog.\n\t */\n\tprivate async _destroyEditor( initializeResult: EditorSemaphoreMountResult<Editor> ): Promise<void> {\n\t\tconst { watchdog, instance } = initializeResult;\n\n\t\treturn new Promise<void>( ( resolve, reject ) => {\n\t\t\t// It may happen during the tests that the watchdog instance is not assigned before destroying itself. See: #197.\n\t\t\t//\n\t\t\t// Additionally, we need to find a way to detect if the whole context has been destroyed. As `componentWillUnmount()`\n\t\t\t// could be fired by <CKEditorContext /> and <CKEditor /> at the same time, this `setTimeout()` makes sure\n\t\t\t// that <CKEditorContext /> component will be destroyed first, so during the code execution\n\t\t\t// the `ContextWatchdog#state` would have a correct value. See `EditorWatchdogAdapter#destroy()` for more information.\n\t\t\t/* istanbul ignore next */\n\t\t\tsetTimeout( async () => {\n\t\t\t\ttry {\n\t\t\t\t\tif ( watchdog ) {\n\t\t\t\t\t\tawait watchdog.destroy();\n\t\t\t\t\t\treturn resolve();\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( instance ) {\n\t\t\t\t\t\tawait instance.destroy();\n\t\t\t\t\t\treturn resolve();\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve();\n\t\t\t\t} catch ( e ) {\n\t\t\t\t\tconsole.error( e );\n\t\t\t\t\treject( e );\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t}\n\n\t/**\n\t * Returns true when the editor should be updated.\n\t *\n\t * @param prevProps Previous react's properties.\n\t * @param nextProps React's properties.\n\t * @param editor Current editor instance.\n\t */\n\tprivate _shouldUpdateEditorData( prevProps: Readonly<Props<TEditor>>, nextProps: Readonly<Props<TEditor>>, editor: TEditor ): boolean {\n\t\t// Check whether `nextProps.data` is equal to `this.props.data` is required if somebody defined the `#data`\n\t\t// property as a static string and updated a state of component when the editor's content has been changed.\n\t\t// If we avoid checking those properties, the editor's content will back to the initial value because\n\t\t// the state has been changed and React will call this method.\n\t\tif ( prevProps.data === nextProps.data ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// We should not change data if the editor's content is equal to the `#data` property.\n\t\tif ( editor.data.get() === nextProps.data ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns the editor configuration.\n\t */\n\tprivate _getConfig(): EditorConfig {\n\t\tconst config = this.props.config || {};\n\n\t\tif ( this.props.data && config.initialData ) {\n\t\t\tconsole.warn(\n\t\t\t\t'Editor data should be provided either using `config.initialData` or `content` property. ' +\n\t\t\t\t'The config value takes precedence over `content` property and will be used when both are specified.'\n\t\t\t);\n\t\t}\n\n\t\t// Merge two possible ways of providing data into the `config.initialData` field.\n\t\treturn {\n\t\t\t...config,\n\t\t\tinitialData: config.initialData || this.props.data || ''\n\t\t};\n\t}\n\n\tpublic static override contextType = ContextWatchdogContext;\n\n\t// Properties definition.\n\tpublic static propTypes = {\n\t\teditor: PropTypes.func.isRequired as unknown as Validator<{ create( ...args: any ): Promise<any> }>,\n\t\tdata: PropTypes.string,\n\t\tconfig: PropTypes.object,\n\t\tdisableWatchdog: PropTypes.bool,\n\t\twatchdogConfig: PropTypes.object,\n\t\tonChange: PropTypes.func,\n\t\tonReady: PropTypes.func,\n\t\tonFocus: PropTypes.func,\n\t\tonBlur: PropTypes.func,\n\t\tonError: PropTypes.func,\n\t\tdisabled: PropTypes.bool,\n\t\tid: PropTypes.any\n\t};\n}\n\n/**\n * TODO this is type space definition for props, the CKEditor.propTypes is a run-time props validation that should match.\n */\ninterface Props<TEditor extends Editor> extends InferProps<typeof CKEditor.propTypes> {\n\teditor: {\n\t\tcreate( ...args: any ): Promise<TEditor>;\n\t\tEditorWatchdog: typeof EditorWatchdog;\n\t\tContextWatchdog: typeof ContextWatchdog;\n\t};\n\tconfig?: EditorConfig;\n\twatchdogConfig?: WatchdogConfig;\n\tdisableWatchdog?: boolean;\n\tonReady?: ( editor: TEditor ) => void;\n\tonAfterDestroy?: ( editor: TEditor ) => void;\n\tonError?: ( error: Error, details: ErrorDetails ) => void;\n\tonChange?: ( event: EventInfo, editor: TEditor ) => void;\n\tonFocus?: ( event: EventInfo, editor: TEditor ) => void;\n\tonBlur?: ( event: EventInfo, editor: TEditor ) => void;\n}\n\ninterface ErrorDetails {\n\tphase: 'initialization' | 'runtime';\n\twillEditorRestart?: boolean;\n}\n\n/**\n * An adapter aligning the context watchdog API to the editor watchdog API for easier usage.\n */\nexport class EditorWatchdogAdapter<TEditor extends Editor> {\n\t/**\n\t * The context watchdog instance that will be wrapped into editor watchdog API.\n\t */\n\tprivate readonly _contextWatchdog: ContextWatchdog;\n\n\t/**\n\t * A unique id for the adapter to distinguish editor items when using the context watchdog API.\n\t */\n\tprivate readonly _id: string;\n\n\t/**\n\t * A watchdog's editor creator function.\n\t */\n\tprivate _creator?: EditorCreatorFunction;\n\n\t/**\n\t * @param contextWatchdog The context watchdog instance that will be wrapped into editor watchdog API.\n\t */\n\tconstructor( contextWatchdog: ContextWatchdog ) {\n\t\tthis._contextWatchdog = contextWatchdog;\n\t\tthis._id = uid();\n\t}\n\n\t/**\n\t *  @param creator A watchdog's editor creator function.\n\t */\n\tpublic setCreator( creator: EditorCreatorFunction ): void {\n\t\tthis._creator = creator;\n\t}\n\n\t/**\n\t * Adds an editor configuration to the context watchdog registry. Creates an instance of it.\n\t *\n\t * @param sourceElementOrData A source element or data for the new editor.\n\t * @param config CKEditor 5 editor config.\n\t */\n\tpublic create( sourceElementOrData: HTMLElement | string, config: EditorConfig ): Promise<unknown> {\n\t\treturn this._contextWatchdog.add( {\n\t\t\tsourceElementOrData,\n\t\t\tconfig,\n\t\t\tcreator: this._creator!,\n\t\t\tid: this._id,\n\t\t\ttype: 'editor'\n\t\t} );\n\t}\n\n\t/**\n\t * Creates a listener that is attached to context watchdog's item and run when the context watchdog fires.\n\t * Currently works only for the `error` event.\n\t */\n\tpublic on( _: string, callback: ( _: null, data: { error: Error; causesRestart?: boolean } ) => void ): void {\n\t\t// Assume that the event name was error.\n\t\tthis._contextWatchdog.on( 'itemError', ( _, { itemId, error } ) => {\n\t\t\tif ( itemId === this._id ) {\n\t\t\t\tcallback( null, { error, causesRestart: undefined } );\n\t\t\t}\n\t\t} );\n\t}\n\n\tpublic destroy(): Promise<unknown> {\n\t\t// Destroying an editor instance after destroying the Context is handled in the `ContextWatchdog` class.\n\t\t// As `EditorWatchdogAdapter` is an adapter, we should not destroy the editor manually.\n\t\t// Otherwise, it causes that the editor is destroyed twice. However, there is a case, when the editor\n\t\t// needs to be removed from the context, without destroying the context itself. We may assume the following\n\t\t// relations with `ContextWatchdog#state`:\n\t\t//\n\t\t// a) `ContextWatchdog#state` === 'ready' - context is not destroyed; it's safe to destroy the editor manually.\n\t\t// b) `ContextWatchdog#state` === 'destroyed' - context is destroyed; let `ContextWatchdog` handle the whole process.\n\t\t//\n\t\t// See #354 for more information.\n\t\tif ( this._contextWatchdog.state === 'ready' ) {\n\t\t\treturn this._contextWatchdog.remove( this._id );\n\t\t}\n\n\t\treturn Promise.resolve();\n\t}\n\n\t/**\n\t * An editor instance.\n\t */\n\tpublic get editor(): TEditor {\n\t\treturn this._contextWatchdog.getItem( this._id ) as TEditor;\n\t}\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\nimport type { MutableRefObject } from 'react';\n\ntype CallbackRef<T> = ( element: T ) => void;\n\ntype ReactRef<T> = CallbackRef<T | null> | MutableRefObject<T | null> | null;\n\n/**\n * Combine multiple react refs into one.\n */\nexport function mergeRefs<T>( ...refs: Array<ReactRef<T>> ): CallbackRef<T> {\n\treturn value => {\n\t\trefs.forEach( ref => {\n\t\t\tif ( typeof ref === 'function' ) {\n\t\t\t\tref( value );\n\t\t\t} else if ( ref != null ) {\n\t\t\t\tref.current = value;\n\t\t\t}\n\t\t} );\n\t};\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * Clears whole object while keeping its reference.\n */\nexport function overwriteObject<O extends Record<string, any>>( source: O, destination: O ): O {\n\tfor ( const prop of Object.getOwnPropertyNames( destination ) ) {\n\t\tdelete destination[ prop ];\n\t}\n\n\t// Prevent assigning self referencing attributes which crashes `Object.assign`.\n\tfor ( const [ key, value ] of Object.entries( source ) ) {\n\t\tif ( value !== destination && key !== 'prototype' && key !== '__proto__' ) {\n\t\t\t( destination as any )[ key ] = value;\n\t\t}\n\t}\n\n\treturn destination;\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\nimport { useCallback, useRef } from 'react';\n\n/**\n * Hook that guarantees that returns constant reference for passed function.\n * Useful for preventing closures from capturing cached scope variables (avoiding the stale closure problem).\n */\nexport const useRefSafeCallback = <A extends Array<unknown>, R>( fn: ( ...args: A ) => R ): typeof fn => {\n\tconst callbackRef = useRef<typeof fn>();\n\tcallbackRef.current = fn;\n\n\treturn useCallback(\n\t\t( ...args: A ): R => ( callbackRef.current as typeof fn )( ...args ),\n\t\t[]\n\t);\n};\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * Clear whole array while keeping its reference.\n */\nexport function overwriteArray<A extends Array<any>>( source: A, destination: A ): A {\n\tdestination.length = 0;\n\tdestination.push( ...source );\n\n\treturn destination;\n}\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * Shallow comparison of two arrays.\n */\nexport const shallowCompareArrays = <T>(\n\ta: Readonly<Array<T>>,\n\tb: Readonly<Array<T>>\n): boolean => {\n\tif ( a === b ) {\n\t\treturn true;\n\t}\n\n\tif ( !a || !b ) {\n\t\treturn false;\n\t}\n\n\tfor ( let i = 0; i < a.length; ++i ) {\n\t\tif ( a[ i ] !== b[ i ] ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n};\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\nimport type { DependencyList } from 'react';\nimport type { LifeCycleElementSemaphore } from '../lifecycle/LifeCycleElementSemaphore';\nimport { useInstantEffect } from './useInstantEffect';\n\n/**\n * `useEffect` alternative but executed after mounting of editor.\n */\nexport const useInstantEditorEffect = <R>(\n\tsemaphore: LifeCycleElementSemaphore<R> | null,\n\tfn: ( mountResult: R ) => void,\n\tdeps: DependencyList\n): void => {\n\tuseInstantEffect( () => {\n\t\tif ( semaphore ) {\n\t\t\tsemaphore.runAfterMount( fn );\n\t\t}\n\t}, [ semaphore, ...deps ] );\n};\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\nimport { useRef, type DependencyList } from 'react';\nimport { shallowCompareArrays } from '../utils/shallowCompareArrays';\n\n/**\n * Triggers an effect immediately if the dependencies change (during rendering of component).\n *\n * @param fn The effect function to execute.\n * @param deps The dependency list.\n */\nexport const useInstantEffect = ( fn: VoidFunction, deps: DependencyList ): void => {\n\tconst prevDeps = useRef<any>( null );\n\n\tif ( !shallowCompareArrays( prevDeps.current, deps ) ) {\n\t\tprevDeps.current = [ ...deps ];\n\t\tfn();\n\t}\n};\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\nimport React, {\n\tforwardRef, useState, useEffect, useRef, useContext, useCallback, memo,\n\ttype Dispatch, type SetStateAction, type RefObject\n} from 'react';\n\nimport type {\n\tInlineEditableUIView,\n\tEditorConfig,\n\tDocumentChangeEvent,\n\tWriter,\n\tRootElement,\n\tContextWatchdog,\n\tEditorWatchdog,\n\tWatchdogConfig,\n\tAddRootEvent,\n\tDetachRootEvent,\n\tMultiRootEditor,\n\tEventInfo\n} from 'ckeditor5';\n\nimport { ContextWatchdogContext } from './ckeditorcontext';\nimport { EditorWatchdogAdapter } from './ckeditor';\n\nimport type { EditorSemaphoreMountResult } from './lifecycle/LifeCycleEditorSemaphore';\n\nimport { useLifeCycleSemaphoreSyncRef, type LifeCycleSemaphoreSyncRefResult } from './lifecycle/useLifeCycleSemaphoreSyncRef';\nimport { mergeRefs } from './utils/mergeRefs';\nimport { LifeCycleElementSemaphore } from './lifecycle/LifeCycleElementSemaphore';\nimport { overwriteObject } from './utils/overwriteObject';\nimport { useRefSafeCallback } from './hooks/useRefSafeCallback';\nimport { uniq } from './utils/uniq';\nimport { overwriteArray } from './utils/overwriteArray';\nimport { useInstantEditorEffect } from './hooks/useInstantEditorEffect';\n\nconst REACT_INTEGRATION_READ_ONLY_LOCK_ID = 'Lock from React integration (@ckeditor/ckeditor5-react)';\n\n/* eslint-disable @typescript-eslint/no-use-before-define */\nconst useMultiRootEditor = ( props: MultiRootHookProps ): MultiRootHookReturns => {\n\tconst semaphoreElementRef = useRef<HTMLElement>( props.semaphoreElement || null );\n\tconst semaphore = useLifeCycleSemaphoreSyncRef<LifeCycleMountResult>();\n\n\tconst editorRefs: LifeCycleSemaphoreRefs<MultiRootEditor> = {\n\t\twatchdog: semaphore.createAttributeRef( 'watchdog' ),\n\t\tinstance: semaphore.createAttributeRef( 'instance' )\n\t};\n\n\tconst context = useContext( ContextWatchdogContext );\n\n\t// List of editor root elements.\n\tconst [ roots, setRoots ] = useState<Array<string>>( () => Object.keys( props.data ) );\n\n\t// Current editor data. An object where each key is a root name and the value is the root content.\n\tconst [ data, setData ] = useState<Record<string, string>>( { ...props.data } );\n\n\t// Current roots attributes. An object where each key is a root name and the value is an object with root attributes.\n\tconst [ attributes, setAttributes ] = useState<Record<string, Record<string, unknown>>>( { ...props.rootsAttributes } );\n\n\tconst shouldUpdateEditor = useRef<boolean>( true );\n\n\tuseEffect( () => {\n\t\tconst semaphoreElement = semaphoreElementRef.current;\n\n\t\tif ( !semaphoreElement || props.isLayoutReady === false ) {\n\t\t\treturn;\n\t\t}\n\n\t\tsemaphore.replace( () => new LifeCycleElementSemaphore( semaphoreElement, {\n\t\t\tmount: _initializeEditor,\n\t\t\tafterMount: ( { mountResult } ) => {\n\t\t\t\tconst { onReady } = props;\n\n\t\t\t\tif ( onReady && semaphoreElementRef.current !== null ) {\n\t\t\t\t\tonReady( mountResult.instance );\n\t\t\t\t}\n\t\t\t},\n\t\t\tunmount: async ( { element, mountResult } ) => {\n\t\t\t\tconst { onAfterDestroy } = props;\n\n\t\t\t\ttry {\n\t\t\t\t\tawait _destroyEditor( mountResult );\n\n\t\t\t\t\t/**\n\t\t\t\t\t * Make sure that nothing left in actual editor element. There can be custom integrations that\n\t\t\t\t\t * appends something to container. Let's reset element every update cycle before mounting another\n\t\t\t\t\t * editor instance.\n\t\t\t\t\t */\n\t\t\t\t\telement.innerHTML = '';\n\t\t\t\t} finally {\n\t\t\t\t\t/**\n\t\t\t\t\t * Broadcast information about destroying current instance. It is useful for removing duplicated\n\t\t\t\t\t * toolbars in decoupled editor mode.\n\t\t\t\t\t */\n\t\t\t\t\tif ( onAfterDestroy ) {\n\t\t\t\t\t\tonAfterDestroy( mountResult.instance );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} ) );\n\n\t\treturn () => {\n\t\t\tsemaphore.release( false );\n\t\t};\n\t}, [ props.id, props.isLayoutReady ] );\n\n\t/**\n\t * Returns the editor configuration.\n\t */\n\tconst _getConfig = (): EditorConfig => {\n\t\tconst config = props.config || {};\n\n\t\tif ( props.data && config.initialData ) {\n\t\t\tconsole.warn(\n\t\t\t\t'Editor data should be provided either using `config.initialData` or `data` property. ' +\n\t\t\t\t'The config value takes precedence over `data` property and will be used when both are specified.'\n\t\t\t);\n\t\t}\n\n\t\treturn {\n\t\t\t...config,\n\t\t\trootsAttributes: attributes\n\t\t};\n\t};\n\n\t/**\n\t * Callback function for handling changed data and attributes in the editor.\n\t */\n\tconst onChangeData = useRefSafeCallback( ( editor: MultiRootEditor, event: EventInfo ): void => {\n\t\tconst modelDocument = editor!.model.document;\n\n\t\tif ( !props.disableTwoWayDataBinding ) {\n\t\t\tconst newData: Record<string, string> = {};\n\t\t\tconst newAttributes: Record<string, Record<string, unknown>> = {};\n\n\t\t\tmodelDocument.differ.getChanges()\n\t\t\t\t.forEach( change => {\n\t\t\t\t\tlet root: RootElement;\n\n\t\t\t\t\tif ( change.type == 'insert' || change.type == 'remove' ) {\n\t\t\t\t\t\troot = change.position.root as RootElement;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Must be `attribute` diff item.\n\t\t\t\t\t\troot = change.range.root as RootElement;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Getting data from a not attached root will trigger a warning.\n\t\t\t\t\t// There is another callback for handling detached roots.\n\t\t\t\t\tif ( !root.isAttached() ) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst { rootName } = root;\n\n\t\t\t\t\tnewData[ rootName ] = editor!.getData( { rootName } );\n\t\t\t\t} );\n\n\t\t\tmodelDocument.differ.getChangedRoots()\n\t\t\t\t.forEach( changedRoot => {\n\t\t\t\t\t// Ignore added and removed roots. They are handled by a different function.\n\t\t\t\t\t// Only register if roots attributes changed.\n\t\t\t\t\tif ( changedRoot.state ) {\n\t\t\t\t\t\tif ( newData[ changedRoot.name ] !== undefined ) {\n\t\t\t\t\t\t\tdelete newData[ changedRoot.name ];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst rootName = changedRoot.name;\n\n\t\t\t\t\tnewAttributes[ rootName ] = editor!.getRootAttributes( rootName );\n\t\t\t\t} );\n\n\t\t\tif ( Object.keys( newData ).length ) {\n\t\t\t\tsetData( previousData => ( { ...previousData, ...newData } ) );\n\t\t\t}\n\n\t\t\tif ( Object.keys( newAttributes ).length ) {\n\t\t\t\tsetAttributes( previousAttributes => ( { ...previousAttributes, ...newAttributes } ) );\n\t\t\t}\n\t\t}\n\n\t\t/* istanbul ignore else */\n\t\tif ( props.onChange ) {\n\t\t\tprops.onChange( event, editor! );\n\t\t}\n\t} );\n\n\t/**\n\t * Callback function for handling an added root.\n\t */\n\tconst onAddRoot = useRefSafeCallback( ( editor: MultiRootEditor, evt: EventInfo, root: RootElement ): void => {\n\t\tconst rootName = root.rootName;\n\n\t\tif ( !props.disableTwoWayDataBinding ) {\n\t\t\tsetData( previousData =>\n\t\t\t\t( { ...previousData, [ rootName ]: editor!.getData( { rootName } ) } )\n\t\t\t);\n\n\t\t\tsetAttributes( previousAttributes =>\n\t\t\t\t( { ...previousAttributes, [ rootName ]: editor!.getRootAttributes( rootName ) } )\n\t\t\t);\n\t\t}\n\n\t\tsetRoots( prevRoots => uniq( [ ...prevRoots, root.rootName ] ) );\n\t} );\n\n\t/**\n\t * Callback function for handling a detached root.\n\t */\n\tconst onDetachRoot = useRefSafeCallback( ( editor: MultiRootEditor, evt: EventInfo, root: RootElement ): void => {\n\t\tconst rootName = root.rootName;\n\n\t\tif ( !props.disableTwoWayDataBinding ) {\n\t\t\tsetData( previousData => {\n\t\t\t\tconst { [ rootName! ]: _, ...newData } = previousData;\n\n\t\t\t\treturn { ...newData };\n\t\t\t} );\n\n\t\t\tsetAttributes( previousAttributes => {\n\t\t\t\tconst { [ rootName! ]: _, ...newAttributes } = previousAttributes;\n\n\t\t\t\treturn { ...newAttributes };\n\t\t\t} );\n\t\t}\n\n\t\tsetRoots( prevRoots => prevRoots.filter( root => root !== rootName ) );\n\t} );\n\n\t/**\n\t * Creates an editor using initial elements or data, and configuration.\n\t *\n\t * @param initialData The initial data.\n\t * @param config CKEditor 5 editor configuration.\n\t */\n\tconst _createEditor = useRefSafeCallback( (\n\t\tinitialData: Record<string, string> | Record<string, HTMLElement>,\n\t\tconfig: EditorConfig\n\t): Promise<MultiRootEditor> => {\n\t\toverwriteObject( { ...props.rootsAttributes }, attributes );\n\t\toverwriteObject( { ...props.data }, data );\n\t\toverwriteArray( Object.keys( props.data ), roots );\n\n\t\treturn props.editor.create( initialData, config )\n\t\t\t.then( ( editor: MultiRootEditor ) => {\n\t\t\t\tconst editorData = editor.getFullData();\n\n\t\t\t\t// Rerender will be called anyway.\n\t\t\t\toverwriteObject( { ...editorData }, data );\n\t\t\t\toverwriteObject( { ...editor.getRootsAttributes() }, attributes );\n\t\t\t\toverwriteArray( Object.keys( editorData ), roots );\n\n\t\t\t\tif ( props.disabled ) {\n\t\t\t\t\t// Switch to the read-only mode if the `[disabled]` attribute is specified.\n\t\t\t\t\t/* istanbul ignore else */\n\t\t\t\t\teditor.enableReadOnlyMode( REACT_INTEGRATION_READ_ONLY_LOCK_ID );\n\t\t\t\t}\n\n\t\t\t\tconst modelDocument = editor.model.document;\n\t\t\t\tconst viewDocument = editor.editing.view.document;\n\n\t\t\t\tmodelDocument.on<DocumentChangeEvent>( 'change:data', evt => onChangeData( editor, evt ) );\n\n\t\t\t\teditor.on<AddRootEvent>( 'addRoot', ( evt, root ) => onAddRoot( editor, evt, root ) );\n\t\t\t\teditor.on<DetachRootEvent>( 'detachRoot', ( evt, root ) => onDetachRoot( editor, evt, root ) );\n\n\t\t\t\tviewDocument.on( 'focus', event => {\n\t\t\t\t\t/* istanbul ignore else */\n\t\t\t\t\tif ( props.onFocus ) {\n\t\t\t\t\t\tprops.onFocus( event, editor );\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\tviewDocument.on( 'blur', event => {\n\t\t\t\t\t/* istanbul ignore else */\n\t\t\t\t\tif ( props.onBlur ) {\n\t\t\t\t\t\tprops.onBlur( event, editor );\n\t\t\t\t\t}\n\t\t\t\t} );\n\n\t\t\t\treturn editor;\n\t\t\t} );\n\t} );\n\n\t/**\n\t * Destroys the editor by destroying the watchdog.\n\t */\n\tconst _destroyEditor = ( initializeResult: EditorSemaphoreMountResult<MultiRootEditor> ): Promise<void> => {\n\t\tconst { watchdog, instance } = initializeResult;\n\n\t\treturn new Promise<void>( ( resolve, reject ) => {\n\t\t\t// It may happen during the tests that the watchdog instance is not assigned before destroying itself. See: #197.\n\t\t\t//\n\t\t\t// Additionally, we need to find a way to detect if the whole context has been destroyed. As `componentWillUnmount()`\n\t\t\t// could be fired by <CKEditorContext /> and <CKEditor /> at the same time, this `setTimeout()` makes sure\n\t\t\t// that <CKEditorContext /> component will be destroyed first, so during the code execution\n\t\t\t// the `ContextWatchdog#state` would have a correct value. See `EditorWatchdogAdapter#destroy()` for more information.\n\t\t\t/* istanbul ignore next */\n\t\t\tsetTimeout( async () => {\n\t\t\t\ttry {\n\t\t\t\t\tif ( watchdog ) {\n\t\t\t\t\t\tawait watchdog.destroy();\n\t\t\t\t\t\treturn resolve();\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( instance ) {\n\t\t\t\t\t\tawait instance.destroy();\n\t\t\t\t\t\treturn resolve();\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve();\n\t\t\t\t} catch ( e ) {\n\t\t\t\t\tconsole.error( e );\n\t\t\t\t\treject( e );\n\t\t\t\t}\n\t\t\t} );\n\t\t} );\n\t};\n\n\t/**\n\t * Initializes the editor by creating a proper watchdog and initializing it with the editor's configuration.\n\t */\n\tconst _initializeEditor = async (): Promise<LifeCycleMountResult> => {\n\t\tif ( props.disableWatchdog ) {\n\t\t\tconst instance = await _createEditor( props.data as any, _getConfig() );\n\n\t\t\treturn {\n\t\t\t\tinstance: instance as MultiRootEditor,\n\t\t\t\twatchdog: null\n\t\t\t};\n\t\t}\n\n\t\tconst watchdog = ( () => {\n\t\t\tif ( context instanceof props.editor.ContextWatchdog ) {\n\t\t\t\treturn new EditorWatchdogAdapter( context );\n\t\t\t}\n\n\t\t\treturn new props.editor.EditorWatchdog( props.editor, props.watchdogConfig );\n\t\t} )() as EditorWatchdogAdapter<MultiRootEditor>;\n\n\t\tconst totalRestartsRef = {\n\t\t\tcurrent: 0\n\t\t};\n\n\t\twatchdog.setCreator( async ( data, config ) => {\n\t\t\tconst { onAfterDestroy } = props;\n\n\t\t\tif ( totalRestartsRef.current > 0 && onAfterDestroy && editorRefs.instance.current ) {\n\t\t\t\tonAfterDestroy( editorRefs.instance.current );\n\t\t\t}\n\n\t\t\tconst instance = await _createEditor( data as any, config );\n\n\t\t\tif ( totalRestartsRef.current > 0 ) {\n\t\t\t\tsemaphore.unsafeSetValue( {\n\t\t\t\t\tinstance,\n\t\t\t\t\twatchdog\n\t\t\t\t} );\n\n\t\t\t\tsetTimeout( () => {\n\t\t\t\t\tif ( props.onReady ) {\n\t\t\t\t\t\tprops.onReady( watchdog!.editor );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\ttotalRestartsRef.current++;\n\t\t\treturn instance;\n\t\t} );\n\n\t\twatchdog.on( 'error', ( _, { error, causesRestart } ) => {\n\t\t\tconst onError = props.onError || console.error;\n\t\t\tonError( error, { phase: 'runtime', willEditorRestart: causesRestart } );\n\t\t} );\n\n\t\tawait watchdog\n\t\t\t.create( data as any, _getConfig() )\n\t\t\t.catch( error => {\n\t\t\t\tconst onError = props.onError || console.error;\n\t\t\t\tonError( error, { phase: 'initialization', willEditorRestart: false } );\n\t\t\t\tthrow error;\n\t\t\t} );\n\n\t\treturn {\n\t\t\twatchdog,\n\t\t\tinstance: watchdog!.editor\n\t\t};\n\t};\n\n\tconst _getStateDiff = (\n\t\tpreviousState: Record<string, unknown>,\n\t\tnewState: Record<string, unknown>\n\t): {\n\t\taddedKeys: Array<string>;\n\t\tremovedKeys: Array<string>;\n\t} => {\n\t\tconst previousStateKeys = Object.keys( previousState );\n\t\tconst newStateKeys = Object.keys( newState );\n\n\t\treturn {\n\t\t\taddedKeys: newStateKeys.filter( key => !previousStateKeys.includes( key ) ),\n\t\t\tremovedKeys: previousStateKeys.filter( key => !newStateKeys.includes( key ) )\n\t\t};\n\t};\n\n\tconst _externalSetData: Dispatch<SetStateAction<Record<string, string>>> = useCallback(\n\t\tnewData => {\n\t\t\tsemaphore.runAfterMount( () => {\n\t\t\t\tshouldUpdateEditor.current = true;\n\t\t\t\tsetData( newData );\n\t\t\t} );\n\t\t},\n\t\t[ setData ]\n\t);\n\n\tconst _externalSetAttributes: Dispatch<SetStateAction<Record<string, Record<string, unknown>>>> = useCallback(\n\t\tnewAttributes => {\n\t\t\tsemaphore.runAfterMount( () => {\n\t\t\t\tshouldUpdateEditor.current = true;\n\t\t\t\tsetAttributes( newAttributes );\n\t\t\t} );\n\t\t},\n\t\t[ setAttributes ]\n\t);\n\n\tconst toolbarElement = (\n\t\t<EditorToolbarWrapper\n\t\t\tref={ semaphoreElementRef }\n\t\t\teditor={editorRefs.instance.current}\n\t\t/>\n\t);\n\n\tuseInstantEditorEffect( semaphore.current, ( { instance } ) => {\n\t\tif ( props.disabled ) {\n\t\t\tinstance.enableReadOnlyMode( REACT_INTEGRATION_READ_ONLY_LOCK_ID );\n\t\t} else {\n\t\t\tinstance.disableReadOnlyMode( REACT_INTEGRATION_READ_ONLY_LOCK_ID );\n\t\t}\n\t}, [ props.disabled ] );\n\n\tuseInstantEditorEffect( semaphore.current, ( { instance } ) => {\n\t\t// Editor should be only updated when the changes come from the integrator React application.\n\t\tif ( shouldUpdateEditor.current ) {\n\t\t\tshouldUpdateEditor.current = false;\n\n\t\t\tconst dataKeys = Object.keys( data );\n\t\t\tconst attributesKeys = Object.keys( attributes );\n\n\t\t\t// Check if `data` and `attributes` have the same keys.\n\t\t\t//\n\t\t\t// It prevents the addition of attributes for non-existing roots.\n\t\t\t// If the `data` object has a different set of keys, an error will not be thrown\n\t\t\t// since the attributes will be removed/added during root initialization/destruction.\n\t\t\tif ( !dataKeys.every( key => attributesKeys.includes( key ) ) ) {\n\t\t\t\tconsole.error( '`data` and `attributes` objects must have the same keys (roots).' );\n\t\t\t\tthrow new Error( '`data` and `attributes` objects must have the same keys (roots).' );\n\t\t\t}\n\n\t\t\tconst editorData = instance.getFullData();\n\t\t\tconst editorAttributes = instance.getRootsAttributes();\n\n\t\t\tconst {\n\t\t\t\taddedKeys: newRoots,\n\t\t\t\tremovedKeys: removedRoots\n\t\t\t} = _getStateDiff( editorData, data || {} );\n\n\t\t\tconst hasModifiedData = dataKeys.some( rootName =>\n\t\t\t\teditorData[ rootName ] !== undefined &&\n\t\t\t\tJSON.stringify( editorData[ rootName ] ) !== JSON.stringify( data[ rootName ] )\n\t\t\t);\n\n\t\t\tconst rootsWithChangedAttributes = attributesKeys.filter( rootName =>\n\t\t\t\tJSON.stringify( editorAttributes[ rootName ] ) !== JSON.stringify( attributes[ rootName ] ) );\n\n\t\t\tconst _handleNewRoots = ( roots: Array<string> ) => {\n\t\t\t\troots.forEach( rootName => {\n\t\t\t\t\tinstance!.addRoot( rootName, {\n\t\t\t\t\t\tdata: data[ rootName ] || '',\n\t\t\t\t\t\tattributes: attributes?.[ rootName ] || {},\n\t\t\t\t\t\tisUndoable: true\n\t\t\t\t\t} );\n\t\t\t\t} );\n\t\t\t};\n\n\t\t\tconst _handleRemovedRoots = ( roots: Array<string> ) => {\n\t\t\t\troots.forEach( rootName => {\n\t\t\t\t\tinstance!.detachRoot( rootName, true );\n\t\t\t\t} );\n\t\t\t};\n\n\t\t\tconst _updateEditorData = () => {\n\t\t\t\t// If any of the roots content has changed, set the editor data.\n\t\t\t\t// Unfortunately, we cannot set the editor data just for one root,\n\t\t\t\t// so we need to overwrite all roots (`nextProps.data` is an\n\t\t\t\t// object with data for each root).\n\t\t\t\tinstance.data.set( data, { suppressErrorInCollaboration: true } as any );\n\t\t\t};\n\n\t\t\tconst _updateEditorAttributes = ( writer: Writer, roots: Array<string> ) => {\n\t\t\t\troots.forEach( rootName => {\n\t\t\t\t\tObject.keys( attributes![ rootName ] ).forEach( attr => {\n\t\t\t\t\t\tinstance.registerRootAttribute( attr );\n\t\t\t\t\t} );\n\n\t\t\t\t\twriter.clearAttributes( instance.model.document.getRoot( rootName )! );\n\t\t\t\t\twriter.setAttributes( attributes![ rootName ], instance.model.document.getRoot( rootName )! );\n\t\t\t\t} );\n\t\t\t};\n\n\t\t\t// React struggles with rerendering during `instance.model.change` callbacks.\n\t\t\tsetTimeout( () => {\n\t\t\t\tinstance.model.change( writer => {\n\t\t\t\t\t_handleNewRoots( newRoots );\n\t\t\t\t\t_handleRemovedRoots( removedRoots );\n\n\t\t\t\t\tif ( hasModifiedData ) {\n\t\t\t\t\t\t_updateEditorData();\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( rootsWithChangedAttributes.length ) {\n\t\t\t\t\t\t_updateEditorAttributes( writer, rootsWithChangedAttributes );\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t} );\n\t\t}\n\t}, [ data, attributes ] );\n\n\tconst editableElements = roots.map(\n\t\trootName => (\n\t\t\t<EditorEditable\n\t\t\t\tkey={rootName}\n\t\t\t\tid={rootName}\n\t\t\t\trootName={rootName}\n\t\t\t\tsemaphore={semaphore}\n\t\t\t/>\n\t\t)\n\t);\n\n\treturn {\n\t\teditor: editorRefs.instance.current,\n\t\teditableElements,\n\t\ttoolbarElement,\n\t\tdata, setData: _externalSetData,\n\t\tattributes, setAttributes: _externalSetAttributes\n\t};\n};\n\nconst EditorEditable = memo( forwardRef( ( { id, semaphore, rootName }: {\n\tid: string;\n\trootName: string;\n\tsemaphore: LifeCycleSemaphoreSyncRefResult<LifeCycleMountResult>;\n}, ref ) => {\n\tconst innerRef = useRef<HTMLDivElement>( null );\n\n\tuseEffect( () => {\n\t\tlet editable: InlineEditableUIView | null;\n\t\tlet editor: MultiRootEditor | null;\n\n\t\tsemaphore.runAfterMount( ( { instance } ) => {\n\t\t\tif ( innerRef.current ) {\n\t\t\t\teditor = instance;\n\t\t\t\teditable = instance.ui.view.createEditable( rootName, innerRef.current );\n\n\t\t\t\tinstance.ui.addEditable( editable );\n\t\t\t\tinstance.editing.view.forceRender();\n\t\t\t}\n\t\t} );\n\n\t\treturn () => {\n\t\t\tif ( editable && innerRef.current && editor && editor.state !== 'destroyed' ) {\n\t\t\t\teditor.ui.removeEditable( editable );\n\t\t\t}\n\t\t};\n\t}, [ semaphore.revision ] );\n\n\treturn (\n\t\t<div\n\t\t\tkey={semaphore.revision}\n\t\t\tid={id}\n\t\t\tref={ mergeRefs( ref, innerRef ) }\n\t\t/>\n\t);\n} ) );\n\nEditorEditable.displayName = 'EditorEditable';\n\nconst EditorToolbarWrapper = forwardRef( ( { editor }: any, ref ) => {\n\tconst toolbarRef = useRef<HTMLDivElement>( null );\n\n\tuseEffect( () => {\n\t\tconst toolbarContainer = toolbarRef.current;\n\n\t\tif ( !editor || !toolbarContainer ) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tconst element = editor.ui.view.toolbar.element!;\n\n\t\tif ( toolbarContainer ) {\n\t\t\ttoolbarContainer.appendChild( element! );\n\t\t}\n\n\t\treturn () => {\n\t\t\tif ( toolbarContainer ) {\n\t\t\t\ttoolbarContainer.removeChild( element! );\n\t\t\t}\n\t\t};\n\t}, [ editor && editor.id ] );\n\n\treturn <div ref={mergeRefs( toolbarRef, ref )}></div>;\n} );\n\nEditorToolbarWrapper.displayName = 'EditorToolbarWrapper';\n\nexport default useMultiRootEditor;\n\ntype LifeCycleMountResult = EditorSemaphoreMountResult<MultiRootEditor>;\n\ntype LifeCycleSemaphoreRefs<TEditor extends MultiRootEditor> = {\n\t[ K in keyof EditorSemaphoreMountResult<TEditor> ]: RefObject<EditorSemaphoreMountResult<TEditor>[ K ]>\n};\n\ninterface ErrorDetails {\n\tphase: 'initialization' | 'runtime';\n\twillEditorRestart?: boolean;\n}\n\nexport type MultiRootHookProps = {\n\tid?: any;\n\tsemaphoreElement?: HTMLElement;\n\n\tisLayoutReady?: boolean;\n\tdisabled?: boolean;\n\tdata: Record<string, string>;\n\trootsAttributes?: Record<string, Record<string, unknown>>;\n\teditor: typeof MultiRootEditor;\n\twatchdogConfig?: WatchdogConfig;\n\tdisableWatchdog?: boolean;\n\tdisableTwoWayDataBinding?: boolean;\n\n\tonReady?: ( editor: MultiRootEditor ) => void;\n\tonAfterDestroy?: ( editor: MultiRootEditor ) => void;\n\tonError?: ( error: Error, details: ErrorDetails ) => void;\n\tonChange?: ( event: EventInfo, editor: MultiRootEditor ) => void;\n\tonFocus?: ( event: EventInfo, editor: MultiRootEditor ) => void;\n\tonBlur?: ( event: EventInfo, editor: MultiRootEditor ) => void;\n\n\tconfig?: Record<string, unknown>;\n};\n\nexport type MultiRootHookReturns = {\n\teditor: MultiRootEditor | null;\n\teditableElements: Array<JSX.Element>;\n\ttoolbarElement: JSX.Element;\n\tdata: Record<string, string>;\n\tsetData: Dispatch<SetStateAction<Record<string, string>>>;\n\tattributes: Record<string, Record<string, unknown>>;\n\tsetAttributes: Dispatch<SetStateAction<Record<string, Record<string, unknown>>>>;\n};\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\nimport { useRef, useState, type RefObject } from 'react';\nimport type { LifeCycleElementSemaphore, LifeCycleAfterMountCallback } from './LifeCycleElementSemaphore';\n\n/**\n * When using the `useState` approach, a new instance of the semaphore must be set based on the previous\n * one within the `setState` callback, as shown in this example:\n *\n * \t\tsetState( prevSemaphore => ... )\n *\n * The issue arises from the uncertainty of whether React has batched and cancelled some `setState` calls.\n * This means that setting the state with a semaphore three times might result in the collapsing of these three calls into a single one.\n *\n * Although this may not seem like a significant issue in theory, it can lead to a multitude of minor issues in practice that may\n * generate race conditions. This is because semaphores handle batching independently.\n *\n * A solution involving refs is safer in terms of preserving object references. In other words, `semaphoreRef.current` is guaranteed to\n * always point to the most recent instance of the semaphore.\n */\nexport const useLifeCycleSemaphoreSyncRef = <R extends object>(): LifeCycleSemaphoreSyncRefResult<R> => {\n\tconst semaphoreRef = useRef<LifeCycleElementSemaphore<R> | null>( null );\n\tconst [ revision, setRevision ] = useState( () => Date.now() );\n\n\tconst refresh = () => {\n\t\tsetRevision( Date.now() );\n\t};\n\n\tconst release = ( rerender: boolean = true ) => {\n\t\tif ( semaphoreRef.current ) {\n\t\t\tsemaphoreRef.current.release();\n\t\t\tsemaphoreRef.current = null;\n\t\t}\n\n\t\tif ( rerender ) {\n\t\t\tsetRevision( Date.now() );\n\t\t}\n\t};\n\n\tconst unsafeSetValue = ( value: R ) => {\n\t\tsemaphoreRef.current?.unsafeSetValue( value );\n\t\trefresh();\n\t};\n\n\tconst runAfterMount = ( callback: LifeCycleAfterMountCallback<R> ) => {\n\t\tif ( semaphoreRef.current ) {\n\t\t\tsemaphoreRef.current.runAfterMount( callback );\n\t\t}\n\t};\n\n\tconst replace = ( newSemaphore: () => LifeCycleElementSemaphore<R> ) => {\n\t\trelease( false );\n\t\tsemaphoreRef.current = newSemaphore();\n\n\t\trefresh();\n\t\trunAfterMount( refresh );\n\t};\n\n\tconst createAttributeRef = <K extends keyof R>( key: K ): RefObject<R[ K ]> => ( {\n\t\tget current() {\n\t\t\tif ( !semaphoreRef.current || !semaphoreRef.current.value ) {\n\t\t\t\treturn null;\n\t\t\t}\n\n\t\t\treturn semaphoreRef.current.value[ key ];\n\t\t}\n\t} );\n\n\treturn {\n\t\tget current() {\n\t\t\treturn semaphoreRef.current;\n\t\t},\n\t\trevision,\n\t\tcreateAttributeRef,\n\t\tunsafeSetValue,\n\t\trelease,\n\t\treplace,\n\t\trunAfterMount\n\t};\n};\n\nexport type LifeCycleSemaphoreSyncRefResult<R> = RefObject<LifeCycleElementSemaphore<R>> & {\n\trevision: number;\n\tunsafeSetValue: ( value: R ) => void;\n\trunAfterMount: ( callback: LifeCycleAfterMountCallback<R> ) => void;\n\trelease: ( rerender?: boolean ) => void;\n\treplace: ( newSemaphore: () => LifeCycleElementSemaphore<R> ) => void;\n\tcreateAttributeRef: <K extends keyof R>( key: K ) => RefObject<R[ K ]>;\n};\n", "/**\n * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.\n * For licensing, see LICENSE.md.\n */\n\n/**\n * A utility function that removes duplicate elements from an array.\n */\nexport function uniq<A>( source: Array<A> ): Array<A> {\n\treturn Array.from( new Set( source ) );\n}\n"],
  "mappings": "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",
  "names": ["root", "factory", "exports", "module", "require", "define", "amd", "self", "__WEBPACK_EXTERNAL_MODULE__155__", "__WEBPACK_EXTERNAL_MODULE__949__", "t", "__webpack_module_cache__", "__webpack_require__", "moduleId", "cachedModule", "__webpack_modules__", "n", "getter", "__esModule", "d", "a", "definition", "key", "o", "Object", "defineProperty", "enumerable", "get", "obj", "prop", "prototype", "hasOwnProperty", "call", "r", "Symbol", "toStringTag", "value", "e", "HEX_NUMBERS", "Array", "fill", "map", "_", "index", "toString", "slice", "ContextWatchdogContext", "CKEditorContext", "props", "context", "super", "contextWatchdog", "this", "isLayoutReady", "_initializeContextWatchdog", "config", "nextProps", "_shouldComponentUpdate", "id", "destroy", "children", "render", "Provider", "componentWillUnmount", "_destroyContext", "watchdogConfig", "on", "errorEvent", "onError", "error", "phase", "willContextRestart", "causesRestart", "state", "onReady", "create", "catch", "defaultProps", "details", "console", "propTypes", "LifeCycleElementSemaphore", "element", "lifecycle", "_releaseLock", "_value", "_afterMountCallbacks", "_state", "destroyedBeforeInitialization", "mountingInProgress", "release", "fn", "lastResult", "args", "current", "_element", "_lifecycle", "then", "unmount", "mountResult", "resolve", "_lock", "forEach", "callback", "push", "_semaphores", "prevElementSemaphore", "Promise", "releaseLock", "deferred", "promise", "createDefer", "newElementSemaphore", "undefined", "mount", "unsafeSetValue", "async", "afterMount", "delete", "set", "Map", "REACT_INTEGRATION_READ_ONLY_LOCK_ID", "CKEditor", "domContainer", "editorSemaphore", "_checkVersion", "CKEDITOR_VERSION", "window", "warn", "major", "split", "Number", "startsWith", "_semaphoreValue", "watchdog", "editor", "instance", "disableWatchdog", "runAfterMount", "_shouldUpdateEditorData", "data", "disabled", "enableReadOnlyMode", "disableReadOnlyMode", "componentDidMount", "_initLifeCycleSemaphore", "componentDidUpdate", "_unlockLifeCycleSemaphore", "_initializeEditor", "onAfterDestroy", "_destroyEditor", "innerHTML", "ref", "_createEditor", "_getConfig", "ContextWatchdog", "EditorWatchdogAdapter", "EditorWatchdog", "totalRestartsRef", "setCreator", "el", "setTimeout", "willEditorRestart", "modelDocument", "model", "document", "viewDocument", "editing", "view", "event", "onChange", "onFocus", "onBlur", "initializeResult", "reject", "prevProps", "initialData", "contextType", "isRequired", "_contextWatchdog", "_id", "r1", "Math", "random", "r2", "r3", "r4", "uid", "creator", "_creator", "sourceElementOrData", "add", "type", "itemId", "remove", "getItem", "mergeRefs", "refs", "overwriteObject", "source", "destination", "getOwnPropertyNames", "entries", "useRefSafeCallback", "callbackRef", "useRef", "useCallback", "overwriteArray", "length", "useInstantEditorEffect", "semaphore", "deps", "prevDeps", "b", "i", "EditorEditable", "memo", "forwardRef", "rootName", "innerRef", "useEffect", "editable", "ui", "createEditable", "addEditable", "forceRender", "removeEditable", "revision", "displayName", "EditorToolbarWrapper", "toolbarRef", "toolbarContainer", "toolbar", "appendChild", "removeChild", "semaphoreElementRef", "semaphoreElement", "semaphoreRef", "setRevision", "useState", "Date", "now", "refresh", "rerender", "createAttributeRef", "replace", "newSemaphore", "useLifeCycleSemaphoreSyncRef", "editorRefs", "useContext", "roots", "setRoots", "keys", "setData", "attributes", "setAttributes", "rootsAttributes", "shouldUpdateEditor", "onChangeData", "disableTwoWayDataBinding", "newData", "newAttributes", "differ", "getChanges", "change", "position", "range", "isAttached", "getData", "getChangedRoots", "changedRoot", "name", "getRootAttributes", "previousData", "previousAttributes", "onAddRoot", "evt", "prevRoots", "uniq", "from", "Set", "onDetachRoot", "filter", "editorData", "getFullData", "getRootsAttributes", "_externalSetData", "_externalSetAttributes", "toolbarElement", "dataKeys", "attributesKeys", "every", "includes", "Error", "editorAttributes", "addedKeys", "newRoots", "removedKeys", "removedRoots", "previousState", "newState", "previousStateKeys", "newStateKeys", "hasModifiedData", "some", "JSON", "stringify", "rootsWithChangedAttributes", "_handleNewRoots", "addRoot", "isUndoable", "_handleRemovedRoots", "detachRoot", "_updateEditorData", "suppressErrorInCollaboration", "_updateEditorAttributes", "writer", "attr", "registerRootAttribute", "clearAttributes", "getRoot", "editableElements"]
}
